<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ“š Anki Study Cards - LeetCode Problems</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
        .card { background: rgba(255, 255, 255, 0.95); border-radius: 15px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); }
        .btn-easy { background: linear-gradient(45deg, #00b894, #00cec9); }
        .btn-medium { background: linear-gradient(45deg, #fdcb6e, #e17055); }
        .btn-hard { background: linear-gradient(45deg, #e17055, #d63031); }
        .stats-card { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); border-radius: 15px; padding: 1.5rem; }
        .navbar { box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15); }
        .navbar-brand { font-weight: 600; font-size: 1.3rem; }
        .nav-link { font-weight: 500; transition: all 0.3s ease; }
        .nav-link:hover { transform: translateY(-1px); }
        .nav-link.active { background: rgba(255, 255, 255, 0.1) !important; border-radius: 8px; }
    </style>
</head>
<body>
    <div class="container-fluid py-4">
        <!-- Navigation Bar -->
        <div class="row mb-4">
            <div class="col-12">
                <nav class="navbar navbar-expand-lg navbar-dark bg-dark rounded">
                    <div class="container-fluid">
                        <a class="navbar-brand" href="index.html">
                            <i class="fas fa-home me-2"></i>LeetCode Anki
                        </a>
                        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                        <div class="collapse navbar-collapse" id="navbarNav">
                            <ul class="navbar-nav me-auto">
                                <li class="nav-item">
                                    <a class="nav-link" href="index.html">
                                        <i class="fas fa-home me-1"></i>Home
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" href="problems.html">
                                        <i class="fas fa-list me-1"></i>Problems
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link active" href="cards.html">
                                        <i class="fas fa-graduation-cap me-1"></i>Study Cards
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" href="tags.html">
                                        <i class="fas fa-tags me-1"></i>Tags
                                    </a>
                                </li>
                            </ul>
                            <div class="navbar-nav">
                                <a class="nav-link" href="https://github.com/robinali34/leetcode-anki-web" target="_blank">
                                    <i class="fab fa-github me-1"></i>GitHub
                                </a>
                            </div>
                        </div>
                    </div>
                </nav>
            </div>
        </div>

        <div class="row mb-4">
            <div class="col-12 text-center">
                <h1 class="display-4 text-white mb-3">
                    <i class="fas fa-graduation-cap me-3"></i>Anki Study Cards
                </h1>
                <p class="lead text-white-50">Master LeetCode problems with spaced repetition learning</p>
            </div>
        </div>

        <div class="row mb-4">
            <div class="col-md-3">
                <div class="stats-card text-center">
                    <h3 class="text-primary" id="total-cards">0</h3>
                    <p>Total Cards</p>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card text-center">
                    <h3 class="text-success" id="new-cards">0</h3>
                    <p>New Cards</p>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card text-center">
                    <h3 class="text-warning" id="learning-cards">0</h3>
                    <p>Learning</p>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card text-center">
                    <h3 class="text-info" id="review-cards">0</h3>
                    <p>Due for Review</p>
                </div>
            </div>
        </div>

        <div class="row mb-4">
            <div class="col-12">
                <div class="card filter-section">
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-2">
                                <select class="form-select" id="difficulty-filter">
                                    <option value="">All Difficulties</option>
                                    <option value="Easy">Easy</option>
                                    <option value="Medium">Medium</option>
                                    <option value="Hard">Hard</option>
                                </select>
                            </div>
                            <div class="col-md-2">
                                <select class="form-select" id="card-type-filter">
                                    <option value="">All Types</option>
                                    <option value="Problem Statement">Problem Statement</option>
                                    <option value="Solution Approach">Solution Approach</option>
                                    <option value="Time Complexity">Time Complexity</option>
                                    <option value="Space Complexity">Space Complexity</option>
                                    <option value="Key Insights">Key Insights</option>
                                    <option value="Python Code">Python Code</option>
                                    <option value="Pseudocode">Pseudocode</option>
                                    <option value="Tags & Categories">Tags & Categories</option>
                                </select>
                            </div>
                            <div class="col-md-3">
                                <select class="form-select" id="problem-filter">
                                    <option value="">All Problems</option>
                                </select>
                            </div>
                            <div class="col-md-3">
                                <input type="text" class="form-control" id="search-filter" placeholder="Search cards...">
                            </div>
                            <div class="col-md-2">
                                <button class="btn btn-primary" onclick="startStudySession()">
                                    <i class="fas fa-play me-1"></i>Start Study Session
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row" id="cards-container">
            <!-- Cards will be populated here -->
        </div>

        <div class="row mt-4">
            <div class="col-12">
                <nav aria-label="Cards pagination">
                    <ul class="pagination justify-content-center" id="pagination"></ul>
                </nav>
            </div>
        </div>

        <div class="modal fade" id="studyModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Study Session</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="card" id="study-card">
                            <div class="card-body text-center">
                                <div id="card-front"></div>
                                <div id="card-back" style="display: none;"></div>
                            </div>
                        </div>
                        <div class="text-center mt-3" id="study-controls">
                            <button class="btn btn-success" onclick="showAnswer()">Show Answer</button>
                        </div>
                        <div class="text-center mt-3" id="answer-controls" style="display: none;">
                            <button class="btn btn-danger me-2" onclick="rateCard(1)">Again</button>
                            <button class="btn btn-warning me-2" onclick="rateCard(2)">Hard</button>
                            <button class="btn btn-info me-2" onclick="rateCard(3)">Good</button>
                            <button class="btn btn-success me-2" onclick="rateCard(4)">Easy</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // All cards data - this will be replaced with the actual data
        const sampleCards = [
        {
                "id": 11,
                "problemId": 1,
                "problemTitle": "Two Sum",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Two Sum problem ask you to do?",
                "back": "Problem 1: Two Sum - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 12,
                "problemId": 1,
                "problemTitle": "Two Sum",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Two Sum?",
                "back": "Algorithm: function twoSum(nums, target):\n    hashMap = {}\n    for i = 0 to nums.length - 1:\n        complement = target - nums[i]\n        if complement in hashMap:\n            return [hashMap[complement], i]\n  ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 13,
                "problemId": 1,
                "problemTitle": "Two Sum",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Two Sum solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 14,
                "problemId": 1,
                "problemTitle": "Two Sum",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Two Sum solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 15,
                "problemId": 1,
                "problemTitle": "Two Sum",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Two Sum?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Hash tables provide O(1) lookup time for fast access patterns",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 16,
                "problemId": 1,
                "problemTitle": "Two Sum",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Two Sum in Python?",
                "back": "```python\ndef twoSum(nums, target):\n    hash_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hash_map:\n            return [hash_map[complement], i]\n        hash_map[num] = i\n    return []\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 17,
                "problemId": 1,
                "problemTitle": "Two Sum",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Two Sum?",
                "back": "Tags: Array, Hash Table. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 18,
                "problemId": 1,
                "problemTitle": "Two Sum",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Two Sum",
                "back": "Input: Example input for Two Sum\nOutput: Expected output for Two Sum\nExplanation: Explanation of how to solve Two Sum",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 21,
                "problemId": 2,
                "problemTitle": "Add Two Numbers",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Add Two Numbers problem ask you to do?",
                "back": "Problem 2: Add Two Numbers - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 22,
                "problemId": 2,
                "problemTitle": "Add Two Numbers",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Add Two Numbers?",
                "back": "Algorithm: function addTwoNumbers(l1, l2):\n    dummy = new ListNode(0)\n    current = dummy\n    carry = 0\n    \n    while l1 != null OR l2 != null OR carry > 0:\n        x = l1.val if l1 != null else 0\n        y = ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 23,
                "problemId": 2,
                "problemTitle": "Add Two Numbers",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Add Two Numbers solution?",
                "back": "O(max(m,n)) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 24,
                "problemId": 2,
                "problemTitle": "Add Two Numbers",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Add Two Numbers solution?",
                "back": "O(max(m,n)) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 25,
                "problemId": 2,
                "problemTitle": "Add Two Numbers",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Add Two Numbers?",
                "back": "Use dummy nodes to simplify edge cases. Be careful about losing references when modifying links. Consider using two pointers for cycle detection or finding middle. Look for mathematical patterns or formulas",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 26,
                "problemId": 2,
                "problemTitle": "Add Two Numbers",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Add Two Numbers in Python?",
                "back": "```python\ndef addTwoNumbers(l1, l2):\n    dummy = ListNode(0)\n    current = dummy\n    carry = 0\n    \n    while l1 or l2 or carry:\n        x = l1.val if l1 else 0\n        y = l2.val if l2 else 0\n        total = x + y + carry\n        \n        carry = total // 10\n        current.next = ListNode(total % 10)\n        current = current.next\n        \n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 27,
                "problemId": 2,
                "problemTitle": "Add Two Numbers",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Add Two Numbers?",
                "back": "Tags: Linked List, Math, Recursion. This problem focuses on Linked List algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 28,
                "problemId": 2,
                "problemTitle": "Add Two Numbers",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Add Two Numbers",
                "back": "Input: Example input for Add Two Numbers\nOutput: Expected output for Add Two Numbers\nExplanation: Explanation of how to solve Add Two Numbers",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 31,
                "problemId": 3,
                "problemTitle": "Longest Substring Without Repeating Characters",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Longest Substring Without Repeating Characters problem ask you to do?",
                "back": "Problem 3: Longest Substring Without Repeating Characters - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 32,
                "problemId": 3,
                "problemTitle": "Longest Substring Without Repeating Characters",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Longest Substring Without Repeating Characters?",
                "back": "Algorithm: function lengthOfLongestSubstring(s):\n    charSet = new Set()\n    left = 0\n    maxLength = 0\n    \n    for right = 0 to s.length - 1:\n        while s[right] in charSet:\n            charSet.remove(s[lef...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 33,
                "problemId": 3,
                "problemTitle": "Longest Substring Without Repeating Characters",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Longest Substring Without Repeating Characters solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 34,
                "problemId": 3,
                "problemTitle": "Longest Substring Without Repeating Characters",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Longest Substring Without Repeating Characters solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 35,
                "problemId": 3,
                "problemTitle": "Longest Substring Without Repeating Characters",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Longest Substring Without Repeating Characters?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 36,
                "problemId": 3,
                "problemTitle": "Longest Substring Without Repeating Characters",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Longest Substring Without Repeating Characters in Python?",
                "back": "```python\ndef lengthOfLongestSubstring(s):\n    char_set = set()\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 37,
                "problemId": 3,
                "problemTitle": "Longest Substring Without Repeating Characters",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Longest Substring Without Repeating Characters?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 38,
                "problemId": 3,
                "problemTitle": "Longest Substring Without Repeating Characters",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Longest Substring Without Repeating Characters",
                "back": "Input: Example input for Longest Substring Without Repeating Characters\nOutput: Expected output for Longest Substring Without Repeating Characters\nExplanation: Explanation of how to solve Longest Substring Without Repeating Characters",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 41,
                "problemId": 4,
                "problemTitle": "Median of Two Sorted Arrays",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Median of Two Sorted Arrays problem ask you to do?",
                "back": "Problem 4: Median of Two Sorted Arrays - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 42,
                "problemId": 4,
                "problemTitle": "Median of Two Sorted Arrays",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Median of Two Sorted Arrays?",
                "back": "Algorithm: function findMedianSortedArrays(nums1, nums2):\n    if nums1.length > nums2.length:\n        swap(nums1, nums2)\n    \n    m, n = nums1.length, nums2.length\n    left, right = 0, m\n    \n    while left <= r...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 43,
                "problemId": 4,
                "problemTitle": "Median of Two Sorted Arrays",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Median of Two Sorted Arrays solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 44,
                "problemId": 4,
                "problemTitle": "Median of Two Sorted Arrays",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Median of Two Sorted Arrays solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 45,
                "problemId": 4,
                "problemTitle": "Median of Two Sorted Arrays",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Median of Two Sorted Arrays?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 46,
                "problemId": 4,
                "problemTitle": "Median of Two Sorted Arrays",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Median of Two Sorted Arrays in Python?",
                "back": "```python\ndef findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    \n    while left <= right:\n        partition_x = (left + right) // 2\n        partition_y = (m + n + 1) // 2 - partition_x\n        \n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]\n        min_right_x = float('inf') if partition_x == m else nums1[partition_x]\n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]\n        min_right_y = float('inf') if partition_y == n else nums2[partition_y]\n        \n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            if (m + n) % 2 == 0:\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            else:\n                return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            right = partition_x - 1\n        else:\n            left = partition_x + 1\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 47,
                "problemId": 4,
                "problemTitle": "Median of Two Sorted Arrays",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Median of Two Sorted Arrays?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 48,
                "problemId": 4,
                "problemTitle": "Median of Two Sorted Arrays",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Median of Two Sorted Arrays",
                "back": "Input: Example input for Median of Two Sorted Arrays\nOutput: Expected output for Median of Two Sorted Arrays\nExplanation: Explanation of how to solve Median of Two Sorted Arrays",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 51,
                "problemId": 5,
                "problemTitle": "Longest Palindromic Substring",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Longest Palindromic Substring problem ask you to do?",
                "back": "Find the longest palindromic substring in a string using dynamic programming approach.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 52,
                "problemId": 5,
                "problemTitle": "Longest Palindromic Substring",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Longest Palindromic Substring?",
                "back": "Algorithm: function longestPalindrome(s):\n    if s.length < 2:\n        return s\n    \n    start = 0\n    maxLength = 1\n    \n    for i = 0 to s.length - 1:\n        // Check odd length palindromes\n        len1 = exp...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 53,
                "problemId": 5,
                "problemTitle": "Longest Palindromic Substring",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Longest Palindromic Substring solution?",
                "back": "O(n\u00b2) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 54,
                "problemId": 5,
                "problemTitle": "Longest Palindromic Substring",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Longest Palindromic Substring solution?",
                "back": "O(n\u00b2) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 55,
                "problemId": 5,
                "problemTitle": "Longest Palindromic Substring",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Longest Palindromic Substring?",
                "back": "DP table approach. Fill diagonally. Check palindrome conditions",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 56,
                "problemId": 5,
                "problemTitle": "Longest Palindromic Substring",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Longest Palindromic Substring in Python?",
                "back": "```python\ndef longestPalindrome(s):\n    if len(s) < 2:\n        return s\n    \n    start = 0\n    max_length = 1\n    \n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    for i in range(len(s)):\n        # Check odd length palindromes\n        len1 = expand_around_center(i, i)\n        # Check even length palindromes\n        len2 = expand_around_center(i, i + 1)\n        \n        curr_len = max(len1, len2)\n        if curr_len > max_length:\n            start = i - (curr_len - 1) // 2\n            max_length = curr_len\n    \n    return s[start:start + max_length]\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 57,
                "problemId": 5,
                "problemTitle": "Longest Palindromic Substring",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Longest Palindromic Substring?",
                "back": "Tags: String, Dynamic Programming. This problem focuses on String algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 58,
                "problemId": 5,
                "problemTitle": "Longest Palindromic Substring",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Longest Palindromic Substring",
                "back": "Input: s = \"babad\"\nOutput: \"bab\"\nExplanation: Longest palindromic substring is 'bab'.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 61,
                "problemId": 6,
                "problemTitle": "Zigzag Conversion",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Zigzag Conversion problem ask you to do?",
                "back": "Problem 6: Zigzag Conversion - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 62,
                "problemId": 6,
                "problemTitle": "Zigzag Conversion",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Zigzag Conversion?",
                "back": "Algorithm: function convert(s, numRows):\n    if numRows == 1:\n        return s\n    \n    rows = new Array(numRows).fill(\"\")\n    currentRow = 0\n    goingDown = false\n    \n    for char in s:\n        rows[currentRow...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 63,
                "problemId": 6,
                "problemTitle": "Zigzag Conversion",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Zigzag Conversion solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 64,
                "problemId": 6,
                "problemTitle": "Zigzag Conversion",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Zigzag Conversion solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 65,
                "problemId": 6,
                "problemTitle": "Zigzag Conversion",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Zigzag Conversion?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 66,
                "problemId": 6,
                "problemTitle": "Zigzag Conversion",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Zigzag Conversion in Python?",
                "back": "```python\ndef convert(s, numRows):\n    if numRows == 1:\n        return s\n    \n    rows = [\"\"] * numRows\n    current_row = 0\n    going_down = False\n    \n    for char in s:\n        rows[current_row] += char\n        \n        if current_row == 0 or current_row == numRows - 1:\n            going_down = not going_down\n        \n        if going_down:\n            current_row += 1\n        else:\n            current_row -= 1\n    \n    return \"\".join(rows)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 67,
                "problemId": 6,
                "problemTitle": "Zigzag Conversion",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Zigzag Conversion?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 68,
                "problemId": 6,
                "problemTitle": "Zigzag Conversion",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Zigzag Conversion",
                "back": "Input: Example input for Zigzag Conversion\nOutput: Expected output for Zigzag Conversion\nExplanation: Explanation of how to solve Zigzag Conversion",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 71,
                "problemId": 7,
                "problemTitle": "Reverse Integer",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Reverse Integer problem ask you to do?",
                "back": "Problem 7: Reverse Integer - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 72,
                "problemId": 7,
                "problemTitle": "Reverse Integer",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Reverse Integer?",
                "back": "Algorithm: function reverse(x):\n    isNegative = x < 0\n    x = abs(x)\n    reversed = 0\n    \n    while x > 0:\n        digit = x % 10\n        reversed = reversed * 10 + digit\n        x = x // 10\n    \n    if isNega...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 73,
                "problemId": 7,
                "problemTitle": "Reverse Integer",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Reverse Integer solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 74,
                "problemId": 7,
                "problemTitle": "Reverse Integer",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Reverse Integer solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 75,
                "problemId": 7,
                "problemTitle": "Reverse Integer",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Reverse Integer?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 76,
                "problemId": 7,
                "problemTitle": "Reverse Integer",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Reverse Integer in Python?",
                "back": "```python\ndef reverse(x):\n    is_negative = x < 0\n    x = abs(x)\n    reversed_num = 0\n    \n    while x > 0:\n        digit = x % 10\n        reversed_num = reversed_num * 10 + digit\n        x //= 10\n    \n    if is_negative:\n        reversed_num = -reversed_num\n    \n    if reversed_num < -2**31 or reversed_num > 2**31 - 1:\n        return 0\n    \n    return reversed_num\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 77,
                "problemId": 7,
                "problemTitle": "Reverse Integer",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Reverse Integer?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 78,
                "problemId": 7,
                "problemTitle": "Reverse Integer",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Reverse Integer",
                "back": "Input: Example input for Reverse Integer\nOutput: Expected output for Reverse Integer\nExplanation: Explanation of how to solve Reverse Integer",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 81,
                "problemId": 8,
                "problemTitle": "String to Integer (atoi)",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the String to Integer (atoi) problem ask you to do?",
                "back": "Problem 8: String to Integer (atoi) - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 82,
                "problemId": 8,
                "problemTitle": "String to Integer (atoi)",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve String to Integer (atoi)?",
                "back": "Algorithm: function myAtoi(s):\n    i = 0\n    n = s.length\n    \n    // Skip whitespace\n    while i < n and s[i] == ' ':\n        i++\n    \n    if i == n:\n        return 0\n    \n    // Handle sign\n    sign = 1\n    if...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 83,
                "problemId": 8,
                "problemTitle": "String to Integer (atoi)",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal String to Integer (atoi) solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 84,
                "problemId": 8,
                "problemTitle": "String to Integer (atoi)",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal String to Integer (atoi) solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 85,
                "problemId": 8,
                "problemTitle": "String to Integer (atoi)",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving String to Integer (atoi)?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 86,
                "problemId": 8,
                "problemTitle": "String to Integer (atoi)",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement String to Integer (atoi) in Python?",
                "back": "```python\ndef myAtoi(s):\n    i = 0\n    n = len(s)\n    \n    # Skip whitespace\n    while i < n and s[i] == ' ':\n        i += 1\n    \n    if i == n:\n        return 0\n    \n    # Handle sign\n    sign = 1\n    if s[i] in ['+', '-']:\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    \n    # Convert digits\n    result = 0\n    while i < n and s[i].isdigit():\n        digit = int(s[i])\n        result = result * 10 + digit\n        \n        # Check overflow\n        if sign == 1 and result > 2**31 - 1:\n            return 2**31 - 1\n        if sign == -1 and result > 2**31:\n            return -2**31\n        \n        i += 1\n    \n    return sign * result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 87,
                "problemId": 8,
                "problemTitle": "String to Integer (atoi)",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for String to Integer (atoi)?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 88,
                "problemId": 8,
                "problemTitle": "String to Integer (atoi)",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for String to Integer (atoi)",
                "back": "Input: Example input for String to Integer (atoi)\nOutput: Expected output for String to Integer (atoi)\nExplanation: Explanation of how to solve String to Integer (atoi)",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 91,
                "problemId": 9,
                "problemTitle": "Palindrome Number",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Palindrome Number problem ask you to do?",
                "back": "Problem 9: Palindrome Number - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 92,
                "problemId": 9,
                "problemTitle": "Palindrome Number",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Palindrome Number?",
                "back": "Algorithm: function isPalindrome(x):\n    if x < 0:\n        return false\n    \n    original = x\n    reversed = 0\n    \n    while x > 0:\n        digit = x % 10\n        reversed = reversed * 10 + digit\n        x = x ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 93,
                "problemId": 9,
                "problemTitle": "Palindrome Number",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Palindrome Number solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 94,
                "problemId": 9,
                "problemTitle": "Palindrome Number",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Palindrome Number solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 95,
                "problemId": 9,
                "problemTitle": "Palindrome Number",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Palindrome Number?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 96,
                "problemId": 9,
                "problemTitle": "Palindrome Number",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Palindrome Number in Python?",
                "back": "```python\ndef isPalindrome(x):\n    if x < 0:\n        return False\n    \n    original = x\n    reversed_num = 0\n    \n    while x > 0:\n        digit = x % 10\n        reversed_num = reversed_num * 10 + digit\n        x //= 10\n    \n    return original == reversed_num\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 97,
                "problemId": 9,
                "problemTitle": "Palindrome Number",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Palindrome Number?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 98,
                "problemId": 9,
                "problemTitle": "Palindrome Number",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Palindrome Number",
                "back": "Input: Example input for Palindrome Number\nOutput: Expected output for Palindrome Number\nExplanation: Explanation of how to solve Palindrome Number",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 101,
                "problemId": 10,
                "problemTitle": "Regular Expression Matching",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Regular Expression Matching problem ask you to do?",
                "back": "Implement regular expression matching with support for '.' and '*' using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 102,
                "problemId": 10,
                "problemTitle": "Regular Expression Matching",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Regular Expression Matching?",
                "back": "DP table for pattern matching\nHandle * and . operators",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 103,
                "problemId": 10,
                "problemTitle": "Regular Expression Matching",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Regular Expression Matching solution?",
                "back": "O(mn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 104,
                "problemId": 10,
                "problemTitle": "Regular Expression Matching",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Regular Expression Matching solution?",
                "back": "O(mn) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 105,
                "problemId": 10,
                "problemTitle": "Regular Expression Matching",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Regular Expression Matching?",
                "back": "Handle * and . operators. Use DP table. Pattern matching",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 106,
                "problemId": 10,
                "problemTitle": "Regular Expression Matching",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Regular Expression Matching in Python?",
                "back": "```python\nDP approach for regex matching\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 107,
                "problemId": 10,
                "problemTitle": "Regular Expression Matching",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Regular Expression Matching?",
                "back": "Tags: String, Dynamic Programming, Recursion. This problem focuses on String algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 108,
                "problemId": 10,
                "problemTitle": "Regular Expression Matching",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Regular Expression Matching",
                "back": "Input: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: Pattern matches the string.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 111,
                "problemId": 11,
                "problemTitle": "Container With Most Water",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Container With Most Water problem ask you to do?",
                "back": "Problem 11: Container With Most Water - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 112,
                "problemId": 11,
                "problemTitle": "Container With Most Water",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Container With Most Water?",
                "back": "Algorithm: function maxArea(height):\n    maxArea = 0\n    left = 0\n    right = height.length - 1\n    \n    while left < right:\n        width = right - left\n        h = min(height[left], height[right])\n        area...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 113,
                "problemId": 11,
                "problemTitle": "Container With Most Water",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Container With Most Water solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 114,
                "problemId": 11,
                "problemTitle": "Container With Most Water",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Container With Most Water solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 115,
                "problemId": 11,
                "problemTitle": "Container With Most Water",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Container With Most Water?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 116,
                "problemId": 11,
                "problemTitle": "Container With Most Water",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Container With Most Water in Python?",
                "back": "```python\ndef maxArea(height):\n    max_area = 0\n    left, right = 0, len(height) - 1\n    \n    while left < right:\n        width = right - left\n        h = min(height[left], height[right])\n        area = width * h\n        max_area = max(max_area, area)\n        \n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_area\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 117,
                "problemId": 11,
                "problemTitle": "Container With Most Water",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Container With Most Water?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 118,
                "problemId": 11,
                "problemTitle": "Container With Most Water",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Container With Most Water",
                "back": "Input: Example input for Container With Most Water\nOutput: Expected output for Container With Most Water\nExplanation: Explanation of how to solve Container With Most Water",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 121,
                "problemId": 12,
                "problemTitle": "Integer to Roman",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Integer to Roman problem ask you to do?",
                "back": "Problem 12: Integer to Roman - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 122,
                "problemId": 12,
                "problemTitle": "Integer to Roman",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Integer to Roman?",
                "back": "Algorithm: function intToRoman(num):\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    \n    result = \"\"...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 123,
                "problemId": 12,
                "problemTitle": "Integer to Roman",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Integer to Roman solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 124,
                "problemId": 12,
                "problemTitle": "Integer to Roman",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Integer to Roman solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 125,
                "problemId": 12,
                "problemTitle": "Integer to Roman",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Integer to Roman?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 126,
                "problemId": 12,
                "problemTitle": "Integer to Roman",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Integer to Roman in Python?",
                "back": "```python\ndef intToRoman(num):\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    \n    result = \"\"\n    \n    for i in range(len(values)):\n        while num >= values[i]:\n            result += symbols[i]\n            num -= values[i]\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 127,
                "problemId": 12,
                "problemTitle": "Integer to Roman",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Integer to Roman?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 128,
                "problemId": 12,
                "problemTitle": "Integer to Roman",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Integer to Roman",
                "back": "Input: Example input for Integer to Roman\nOutput: Expected output for Integer to Roman\nExplanation: Explanation of how to solve Integer to Roman",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 131,
                "problemId": 13,
                "problemTitle": "Roman to Integer",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Roman to Integer problem ask you to do?",
                "back": "Problem 13: Roman to Integer - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 132,
                "problemId": 13,
                "problemTitle": "Roman to Integer",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Roman to Integer?",
                "back": "Algorithm: function romanToInt(s):\n    romanValues = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    \n    result = 0\n    prevValue = 0\n    \n    for i = s.length - 1 to...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 133,
                "problemId": 13,
                "problemTitle": "Roman to Integer",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Roman to Integer solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 134,
                "problemId": 13,
                "problemTitle": "Roman to Integer",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Roman to Integer solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 135,
                "problemId": 13,
                "problemTitle": "Roman to Integer",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Roman to Integer?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 136,
                "problemId": 13,
                "problemTitle": "Roman to Integer",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Roman to Integer in Python?",
                "back": "```python\ndef romanToInt(s):\n    roman_values = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    \n    result = 0\n    prev_value = 0\n    \n    for i in range(len(s) - 1, -1, -1):\n        current_value = roman_values[s[i]]\n        \n        if current_value < prev_value:\n            result -= current_value\n        else:\n            result += current_value\n        \n        prev_value = current_value\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 137,
                "problemId": 13,
                "problemTitle": "Roman to Integer",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Roman to Integer?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 138,
                "problemId": 13,
                "problemTitle": "Roman to Integer",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Roman to Integer",
                "back": "Input: Example input for Roman to Integer\nOutput: Expected output for Roman to Integer\nExplanation: Explanation of how to solve Roman to Integer",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 141,
                "problemId": 14,
                "problemTitle": "Longest Common Prefix",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Longest Common Prefix problem ask you to do?",
                "back": "Problem 14: Longest Common Prefix - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 142,
                "problemId": 14,
                "problemTitle": "Longest Common Prefix",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Longest Common Prefix?",
                "back": "Algorithm: function longestCommonPrefix(strs):\n    if strs.length == 0:\n        return \"\"\n    \n    prefix = strs[0]\n    \n    for i = 1 to strs.length - 1:\n        while strs[i].indexOf(prefix) != 0:\n            ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 143,
                "problemId": 14,
                "problemTitle": "Longest Common Prefix",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Longest Common Prefix solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 144,
                "problemId": 14,
                "problemTitle": "Longest Common Prefix",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Longest Common Prefix solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 145,
                "problemId": 14,
                "problemTitle": "Longest Common Prefix",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Longest Common Prefix?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 146,
                "problemId": 14,
                "problemTitle": "Longest Common Prefix",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Longest Common Prefix in Python?",
                "back": "```python\ndef longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    \n    prefix = strs[0]\n    \n    for i in range(1, len(strs)):\n        while strs[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 147,
                "problemId": 14,
                "problemTitle": "Longest Common Prefix",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Longest Common Prefix?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 148,
                "problemId": 14,
                "problemTitle": "Longest Common Prefix",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Longest Common Prefix",
                "back": "Input: Example input for Longest Common Prefix\nOutput: Expected output for Longest Common Prefix\nExplanation: Explanation of how to solve Longest Common Prefix",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 151,
                "problemId": 15,
                "problemTitle": "3Sum",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the 3Sum problem ask you to do?",
                "back": "Problem 15: 3Sum - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 152,
                "problemId": 15,
                "problemTitle": "3Sum",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve 3Sum?",
                "back": "Algorithm: function threeSum(nums):\n    result = []\n    sort(nums)\n    \n    for i = 0 to nums.length - 3:\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        \n        left = i + 1\n        rig...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 153,
                "problemId": 15,
                "problemTitle": "3Sum",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal 3Sum solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 154,
                "problemId": 15,
                "problemTitle": "3Sum",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal 3Sum solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 155,
                "problemId": 15,
                "problemTitle": "3Sum",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving 3Sum?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 156,
                "problemId": 15,
                "problemTitle": "3Sum",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement 3Sum in Python?",
                "back": "```python\ndef threeSum(nums):\n    result = []\n    nums.sort()\n    \n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        \n        left = i + 1\n        right = len(nums) - 1\n        \n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            \n            if total == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 157,
                "problemId": 15,
                "problemTitle": "3Sum",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for 3Sum?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 158,
                "problemId": 15,
                "problemTitle": "3Sum",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for 3Sum",
                "back": "Input: Example input for 3Sum\nOutput: Expected output for 3Sum\nExplanation: Explanation of how to solve 3Sum",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 161,
                "problemId": 16,
                "problemTitle": "3Sum Closest",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the 3Sum Closest problem ask you to do?",
                "back": "Problem 16: 3Sum Closest - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 162,
                "problemId": 16,
                "problemTitle": "3Sum Closest",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve 3Sum Closest?",
                "back": "Algorithm: function threeSumClosest(nums, target):\n    nums.sort()\n    closest = nums[0] + nums[1] + nums[2]\n    \n    for i = 0 to nums.length - 2:\n        left = i + 1\n        right = nums.length - 1\n        \n ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 163,
                "problemId": 16,
                "problemTitle": "3Sum Closest",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal 3Sum Closest solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 164,
                "problemId": 16,
                "problemTitle": "3Sum Closest",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal 3Sum Closest solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 165,
                "problemId": 16,
                "problemTitle": "3Sum Closest",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving 3Sum Closest?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 166,
                "problemId": 16,
                "problemTitle": "3Sum Closest",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement 3Sum Closest in Python?",
                "back": "```python\ndef threeSumClosest(nums, target):\n    nums.sort()\n    closest = nums[0] + nums[1] + nums[2]\n    \n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            \n            if abs(total - target) < abs(closest - target):\n                closest = total\n            \n            if total < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return closest\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 167,
                "problemId": 16,
                "problemTitle": "3Sum Closest",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for 3Sum Closest?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 168,
                "problemId": 16,
                "problemTitle": "3Sum Closest",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for 3Sum Closest",
                "back": "Input: Example input for 3Sum Closest\nOutput: Expected output for 3Sum Closest\nExplanation: Explanation of how to solve 3Sum Closest",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 171,
                "problemId": 17,
                "problemTitle": "Letter Combinations of a Phone Number",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Letter Combinations of a Phone Number problem ask you to do?",
                "back": "Problem 17: Letter Combinations of a Phone Number - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 172,
                "problemId": 17,
                "problemTitle": "Letter Combinations of a Phone Number",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Letter Combinations of a Phone Number?",
                "back": "Algorithm: function letterCombinations(digits):\n    if digits.length == 0:\n        return []\n    \n    phoneMap = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n        '6': 'mno', '7': 'pqrs', '8': 't...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 173,
                "problemId": 17,
                "problemTitle": "Letter Combinations of a Phone Number",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Letter Combinations of a Phone Number solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 174,
                "problemId": 17,
                "problemTitle": "Letter Combinations of a Phone Number",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Letter Combinations of a Phone Number solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 175,
                "problemId": 17,
                "problemTitle": "Letter Combinations of a Phone Number",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Letter Combinations of a Phone Number?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 176,
                "problemId": 17,
                "problemTitle": "Letter Combinations of a Phone Number",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Letter Combinations of a Phone Number in Python?",
                "back": "```python\ndef letterCombinations(digits):\n    if not digits:\n        return []\n    \n    phone_map = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n    }\n    \n    result = []\n    \n    def backtrack(index, current):\n        if index == len(digits):\n            result.append(current)\n            return\n        \n        letters = phone_map[digits[index]]\n        for letter in letters:\n            backtrack(index + 1, current + letter)\n    \n    backtrack(0, \"\")\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 177,
                "problemId": 17,
                "problemTitle": "Letter Combinations of a Phone Number",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Letter Combinations of a Phone Number?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 178,
                "problemId": 17,
                "problemTitle": "Letter Combinations of a Phone Number",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Letter Combinations of a Phone Number",
                "back": "Input: Example input for Letter Combinations of a Phone Number\nOutput: Expected output for Letter Combinations of a Phone Number\nExplanation: Explanation of how to solve Letter Combinations of a Phone Number",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 181,
                "problemId": 18,
                "problemTitle": "4Sum",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the 4Sum problem ask you to do?",
                "back": "Problem 18: 4Sum - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 182,
                "problemId": 18,
                "problemTitle": "4Sum",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve 4Sum?",
                "back": "Algorithm: function fourSum(nums, target):\n    nums.sort()\n    result = []\n    \n    for i = 0 to nums.length - 3:\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        \n        for j = i + 1 to...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 183,
                "problemId": 18,
                "problemTitle": "4Sum",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal 4Sum solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 184,
                "problemId": 18,
                "problemTitle": "4Sum",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal 4Sum solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 185,
                "problemId": 18,
                "problemTitle": "4Sum",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving 4Sum?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 186,
                "problemId": 18,
                "problemTitle": "4Sum",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement 4Sum in Python?",
                "back": "```python\ndef fourSum(nums, target):\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        \n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j-1]:\n                continue\n            \n            left, right = j + 1, len(nums) - 1\n            \n            while left < right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n                \n                if total == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    \n                    while left < right and nums[left] == nums[left+1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:\n                        right -= 1\n                    \n                    left += 1\n                    right -= 1\n                elif total < target:\n                    left += 1\n                else:\n                    right -= 1\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 187,
                "problemId": 18,
                "problemTitle": "4Sum",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for 4Sum?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 188,
                "problemId": 18,
                "problemTitle": "4Sum",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for 4Sum",
                "back": "Input: Example input for 4Sum\nOutput: Expected output for 4Sum\nExplanation: Explanation of how to solve 4Sum",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 191,
                "problemId": 19,
                "problemTitle": "Remove Nth Node From End of List",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Remove Nth Node From End of List problem ask you to do?",
                "back": "Problem 19: Remove Nth Node From End of List - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 192,
                "problemId": 19,
                "problemTitle": "Remove Nth Node From End of List",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Remove Nth Node From End of List?",
                "back": "Algorithm: function removeNthFromEnd(head, n):\n    dummy = new ListNode(0)\n    dummy.next = head\n    \n    first = dummy\n    second = dummy\n    \n    // Move first pointer n+1 steps ahead\n    for i = 1 to n+1:\n   ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 193,
                "problemId": 19,
                "problemTitle": "Remove Nth Node From End of List",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Remove Nth Node From End of List solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 194,
                "problemId": 19,
                "problemTitle": "Remove Nth Node From End of List",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Remove Nth Node From End of List solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 195,
                "problemId": 19,
                "problemTitle": "Remove Nth Node From End of List",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Remove Nth Node From End of List?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 196,
                "problemId": 19,
                "problemTitle": "Remove Nth Node From End of List",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Remove Nth Node From End of List in Python?",
                "back": "```python\ndef removeNthFromEnd(head, n):\n    dummy = ListNode(0)\n    dummy.next = head\n    \n    first = dummy\n    second = dummy\n    \n    # Move first pointer n+1 steps ahead\n    for i in range(n + 1):\n        first = first.next\n    \n    # Move both pointers until first reaches end\n    while first:\n        first = first.next\n        second = second.next\n    \n    # Remove the nth node from end\n    second.next = second.next.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 197,
                "problemId": 19,
                "problemTitle": "Remove Nth Node From End of List",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Remove Nth Node From End of List?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 198,
                "problemId": 19,
                "problemTitle": "Remove Nth Node From End of List",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Remove Nth Node From End of List",
                "back": "Input: Example input for Remove Nth Node From End of List\nOutput: Expected output for Remove Nth Node From End of List\nExplanation: Explanation of how to solve Remove Nth Node From End of List",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 201,
                "problemId": 20,
                "problemTitle": "Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Valid Parentheses problem ask you to do?",
                "back": "Problem 20: Valid Parentheses - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 202,
                "problemId": 20,
                "problemTitle": "Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Valid Parentheses?",
                "back": "Algorithm: function isValid(s):\n    stack = []\n    brackets = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    }\n    \n    for char in s:\n        if char in brackets.values():\n            stack.push(cha...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 203,
                "problemId": 20,
                "problemTitle": "Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Valid Parentheses solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 204,
                "problemId": 20,
                "problemTitle": "Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Valid Parentheses solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 205,
                "problemId": 20,
                "problemTitle": "Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Valid Parentheses?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 206,
                "problemId": 20,
                "problemTitle": "Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Valid Parentheses in Python?",
                "back": "```python\ndef isValid(s):\n    stack = []\n    brackets = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    }\n    \n    for char in s:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets:\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    \n    return len(stack) == 0\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 207,
                "problemId": 20,
                "problemTitle": "Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Valid Parentheses?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 208,
                "problemId": 20,
                "problemTitle": "Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Valid Parentheses",
                "back": "Input: Example input for Valid Parentheses\nOutput: Expected output for Valid Parentheses\nExplanation: Explanation of how to solve Valid Parentheses",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 211,
                "problemId": 21,
                "problemTitle": "Merge Two Sorted Lists",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Merge Two Sorted Lists problem ask you to do?",
                "back": "Problem 21: Merge Two Sorted Lists - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 212,
                "problemId": 21,
                "problemTitle": "Merge Two Sorted Lists",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Merge Two Sorted Lists?",
                "back": "Algorithm: function mergeTwoLists(l1, l2):\n    dummy = new ListNode(0)\n    current = dummy\n    \n    while l1 != null and l2 != null:\n        if l1.val <= l2.val:\n            current.next = l1\n            l1 = l1...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 213,
                "problemId": 21,
                "problemTitle": "Merge Two Sorted Lists",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Merge Two Sorted Lists solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 214,
                "problemId": 21,
                "problemTitle": "Merge Two Sorted Lists",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Merge Two Sorted Lists solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 215,
                "problemId": 21,
                "problemTitle": "Merge Two Sorted Lists",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Merge Two Sorted Lists?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 216,
                "problemId": 21,
                "problemTitle": "Merge Two Sorted Lists",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Merge Two Sorted Lists in Python?",
                "back": "```python\ndef mergeTwoLists(l1, l2):\n    dummy = ListNode(0)\n    current = dummy\n    \n    while l1 and l2:\n        if l1.val <= l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    \n    # Attach remaining nodes\n    if l1:\n        current.next = l1\n    if l2:\n        current.next = l2\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 217,
                "problemId": 21,
                "problemTitle": "Merge Two Sorted Lists",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Merge Two Sorted Lists?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 218,
                "problemId": 21,
                "problemTitle": "Merge Two Sorted Lists",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Merge Two Sorted Lists",
                "back": "Input: Example input for Merge Two Sorted Lists\nOutput: Expected output for Merge Two Sorted Lists\nExplanation: Explanation of how to solve Merge Two Sorted Lists",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 221,
                "problemId": 22,
                "problemTitle": "Generate Parentheses",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Generate Parentheses problem ask you to do?",
                "back": "Problem 22: Generate Parentheses - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 222,
                "problemId": 22,
                "problemTitle": "Generate Parentheses",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Generate Parentheses?",
                "back": "Algorithm: function generateParenthesis(n):\n    result = []\n    backtrack(result, \"\", 0, 0, n)\n    return result\n\nfunction backtrack(result, current, open, close, max):\n    if current.length == max * 2:\n        ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 223,
                "problemId": 22,
                "problemTitle": "Generate Parentheses",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Generate Parentheses solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 224,
                "problemId": 22,
                "problemTitle": "Generate Parentheses",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Generate Parentheses solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 225,
                "problemId": 22,
                "problemTitle": "Generate Parentheses",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Generate Parentheses?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 226,
                "problemId": 22,
                "problemTitle": "Generate Parentheses",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Generate Parentheses in Python?",
                "back": "```python\ndef generateParenthesis(n):\n    result = []\n    \n    def backtrack(current, open_count, close_count):\n        if len(current) == n * 2:\n            result.append(current)\n            return\n        \n        if open_count < n:\n            backtrack(current + \"(\", open_count + 1, close_count)\n        if close_count < open_count:\n            backtrack(current + \")\", open_count, close_count + 1)\n    \n    backtrack(\"\", 0, 0)\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 227,
                "problemId": 22,
                "problemTitle": "Generate Parentheses",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Generate Parentheses?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 228,
                "problemId": 22,
                "problemTitle": "Generate Parentheses",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Generate Parentheses",
                "back": "Input: Example input for Generate Parentheses\nOutput: Expected output for Generate Parentheses\nExplanation: Explanation of how to solve Generate Parentheses",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 231,
                "problemId": 23,
                "problemTitle": "Merge k Sorted Lists",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Merge k Sorted Lists problem ask you to do?",
                "back": "Problem 23: Merge k Sorted Lists - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 232,
                "problemId": 23,
                "problemTitle": "Merge k Sorted Lists",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Merge k Sorted Lists?",
                "back": "Algorithm: function mergeKLists(lists):\n    if lists.length == 0:\n        return null\n    \n    minHeap = new PriorityQueue()\n    \n    // Add first node of each list to min heap\n    for list in lists:\n        if ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 233,
                "problemId": 23,
                "problemTitle": "Merge k Sorted Lists",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Merge k Sorted Lists solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 234,
                "problemId": 23,
                "problemTitle": "Merge k Sorted Lists",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Merge k Sorted Lists solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 235,
                "problemId": 23,
                "problemTitle": "Merge k Sorted Lists",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Merge k Sorted Lists?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 236,
                "problemId": 23,
                "problemTitle": "Merge k Sorted Lists",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Merge k Sorted Lists in Python?",
                "back": "```python\ndef mergeKLists(lists):\n    if not lists:\n        return None\n    \n    import heapq\n    \n    min_heap = []\n    \n    # Add first node of each list to min heap\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(min_heap, (lst.val, i, lst))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while min_heap:\n        val, i, node = heapq.heappop(min_heap)\n        current.next = node\n        current = current.next\n        \n        if node.next:\n            heapq.heappush(min_heap, (node.next.val, i, node.next))\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 237,
                "problemId": 23,
                "problemTitle": "Merge k Sorted Lists",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Merge k Sorted Lists?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 238,
                "problemId": 23,
                "problemTitle": "Merge k Sorted Lists",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Merge k Sorted Lists",
                "back": "Input: Example input for Merge k Sorted Lists\nOutput: Expected output for Merge k Sorted Lists\nExplanation: Explanation of how to solve Merge k Sorted Lists",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 241,
                "problemId": 24,
                "problemTitle": "Swap Nodes in Pairs",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Swap Nodes in Pairs problem ask you to do?",
                "back": "Problem 24: Swap Nodes in Pairs - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 242,
                "problemId": 24,
                "problemTitle": "Swap Nodes in Pairs",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Swap Nodes in Pairs?",
                "back": "Algorithm: function swapPairs(head):\n    if head == null or head.next == null:\n        return head\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next != null a...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 243,
                "problemId": 24,
                "problemTitle": "Swap Nodes in Pairs",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Swap Nodes in Pairs solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 244,
                "problemId": 24,
                "problemTitle": "Swap Nodes in Pairs",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Swap Nodes in Pairs solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 245,
                "problemId": 24,
                "problemTitle": "Swap Nodes in Pairs",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Swap Nodes in Pairs?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 246,
                "problemId": 24,
                "problemTitle": "Swap Nodes in Pairs",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Swap Nodes in Pairs in Python?",
                "back": "```python\ndef swapPairs(head):\n    if not head or not head.next:\n        return head\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next and current.next.next:\n        first = current.next\n        second = current.next.next\n        \n        # Swap the pairs\n        first.next = second.next\n        second.next = first\n        current.next = second\n        \n        current = first\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 247,
                "problemId": 24,
                "problemTitle": "Swap Nodes in Pairs",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Swap Nodes in Pairs?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 248,
                "problemId": 24,
                "problemTitle": "Swap Nodes in Pairs",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Swap Nodes in Pairs",
                "back": "Input: Example input for Swap Nodes in Pairs\nOutput: Expected output for Swap Nodes in Pairs\nExplanation: Explanation of how to solve Swap Nodes in Pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 251,
                "problemId": 25,
                "problemTitle": "Reverse Nodes in k-Group",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Reverse Nodes in k-Group problem ask you to do?",
                "back": "Problem 25: Reverse Nodes in k-Group - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 252,
                "problemId": 25,
                "problemTitle": "Reverse Nodes in k-Group",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Reverse Nodes in k-Group?",
                "back": "Algorithm: function reverseKGroup(head, k):\n    if head == null or k == 1:\n        return head\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next != null:\n    ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 253,
                "problemId": 25,
                "problemTitle": "Reverse Nodes in k-Group",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Reverse Nodes in k-Group solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 254,
                "problemId": 25,
                "problemTitle": "Reverse Nodes in k-Group",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Reverse Nodes in k-Group solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 255,
                "problemId": 25,
                "problemTitle": "Reverse Nodes in k-Group",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Reverse Nodes in k-Group?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 256,
                "problemId": 25,
                "problemTitle": "Reverse Nodes in k-Group",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Reverse Nodes in k-Group in Python?",
                "back": "```python\ndef reverseKGroup(head, k):\n    if not head or k == 1:\n        return head\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Check if we have k nodes\n        count = 0\n        temp = current.next\n        while temp and count < k:\n            temp = temp.next\n            count += 1\n        \n        if count < k:\n            break\n        \n        # Reverse k nodes\n        prev = current.next\n        curr = prev.next\n        \n        for i in range(1, k):\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        # Connect the reversed group\n        current.next.next = curr\n        current.next = prev\n        current = current.next.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 257,
                "problemId": 25,
                "problemTitle": "Reverse Nodes in k-Group",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Reverse Nodes in k-Group?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 258,
                "problemId": 25,
                "problemTitle": "Reverse Nodes in k-Group",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Reverse Nodes in k-Group",
                "back": "Input: Example input for Reverse Nodes in k-Group\nOutput: Expected output for Reverse Nodes in k-Group\nExplanation: Explanation of how to solve Reverse Nodes in k-Group",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 261,
                "problemId": 26,
                "problemTitle": "Remove Duplicates from Sorted Array",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Remove Duplicates from Sorted Array problem ask you to do?",
                "back": "Problem 26: Remove Duplicates from Sorted Array - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 262,
                "problemId": 26,
                "problemTitle": "Remove Duplicates from Sorted Array",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Remove Duplicates from Sorted Array?",
                "back": "Algorithm: function removeDuplicates(nums):\n    if nums.length == 0:\n        return 0\n    \n    k = 1\n    \n    for i = 1 to nums.length - 1:\n        if nums[i] != nums[i-1]:\n            nums[k] = nums[i]\n        ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 263,
                "problemId": 26,
                "problemTitle": "Remove Duplicates from Sorted Array",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Remove Duplicates from Sorted Array solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 264,
                "problemId": 26,
                "problemTitle": "Remove Duplicates from Sorted Array",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Remove Duplicates from Sorted Array solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 265,
                "problemId": 26,
                "problemTitle": "Remove Duplicates from Sorted Array",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Remove Duplicates from Sorted Array?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 266,
                "problemId": 26,
                "problemTitle": "Remove Duplicates from Sorted Array",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Remove Duplicates from Sorted Array in Python?",
                "back": "```python\ndef removeDuplicates(nums):\n    if not nums:\n        return 0\n    \n    k = 1\n    \n    for i in range(1, len(nums)):\n        if nums[i] != nums[i-1]:\n            nums[k] = nums[i]\n            k += 1\n    \n    return k\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 267,
                "problemId": 26,
                "problemTitle": "Remove Duplicates from Sorted Array",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Remove Duplicates from Sorted Array?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 268,
                "problemId": 26,
                "problemTitle": "Remove Duplicates from Sorted Array",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Remove Duplicates from Sorted Array",
                "back": "Input: Example input for Remove Duplicates from Sorted Array\nOutput: Expected output for Remove Duplicates from Sorted Array\nExplanation: Explanation of how to solve Remove Duplicates from Sorted Array",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 271,
                "problemId": 27,
                "problemTitle": "Remove Element",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Remove Element problem ask you to do?",
                "back": "Problem 27: Remove Element - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 272,
                "problemId": 27,
                "problemTitle": "Remove Element",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Remove Element?",
                "back": "function removeElement(nums, val):\n    k = 0\n    \n    for i = 0 to nums.length - 1:\n        if nums[i] != val:\n            nums[k] = nums[i]\n            k++\n    \n    return k",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 273,
                "problemId": 27,
                "problemTitle": "Remove Element",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Remove Element solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 274,
                "problemId": 27,
                "problemTitle": "Remove Element",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Remove Element solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 275,
                "problemId": 27,
                "problemTitle": "Remove Element",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Remove Element?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 276,
                "problemId": 27,
                "problemTitle": "Remove Element",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Remove Element in Python?",
                "back": "```python\ndef removeElement(nums, val):\n    k = 0\n    \n    for i in range(len(nums)):\n        if nums[i] != val:\n            nums[k] = nums[i]\n            k += 1\n    \n    return k\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 277,
                "problemId": 27,
                "problemTitle": "Remove Element",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Remove Element?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 278,
                "problemId": 27,
                "problemTitle": "Remove Element",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Remove Element",
                "back": "Input: Example input for Remove Element\nOutput: Expected output for Remove Element\nExplanation: Explanation of how to solve Remove Element",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 281,
                "problemId": 28,
                "problemTitle": "Find the Index of the First Occurrence in a String",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Find the Index of the First Occurrence in a String problem ask you to do?",
                "back": "Problem 28: Find the Index of the First Occurrence in a String - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 282,
                "problemId": 28,
                "problemTitle": "Find the Index of the First Occurrence in a String",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Find the Index of the First Occurrence in a String?",
                "back": "Algorithm: function strStr(haystack, needle):\n    if needle.length == 0:\n        return 0\n    \n    for i = 0 to haystack.length - needle.length:\n        for j = 0 to needle.length:\n            if haystack[i + j]...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 283,
                "problemId": 28,
                "problemTitle": "Find the Index of the First Occurrence in a String",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Find the Index of the First Occurrence in a String solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 284,
                "problemId": 28,
                "problemTitle": "Find the Index of the First Occurrence in a String",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Find the Index of the First Occurrence in a String solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 285,
                "problemId": 28,
                "problemTitle": "Find the Index of the First Occurrence in a String",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Find the Index of the First Occurrence in a String?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 286,
                "problemId": 28,
                "problemTitle": "Find the Index of the First Occurrence in a String",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Find the Index of the First Occurrence in a String in Python?",
                "back": "```python\ndef strStr(haystack, needle):\n    if not needle:\n        return 0\n    \n    for i in range(len(haystack) - len(needle) + 1):\n        for j in range(len(needle)):\n            if haystack[i + j] != needle[j]:\n                break\n            if j == len(needle) - 1:\n                return i\n    \n    return -1\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 287,
                "problemId": 28,
                "problemTitle": "Find the Index of the First Occurrence in a String",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Find the Index of the First Occurrence in a String?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 288,
                "problemId": 28,
                "problemTitle": "Find the Index of the First Occurrence in a String",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Find the Index of the First Occurrence in a String",
                "back": "Input: Example input for Find the Index of the First Occurrence in a String\nOutput: Expected output for Find the Index of the First Occurrence in a String\nExplanation: Explanation of how to solve Find the Index of the First Occurrence in a String",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 291,
                "problemId": 29,
                "problemTitle": "Divide Two Integers",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Divide Two Integers problem ask you to do?",
                "back": "Problem 29: Divide Two Integers - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 292,
                "problemId": 29,
                "problemTitle": "Divide Two Integers",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Divide Two Integers?",
                "back": "Algorithm: function divide(dividend, divisor):\n    if dividend == -2^31 and divisor == -1:\n        return 2^31 - 1\n    \n    negative = (dividend < 0) != (divisor < 0)\n    dividend = abs(dividend)\n    divisor = a...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 293,
                "problemId": 29,
                "problemTitle": "Divide Two Integers",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Divide Two Integers solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 294,
                "problemId": 29,
                "problemTitle": "Divide Two Integers",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Divide Two Integers solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 295,
                "problemId": 29,
                "problemTitle": "Divide Two Integers",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Divide Two Integers?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 296,
                "problemId": 29,
                "problemTitle": "Divide Two Integers",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Divide Two Integers in Python?",
                "back": "```python\ndef divide(dividend, divisor):\n    if dividend == -2**31 and divisor == -1:\n        return 2**31 - 1\n    \n    negative = (dividend < 0) != (divisor < 0)\n    dividend = abs(dividend)\n    divisor = abs(divisor)\n    \n    result = 0\n    while dividend >= divisor:\n        temp = divisor\n        multiple = 1\n        while dividend >= (temp << 1):\n            temp <<= 1\n            multiple <<= 1\n        dividend -= temp\n        result += multiple\n    \n    return -result if negative else result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 297,
                "problemId": 29,
                "problemTitle": "Divide Two Integers",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Divide Two Integers?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 298,
                "problemId": 29,
                "problemTitle": "Divide Two Integers",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Divide Two Integers",
                "back": "Input: Example input for Divide Two Integers\nOutput: Expected output for Divide Two Integers\nExplanation: Explanation of how to solve Divide Two Integers",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 301,
                "problemId": 30,
                "problemTitle": "Substring with Concatenation of All Words",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Substring with Concatenation of All Words problem ask you to do?",
                "back": "Problem 30: Substring with Concatenation of All Words - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 302,
                "problemId": 30,
                "problemTitle": "Substring with Concatenation of All Words",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Substring with Concatenation of All Words?",
                "back": "Algorithm: function findSubstring(s, words):\n    if not words or not s:\n        return []\n    \n    wordLength = words[0].length\n    wordCount = words.length\n    totalLength = wordLength * wordCount\n    result = ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 303,
                "problemId": 30,
                "problemTitle": "Substring with Concatenation of All Words",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Substring with Concatenation of All Words solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 304,
                "problemId": 30,
                "problemTitle": "Substring with Concatenation of All Words",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Substring with Concatenation of All Words solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 305,
                "problemId": 30,
                "problemTitle": "Substring with Concatenation of All Words",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Substring with Concatenation of All Words?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 306,
                "problemId": 30,
                "problemTitle": "Substring with Concatenation of All Words",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Substring with Concatenation of All Words in Python?",
                "back": "```python\ndef findSubstring(s, words):\n    if not words or not s:\n        return []\n    \n    word_length = len(words[0])\n    word_count = len(words)\n    total_length = word_length * word_count\n    result = []\n    \n    word_freq = {}\n    for word in words:\n        word_freq[word] = word_freq.get(word, 0) + 1\n    \n    for i in range(len(s) - total_length + 1):\n        seen = {}\n        for j in range(word_count):\n            word = s[i + j * word_length:i + (j + 1) * word_length]\n            if word not in word_freq:\n                break\n            seen[word] = seen.get(word, 0) + 1\n            if seen[word] > word_freq[word]:\n                break\n            if j == word_count - 1:\n                result.append(i)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 307,
                "problemId": 30,
                "problemTitle": "Substring with Concatenation of All Words",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Substring with Concatenation of All Words?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 308,
                "problemId": 30,
                "problemTitle": "Substring with Concatenation of All Words",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Substring with Concatenation of All Words",
                "back": "Input: Example input for Substring with Concatenation of All Words\nOutput: Expected output for Substring with Concatenation of All Words\nExplanation: Explanation of how to solve Substring with Concatenation of All Words",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 311,
                "problemId": 31,
                "problemTitle": "Next Permutation",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Next Permutation problem ask you to do?",
                "back": "Problem 31: Next Permutation - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 312,
                "problemId": 31,
                "problemTitle": "Next Permutation",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Next Permutation?",
                "back": "Algorithm: function nextPermutation(nums):\n    i = nums.length - 2\n    \n    // Find first decreasing element from right\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i--\n    \n    if i >= 0:\n        j = nu...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 313,
                "problemId": 31,
                "problemTitle": "Next Permutation",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Next Permutation solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 314,
                "problemId": 31,
                "problemTitle": "Next Permutation",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Next Permutation solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 315,
                "problemId": 31,
                "problemTitle": "Next Permutation",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Next Permutation?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 316,
                "problemId": 31,
                "problemTitle": "Next Permutation",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Next Permutation in Python?",
                "back": "```python\ndef nextPermutation(nums):\n    i = len(nums) - 2\n    \n    # Find first decreasing element from right\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    \n    if i >= 0:\n        j = len(nums) - 1\n        # Find element just larger than nums[i]\n        while j >= 0 and nums[j] <= nums[i]:\n            j -= 1\n        \n        # Swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n    \n    # Reverse the subarray after position i\n    left, right = i + 1, len(nums) - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 317,
                "problemId": 31,
                "problemTitle": "Next Permutation",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Next Permutation?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 318,
                "problemId": 31,
                "problemTitle": "Next Permutation",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Next Permutation",
                "back": "Input: Example input for Next Permutation\nOutput: Expected output for Next Permutation\nExplanation: Explanation of how to solve Next Permutation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 321,
                "problemId": 32,
                "problemTitle": "Longest Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Longest Valid Parentheses problem ask you to do?",
                "back": "Find the length of the longest valid parentheses substring using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 322,
                "problemId": 32,
                "problemTitle": "Longest Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Longest Valid Parentheses?",
                "back": "Algorithm: function longestValidParentheses(s):\n    stack = [-1]  // Initialize with -1\n    maxLength = 0\n    \n    for i = 0 to s.length - 1:\n        if s[i] == '(':\n            stack.push(i)\n        else:\n     ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 323,
                "problemId": 32,
                "problemTitle": "Longest Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Longest Valid Parentheses solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 324,
                "problemId": 32,
                "problemTitle": "Longest Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Longest Valid Parentheses solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 325,
                "problemId": 32,
                "problemTitle": "Longest Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Longest Valid Parentheses?",
                "back": "DP array. Stack combination. Track valid lengths",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 326,
                "problemId": 32,
                "problemTitle": "Longest Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Longest Valid Parentheses in Python?",
                "back": "```python\ndef longestValidParentheses(s):\n    stack = [-1]  # Initialize with -1\n    max_length = 0\n    \n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if not stack:\n                stack.append(i)\n            else:\n                max_length = max(max_length, i - stack[-1])\n    \n    return max_length\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 327,
                "problemId": 32,
                "problemTitle": "Longest Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Longest Valid Parentheses?",
                "back": "Tags: String, Dynamic Programming, Stack. This problem focuses on String algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 328,
                "problemId": 32,
                "problemTitle": "Longest Valid Parentheses",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Longest Valid Parentheses",
                "back": "Input: s = \"(()\"\nOutput: 2\nExplanation: Longest valid substring is '()'.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 331,
                "problemId": 33,
                "problemTitle": "Search in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Search in Rotated Sorted Array problem ask you to do?",
                "back": "Problem 33: Search in Rotated Sorted Array - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 332,
                "problemId": 33,
                "problemTitle": "Search in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Search in Rotated Sorted Array?",
                "back": "Algorithm: function search(nums, target):\n    left = 0\n    right = nums.length - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 333,
                "problemId": 33,
                "problemTitle": "Search in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Search in Rotated Sorted Array solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 334,
                "problemId": 33,
                "problemTitle": "Search in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Search in Rotated Sorted Array solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 335,
                "problemId": 33,
                "problemTitle": "Search in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Search in Rotated Sorted Array?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 336,
                "problemId": 33,
                "problemTitle": "Search in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Search in Rotated Sorted Array in Python?",
                "back": "```python\ndef search(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        # Check if left half is sorted\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            # Right half is sorted\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 337,
                "problemId": 33,
                "problemTitle": "Search in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Search in Rotated Sorted Array?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 338,
                "problemId": 33,
                "problemTitle": "Search in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Search in Rotated Sorted Array",
                "back": "Input: Example input for Search in Rotated Sorted Array\nOutput: Expected output for Search in Rotated Sorted Array\nExplanation: Explanation of how to solve Search in Rotated Sorted Array",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 341,
                "problemId": 34,
                "problemTitle": "Find First and Last Position of Element in Sorted Array",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Find First and Last Position of Element in Sorted Array problem ask you to do?",
                "back": "Problem 34: Find First and Last Position of Element in Sorted Array - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 342,
                "problemId": 34,
                "problemTitle": "Find First and Last Position of Element in Sorted Array",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Find First and Last Position of Element in Sorted Array?",
                "back": "Algorithm: function searchRange(nums, target):\n    left = findFirst(nums, target)\n    if left == -1:\n        return [-1, -1]\n    \n    right = findLast(nums, target)\n    return [left, right]\n\nfunction findFirst(n...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 343,
                "problemId": 34,
                "problemTitle": "Find First and Last Position of Element in Sorted Array",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Find First and Last Position of Element in Sorted Array solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 344,
                "problemId": 34,
                "problemTitle": "Find First and Last Position of Element in Sorted Array",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Find First and Last Position of Element in Sorted Array solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 345,
                "problemId": 34,
                "problemTitle": "Find First and Last Position of Element in Sorted Array",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Find First and Last Position of Element in Sorted Array?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 346,
                "problemId": 34,
                "problemTitle": "Find First and Last Position of Element in Sorted Array",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Find First and Last Position of Element in Sorted Array in Python?",
                "back": "```python\ndef searchRange(nums, target):\n    left = find_first(nums, target)\n    if left == -1:\n        return [-1, -1]\n    \n    right = find_last(nums, target)\n    return [left, right]\n\ndef find_first(nums, target):\n    left, right = 0, len(nums) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            result = mid\n            right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n\ndef find_last(nums, target):\n    left, right = 0, len(nums) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            result = mid\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 347,
                "problemId": 34,
                "problemTitle": "Find First and Last Position of Element in Sorted Array",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Find First and Last Position of Element in Sorted Array?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 348,
                "problemId": 34,
                "problemTitle": "Find First and Last Position of Element in Sorted Array",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Find First and Last Position of Element in Sorted Array",
                "back": "Input: Example input for Find First and Last Position of Element in Sorted Array\nOutput: Expected output for Find First and Last Position of Element in Sorted Array\nExplanation: Explanation of how to solve Find First and Last Position of Element in Sorted Array",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 351,
                "problemId": 35,
                "problemTitle": "Search Insert Position",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Search Insert Position problem ask you to do?",
                "back": "Problem 35: Search Insert Position - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 352,
                "problemId": 35,
                "problemTitle": "Search Insert Position",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Search Insert Position?",
                "back": "Algorithm: function searchInsert(nums, target):\n    left = 0\n    right = nums.length - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            retur...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 353,
                "problemId": 35,
                "problemTitle": "Search Insert Position",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Search Insert Position solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 354,
                "problemId": 35,
                "problemTitle": "Search Insert Position",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Search Insert Position solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 355,
                "problemId": 35,
                "problemTitle": "Search Insert Position",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Search Insert Position?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 356,
                "problemId": 35,
                "problemTitle": "Search Insert Position",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Search Insert Position in Python?",
                "back": "```python\ndef searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return left\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 357,
                "problemId": 35,
                "problemTitle": "Search Insert Position",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Search Insert Position?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 358,
                "problemId": 35,
                "problemTitle": "Search Insert Position",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Search Insert Position",
                "back": "Input: Example input for Search Insert Position\nOutput: Expected output for Search Insert Position\nExplanation: Explanation of how to solve Search Insert Position",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 361,
                "problemId": 36,
                "problemTitle": "Valid Sudoku",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Valid Sudoku problem ask you to do?",
                "back": "Problem 36: Valid Sudoku - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 362,
                "problemId": 36,
                "problemTitle": "Valid Sudoku",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Valid Sudoku?",
                "back": "Algorithm: function isValidSudoku(board):\n    rows = new Array(9).fill().map(() => new Set())\n    cols = new Array(9).fill().map(() => new Set())\n    boxes = new Array(9).fill().map(() => new Set())\n    \n    for...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 363,
                "problemId": 36,
                "problemTitle": "Valid Sudoku",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Valid Sudoku solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 364,
                "problemId": 36,
                "problemTitle": "Valid Sudoku",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Valid Sudoku solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 365,
                "problemId": 36,
                "problemTitle": "Valid Sudoku",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Valid Sudoku?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 366,
                "problemId": 36,
                "problemTitle": "Valid Sudoku",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Valid Sudoku in Python?",
                "back": "```python\ndef isValidSudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    \n    for i in range(9):\n        for j in range(9):\n            if board[i][j] != '.':\n                num = int(board[i][j])\n                box_index = (i // 3) * 3 + (j // 3)\n                \n                if num in rows[i] or num in cols[j] or num in boxes[box_index]:\n                    return False\n                \n                rows[i].add(num)\n                cols[j].add(num)\n                boxes[box_index].add(num)\n    \n    return True\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 367,
                "problemId": 36,
                "problemTitle": "Valid Sudoku",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Valid Sudoku?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 368,
                "problemId": 36,
                "problemTitle": "Valid Sudoku",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Valid Sudoku",
                "back": "Input: Example input for Valid Sudoku\nOutput: Expected output for Valid Sudoku\nExplanation: Explanation of how to solve Valid Sudoku",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 371,
                "problemId": 37,
                "problemTitle": "Sudoku Solver",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Sudoku Solver problem ask you to do?",
                "back": "Problem 37: Sudoku Solver - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 372,
                "problemId": 37,
                "problemTitle": "Sudoku Solver",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Sudoku Solver?",
                "back": "Algorithm: function solveSudoku(board):\n    solve(board)\n\nfunction solve(board):\n    for i = 0 to 8:\n        for j = 0 to 8:\n            if board[i][j] == '.':\n                for num = 1 to 9:\n                 ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 373,
                "problemId": 37,
                "problemTitle": "Sudoku Solver",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Sudoku Solver solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 374,
                "problemId": 37,
                "problemTitle": "Sudoku Solver",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Sudoku Solver solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 375,
                "problemId": 37,
                "problemTitle": "Sudoku Solver",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Sudoku Solver?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 376,
                "problemId": 37,
                "problemTitle": "Sudoku Solver",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Sudoku Solver in Python?",
                "back": "```python\ndef solveSudoku(board):\n    solve(board)\n\ndef solve(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == '.':\n                for num in range(1, 10):\n                    if is_valid(board, i, j, str(num)):\n                        board[i][j] = str(num)\n                        if solve(board):\n                            return True\n                        board[i][j] = '.'\n                return False\n    return True\n\ndef is_valid(board, row, col, num):\n    # Check row\n    for j in range(9):\n        if board[row][j] == num:\n            return False\n    \n    # Check column\n    for i in range(9):\n        if board[i][col] == num:\n            return False\n    \n    # Check 3x3 box\n    box_row = (row // 3) * 3\n    box_col = (col // 3) * 3\n    for i in range(box_row, box_row + 3):\n        for j in range(box_col, box_col + 3):\n            if board[i][j] == num:\n                return False\n    \n    return True\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 377,
                "problemId": 37,
                "problemTitle": "Sudoku Solver",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Sudoku Solver?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 378,
                "problemId": 37,
                "problemTitle": "Sudoku Solver",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Sudoku Solver",
                "back": "Input: Example input for Sudoku Solver\nOutput: Expected output for Sudoku Solver\nExplanation: Explanation of how to solve Sudoku Solver",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 381,
                "problemId": 38,
                "problemTitle": "Count and Say",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Count and Say problem ask you to do?",
                "back": "Problem 38: Count and Say - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 382,
                "problemId": 38,
                "problemTitle": "Count and Say",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Count and Say?",
                "back": "Algorithm: function countAndSay(n):\n    if n == 1:\n        return \"1\"\n    \n    prev = countAndSay(n - 1)\n    result = \"\"\n    count = 1\n    current = prev[0]\n    \n    for i = 1 to prev.length - 1:\n        if prev...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 383,
                "problemId": 38,
                "problemTitle": "Count and Say",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Count and Say solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 384,
                "problemId": 38,
                "problemTitle": "Count and Say",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Count and Say solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 385,
                "problemId": 38,
                "problemTitle": "Count and Say",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Count and Say?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 386,
                "problemId": 38,
                "problemTitle": "Count and Say",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Count and Say in Python?",
                "back": "```python\ndef countAndSay(n):\n    if n == 1:\n        return \"1\"\n    \n    prev = countAndSay(n - 1)\n    result = \"\"\n    count = 1\n    current = prev[0]\n    \n    for i in range(1, len(prev)):\n        if prev[i] == current:\n            count += 1\n        else:\n            result += str(count) + current\n            current = prev[i]\n            count = 1\n    \n    result += str(count) + current\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 387,
                "problemId": 38,
                "problemTitle": "Count and Say",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Count and Say?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 388,
                "problemId": 38,
                "problemTitle": "Count and Say",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Count and Say",
                "back": "Input: Example input for Count and Say\nOutput: Expected output for Count and Say\nExplanation: Explanation of how to solve Count and Say",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 391,
                "problemId": 39,
                "problemTitle": "Combination Sum",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Combination Sum problem ask you to do?",
                "back": "Problem 39: Combination Sum - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 392,
                "problemId": 39,
                "problemTitle": "Combination Sum",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Combination Sum?",
                "back": "Algorithm: function combinationSum(candidates, target):\n    result = []\n    backtrack(candidates, target, 0, [], result)\n    return result\n\nfunction backtrack(candidates, target, start, current, result):\n    if ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 393,
                "problemId": 39,
                "problemTitle": "Combination Sum",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Combination Sum solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 394,
                "problemId": 39,
                "problemTitle": "Combination Sum",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Combination Sum solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 395,
                "problemId": 39,
                "problemTitle": "Combination Sum",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Combination Sum?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 396,
                "problemId": 39,
                "problemTitle": "Combination Sum",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Combination Sum in Python?",
                "back": "```python\ndef combinationSum(candidates, target):\n    result = []\n    \n    def backtrack(start, current, target):\n        if target < 0:\n            return\n        if target == 0:\n            result.append(current[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            current.append(candidates[i])\n            backtrack(i, current, target - candidates[i])\n            current.pop()\n    \n    backtrack(0, [], target)\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 397,
                "problemId": 39,
                "problemTitle": "Combination Sum",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Combination Sum?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 398,
                "problemId": 39,
                "problemTitle": "Combination Sum",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Combination Sum",
                "back": "Input: Example input for Combination Sum\nOutput: Expected output for Combination Sum\nExplanation: Explanation of how to solve Combination Sum",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 401,
                "problemId": 40,
                "problemTitle": "Combination Sum II",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Combination Sum II problem ask you to do?",
                "back": "Problem 40: Combination Sum II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 402,
                "problemId": 40,
                "problemTitle": "Combination Sum II",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Combination Sum II?",
                "back": "Algorithm: function combinationSum2(candidates, target):\n    candidates.sort()\n    result = []\n    backtrack(candidates, target, 0, [], result)\n    return result\n\nfunction backtrack(candidates, target, start, cu...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 403,
                "problemId": 40,
                "problemTitle": "Combination Sum II",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Combination Sum II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 404,
                "problemId": 40,
                "problemTitle": "Combination Sum II",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Combination Sum II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 405,
                "problemId": 40,
                "problemTitle": "Combination Sum II",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Combination Sum II?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 406,
                "problemId": 40,
                "problemTitle": "Combination Sum II",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Combination Sum II in Python?",
                "back": "```python\ndef combinationSum2(candidates, target):\n    candidates.sort()\n    result = []\n    \n    def backtrack(start, current, target):\n        if target < 0:\n            return\n        if target == 0:\n            result.append(current[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            \n            current.append(candidates[i])\n            backtrack(i + 1, current, target - candidates[i])\n            current.pop()\n    \n    backtrack(0, [], target)\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 407,
                "problemId": 40,
                "problemTitle": "Combination Sum II",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Combination Sum II?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 408,
                "problemId": 40,
                "problemTitle": "Combination Sum II",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Combination Sum II",
                "back": "Input: Example input for Combination Sum II\nOutput: Expected output for Combination Sum II\nExplanation: Explanation of how to solve Combination Sum II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 411,
                "problemId": 41,
                "problemTitle": "First Missing Positive",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the First Missing Positive problem ask you to do?",
                "back": "Problem 41: First Missing Positive - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 412,
                "problemId": 41,
                "problemTitle": "First Missing Positive",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve First Missing Positive?",
                "back": "Algorithm: function firstMissingPositive(nums):\n    n = nums.length\n    \n    // Move positive numbers to their correct positions\n    for i = 0 to n - 1:\n        while nums[i] > 0 and nums[i] <= n and nums[nums[i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 413,
                "problemId": 41,
                "problemTitle": "First Missing Positive",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal First Missing Positive solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 414,
                "problemId": 41,
                "problemTitle": "First Missing Positive",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal First Missing Positive solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 415,
                "problemId": 41,
                "problemTitle": "First Missing Positive",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving First Missing Positive?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 416,
                "problemId": 41,
                "problemTitle": "First Missing Positive",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement First Missing Positive in Python?",
                "back": "```python\ndef firstMissingPositive(nums):\n    n = len(nums)\n    \n    # Move positive numbers to their correct positions\n    for i in range(n):\n        while 0 < nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    \n    # Find first missing positive\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    \n    return n + 1\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 417,
                "problemId": 41,
                "problemTitle": "First Missing Positive",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for First Missing Positive?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 418,
                "problemId": 41,
                "problemTitle": "First Missing Positive",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for First Missing Positive",
                "back": "Input: Example input for First Missing Positive\nOutput: Expected output for First Missing Positive\nExplanation: Explanation of how to solve First Missing Positive",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 421,
                "problemId": 42,
                "problemTitle": "Trapping Rain Water",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Trapping Rain Water problem ask you to do?",
                "back": "Compute how much water can be trapped after raining using dynamic programming approach.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 422,
                "problemId": 42,
                "problemTitle": "Trapping Rain Water",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Trapping Rain Water?",
                "back": "Algorithm: function trap(height):\n    if height.length < 3:\n        return 0\n    \n    left = 0\n    right = height.length - 1\n    leftMax = 0\n    rightMax = 0\n    water = 0\n    \n    while left < right:\n        if...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 423,
                "problemId": 42,
                "problemTitle": "Trapping Rain Water",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Trapping Rain Water solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 424,
                "problemId": 42,
                "problemTitle": "Trapping Rain Water",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Trapping Rain Water solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 425,
                "problemId": 42,
                "problemTitle": "Trapping Rain Water",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Trapping Rain Water?",
                "back": "Precompute max heights. Calculate trapped water. DP optimization",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 426,
                "problemId": 42,
                "problemTitle": "Trapping Rain Water",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Trapping Rain Water in Python?",
                "back": "```python\ndef trap(height):\n    if len(height) < 3:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max = right_max = 0\n    water = 0\n    \n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    \n    return water\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 427,
                "problemId": 42,
                "problemTitle": "Trapping Rain Water",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Trapping Rain Water?",
                "back": "Tags: Array, Two Pointers, Dynamic Programming, Stack. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 428,
                "problemId": 42,
                "problemTitle": "Trapping Rain Water",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Trapping Rain Water",
                "back": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: Total trapped water is 6 units.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 431,
                "problemId": 43,
                "problemTitle": "Multiply Strings",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Multiply Strings problem ask you to do?",
                "back": "Problem 43: Multiply Strings - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 432,
                "problemId": 43,
                "problemTitle": "Multiply Strings",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Multiply Strings?",
                "back": "Algorithm: function multiply(num1, num2):\n    if num1 == \"0\" or num2 == \"0\":\n        return \"0\"\n    \n    m = num1.length\n    n = num2.length\n    result = new Array(m + n).fill(0)\n    \n    for i = m - 1 to 0:\n   ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 433,
                "problemId": 43,
                "problemTitle": "Multiply Strings",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Multiply Strings solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 434,
                "problemId": 43,
                "problemTitle": "Multiply Strings",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Multiply Strings solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 435,
                "problemId": 43,
                "problemTitle": "Multiply Strings",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Multiply Strings?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 436,
                "problemId": 43,
                "problemTitle": "Multiply Strings",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Multiply Strings in Python?",
                "back": "```python\ndef multiply(num1, num2):\n    if num1 == \"0\" or num2 == \"0\":\n        return \"0\"\n    \n    m, n = len(num1), len(num2)\n    result = [0] * (m + n)\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            product = int(num1[i]) * int(num2[j])\n            total = result[i + j + 1] + product\n            \n            result[i + j + 1] = total % 10\n            result[i + j] += total // 10\n    \n    # Convert result array to string\n    start = 0\n    while start < len(result) and result[start] == 0:\n        start += 1\n    \n    if start == len(result):\n        return \"0\"\n    \n    return ''.join(map(str, result[start:]))\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 437,
                "problemId": 43,
                "problemTitle": "Multiply Strings",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Multiply Strings?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 438,
                "problemId": 43,
                "problemTitle": "Multiply Strings",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Multiply Strings",
                "back": "Input: Example input for Multiply Strings\nOutput: Expected output for Multiply Strings\nExplanation: Explanation of how to solve Multiply Strings",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 441,
                "problemId": 44,
                "problemTitle": "Wildcard Matching",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Wildcard Matching problem ask you to do?",
                "back": "Implement wildcard pattern matching with support for '?' and '*' using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 442,
                "problemId": 44,
                "problemTitle": "Wildcard Matching",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Wildcard Matching?",
                "back": "DP approach for wildcard matching\nHandle ? and * operators",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 443,
                "problemId": 44,
                "problemTitle": "Wildcard Matching",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Wildcard Matching solution?",
                "back": "O(mn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 444,
                "problemId": 44,
                "problemTitle": "Wildcard Matching",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Wildcard Matching solution?",
                "back": "O(mn) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 445,
                "problemId": 44,
                "problemTitle": "Wildcard Matching",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Wildcard Matching?",
                "back": "Handle ? and * operators. DP approach. Pattern matching",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 446,
                "problemId": 44,
                "problemTitle": "Wildcard Matching",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Wildcard Matching in Python?",
                "back": "```python\nDP table for wildcard matching\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 447,
                "problemId": 44,
                "problemTitle": "Wildcard Matching",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Wildcard Matching?",
                "back": "Tags: String, Dynamic Programming, Greedy, Recursion. This problem focuses on String algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 448,
                "problemId": 44,
                "problemTitle": "Wildcard Matching",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Wildcard Matching",
                "back": "Input: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 451,
                "problemId": 45,
                "problemTitle": "Jump Game II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Jump Game II problem ask you to do?",
                "back": "Find minimum number of jumps to reach the last index using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 452,
                "problemId": 45,
                "problemTitle": "Jump Game II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Jump Game II?",
                "back": "Greedy approach with jumps\nTrack reachable range",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 453,
                "problemId": 45,
                "problemTitle": "Jump Game II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Jump Game II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 454,
                "problemId": 45,
                "problemTitle": "Jump Game II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Jump Game II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 455,
                "problemId": 45,
                "problemTitle": "Jump Game II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Jump Game II?",
                "back": "Greedy approach. Track reachable range. Jump optimization",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 456,
                "problemId": 45,
                "problemTitle": "Jump Game II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Jump Game II in Python?",
                "back": "```python\nGreedy jump selection\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 457,
                "problemId": 45,
                "problemTitle": "Jump Game II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Jump Game II?",
                "back": "Tags: Array, Dynamic Programming, Greedy. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 458,
                "problemId": 45,
                "problemTitle": "Jump Game II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Jump Game II",
                "back": "Input: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: Jump from index 0 to 1, then to last.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 461,
                "problemId": 46,
                "problemTitle": "Permutations",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Permutations problem ask you to do?",
                "back": "Problem 46: Permutations - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 462,
                "problemId": 46,
                "problemTitle": "Permutations",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Permutations?",
                "back": "Algorithm: function permute(nums):\n    result = []\n    backtrack(nums, [], result)\n    return result\n\nfunction backtrack(nums, current, result):\n    if current.length == nums.length:\n        result.add([...curre...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 463,
                "problemId": 46,
                "problemTitle": "Permutations",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Permutations solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 464,
                "problemId": 46,
                "problemTitle": "Permutations",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Permutations solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 465,
                "problemId": 46,
                "problemTitle": "Permutations",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Permutations?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 466,
                "problemId": 46,
                "problemTitle": "Permutations",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Permutations in Python?",
                "back": "```python\ndef permute(nums):\n    result = []\n    \n    def backtrack(current):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n        \n        for num in nums:\n            if num in current:\n                continue\n            current.append(num)\n            backtrack(current)\n            current.pop()\n    \n    backtrack([])\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 467,
                "problemId": 46,
                "problemTitle": "Permutations",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Permutations?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 468,
                "problemId": 46,
                "problemTitle": "Permutations",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Permutations",
                "back": "Input: Example input for Permutations\nOutput: Expected output for Permutations\nExplanation: Explanation of how to solve Permutations",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 471,
                "problemId": 47,
                "problemTitle": "Permutations II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Permutations II problem ask you to do?",
                "back": "Problem 47: Permutations II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 472,
                "problemId": 47,
                "problemTitle": "Permutations II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Permutations II?",
                "back": "Algorithm: function permuteUnique(nums):\n    nums.sort()\n    result = []\n    used = new Array(nums.length).fill(false)\n    backtrack(nums, [], used, result)\n    return result\n\nfunction backtrack(nums, current, u...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 473,
                "problemId": 47,
                "problemTitle": "Permutations II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Permutations II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 474,
                "problemId": 47,
                "problemTitle": "Permutations II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Permutations II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 475,
                "problemId": 47,
                "problemTitle": "Permutations II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Permutations II?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 476,
                "problemId": 47,
                "problemTitle": "Permutations II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Permutations II in Python?",
                "back": "```python\ndef permuteUnique(nums):\n    nums.sort()\n    result = []\n    used = [False] * len(nums)\n    \n    def backtrack(current):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n        \n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):\n                continue\n            \n            used[i] = True\n            current.append(nums[i])\n            backtrack(current)\n            used[i] = False\n            current.pop()\n    \n    backtrack([])\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 477,
                "problemId": 47,
                "problemTitle": "Permutations II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Permutations II?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 478,
                "problemId": 47,
                "problemTitle": "Permutations II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Permutations II",
                "back": "Input: Example input for Permutations II\nOutput: Expected output for Permutations II\nExplanation: Explanation of how to solve Permutations II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 481,
                "problemId": 48,
                "problemTitle": "Rotate Image",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Rotate Image problem ask you to do?",
                "back": "Problem 48: Rotate Image - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 482,
                "problemId": 48,
                "problemTitle": "Rotate Image",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Rotate Image?",
                "back": "Algorithm: function rotate(matrix):\n    n = matrix.length\n    \n    // Transpose the matrix\n    for i = 0 to n - 1:\n        for j = i to n - 1:\n            swap(matrix[i][j], matrix[j][i])\n    \n    // Reverse eac...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 483,
                "problemId": 48,
                "problemTitle": "Rotate Image",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Rotate Image solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 484,
                "problemId": 48,
                "problemTitle": "Rotate Image",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Rotate Image solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 485,
                "problemId": 48,
                "problemTitle": "Rotate Image",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Rotate Image?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 486,
                "problemId": 48,
                "problemTitle": "Rotate Image",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Rotate Image in Python?",
                "back": "```python\ndef rotate(matrix):\n    n = len(matrix)\n    \n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    # Reverse each row\n    for i in range(n):\n        matrix[i].reverse()\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 487,
                "problemId": 48,
                "problemTitle": "Rotate Image",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Rotate Image?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 488,
                "problemId": 48,
                "problemTitle": "Rotate Image",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Rotate Image",
                "back": "Input: Example input for Rotate Image\nOutput: Expected output for Rotate Image\nExplanation: Explanation of how to solve Rotate Image",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 491,
                "problemId": 49,
                "problemTitle": "Group Anagrams",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Group Anagrams problem ask you to do?",
                "back": "Problem 49: Group Anagrams - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 492,
                "problemId": 49,
                "problemTitle": "Group Anagrams",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Group Anagrams?",
                "back": "Algorithm: function groupAnagrams(strs):\n    groups = {}\n    \n    for str in strs:\n        sortedStr = sort(str)\n        if sortedStr not in groups:\n            groups[sortedStr] = []\n        groups[sortedStr].a...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 493,
                "problemId": 49,
                "problemTitle": "Group Anagrams",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Group Anagrams solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 494,
                "problemId": 49,
                "problemTitle": "Group Anagrams",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Group Anagrams solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 495,
                "problemId": 49,
                "problemTitle": "Group Anagrams",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Group Anagrams?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 496,
                "problemId": 49,
                "problemTitle": "Group Anagrams",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Group Anagrams in Python?",
                "back": "```python\ndef groupAnagrams(strs):\n    groups = {}\n    \n    for s in strs:\n        sorted_s = ''.join(sorted(s))\n        if sorted_s not in groups:\n            groups[sorted_s] = []\n        groups[sorted_s].append(s)\n    \n    return list(groups.values())\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 497,
                "problemId": 49,
                "problemTitle": "Group Anagrams",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Group Anagrams?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 498,
                "problemId": 49,
                "problemTitle": "Group Anagrams",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Group Anagrams",
                "back": "Input: Example input for Group Anagrams\nOutput: Expected output for Group Anagrams\nExplanation: Explanation of how to solve Group Anagrams",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 501,
                "problemId": 50,
                "problemTitle": "Pow(x, n)",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Pow(x, n) problem ask you to do?",
                "back": "Problem 50: Pow(x, n) - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 502,
                "problemId": 50,
                "problemTitle": "Pow(x, n)",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Pow(x, n)?",
                "back": "Algorithm: function myPow(x, n):\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    \n    result = 1\n    current = x\n    \n    while n > 0:\n        if n % 2 == 1:\n            result...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 503,
                "problemId": 50,
                "problemTitle": "Pow(x, n)",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Pow(x, n) solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 504,
                "problemId": 50,
                "problemTitle": "Pow(x, n)",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Pow(x, n) solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 505,
                "problemId": 50,
                "problemTitle": "Pow(x, n)",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Pow(x, n)?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 506,
                "problemId": 50,
                "problemTitle": "Pow(x, n)",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Pow(x, n) in Python?",
                "back": "```python\ndef myPow(x, n):\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    \n    result = 1\n    current = x\n    \n    while n > 0:\n        if n % 2 == 1:\n            result *= current\n        current *= current\n        n //= 2\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 507,
                "problemId": 50,
                "problemTitle": "Pow(x, n)",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Pow(x, n)?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 508,
                "problemId": 50,
                "problemTitle": "Pow(x, n)",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Pow(x, n)",
                "back": "Input: Example input for Pow(x, n)\nOutput: Expected output for Pow(x, n)\nExplanation: Explanation of how to solve Pow(x, n)",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 511,
                "problemId": 51,
                "problemTitle": "N-Queens",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the N-Queens problem ask you to do?",
                "back": "Problem 51: N-Queens - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 512,
                "problemId": 51,
                "problemTitle": "N-Queens",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve N-Queens?",
                "back": "Algorithm: function solveNQueens(n):\n    result = []\n    board = new Array(n).fill().map(() => new Array(n).fill('.'))\n    backtrack(board, 0, result)\n    return result\n\nfunction backtrack(board, row, result):\n ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 513,
                "problemId": 51,
                "problemTitle": "N-Queens",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal N-Queens solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 514,
                "problemId": 51,
                "problemTitle": "N-Queens",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal N-Queens solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 515,
                "problemId": 51,
                "problemTitle": "N-Queens",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving N-Queens?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 516,
                "problemId": 51,
                "problemTitle": "N-Queens",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement N-Queens in Python?",
                "back": "```python\ndef solveNQueens(n):\n    result = []\n    board = [['.'] * n for _ in range(n)]\n    \n    def backtrack(row):\n        if row == n:\n            result.append(format_board(board))\n            return\n        \n        for col in range(n):\n            if is_valid(board, row, col):\n                board[row][col] = 'Q'\n                backtrack(row + 1)\n                board[row][col] = '.'\n    \n    def is_valid(board, row, col):\n        # Check column\n        for i in range(row):\n            if board[i][col] == 'Q':\n                return False\n        \n        # Check diagonal\n        for i in range(1, row + 1):\n            if row - i >= 0 and col - i >= 0 and board[row-i][col-i] == 'Q':\n                return False\n            if row - i >= 0 and col + i < n and board[row-i][col+i] == 'Q':\n                return False\n        \n        return True\n    \n    def format_board(board):\n        return [''.join(row) for row in board]\n    \n    backtrack(0)\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 517,
                "problemId": 51,
                "problemTitle": "N-Queens",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for N-Queens?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 518,
                "problemId": 51,
                "problemTitle": "N-Queens",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for N-Queens",
                "back": "Input: Example input for N-Queens\nOutput: Expected output for N-Queens\nExplanation: Explanation of how to solve N-Queens",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 521,
                "problemId": 52,
                "problemTitle": "N-Queens II",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the N-Queens II problem ask you to do?",
                "back": "Problem 52: N-Queens II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 522,
                "problemId": 52,
                "problemTitle": "N-Queens II",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve N-Queens II?",
                "back": "Algorithm: function solve52():\n    // Algorithm approach for N-Queens II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initiali...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 523,
                "problemId": 52,
                "problemTitle": "N-Queens II",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal N-Queens II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 524,
                "problemId": 52,
                "problemTitle": "N-Queens II",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal N-Queens II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 525,
                "problemId": 52,
                "problemTitle": "N-Queens II",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving N-Queens II?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 526,
                "problemId": 52,
                "problemTitle": "N-Queens II",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement N-Queens II in Python?",
                "back": "```python\ndef solve_52():\n    # Algorithm approach for N-Queens II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 527,
                "problemId": 52,
                "problemTitle": "N-Queens II",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for N-Queens II?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 528,
                "problemId": 52,
                "problemTitle": "N-Queens II",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for N-Queens II",
                "back": "Input: Input for N-Queens II\nOutput: Expected output for N-Queens II\nExplanation: Explanation of how to solve N-Queens II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 531,
                "problemId": 53,
                "problemTitle": "Maximum Subarray",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Maximum Subarray problem ask you to do?",
                "back": "Problem 53: Maximum Subarray - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 532,
                "problemId": 53,
                "problemTitle": "Maximum Subarray",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Maximum Subarray?",
                "back": "Algorithm: function maxSubArray(nums):\n    maxSoFar = nums[0]\n    maxEndingHere = nums[0]\n    \n    for i = 1 to nums.length - 1:\n        maxEndingHere = max(nums[i], maxEndingHere + nums[i])\n        maxSoFar = m...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 533,
                "problemId": 53,
                "problemTitle": "Maximum Subarray",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Maximum Subarray solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 534,
                "problemId": 53,
                "problemTitle": "Maximum Subarray",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Maximum Subarray solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 535,
                "problemId": 53,
                "problemTitle": "Maximum Subarray",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Maximum Subarray?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 536,
                "problemId": 53,
                "problemTitle": "Maximum Subarray",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Maximum Subarray in Python?",
                "back": "```python\ndef maxSubArray(nums):\n    max_so_far = max_ending_here = nums[0]\n    \n    for i in range(1, len(nums)):\n        max_ending_here = max(nums[i], max_ending_here + nums[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 537,
                "problemId": 53,
                "problemTitle": "Maximum Subarray",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Maximum Subarray?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 538,
                "problemId": 53,
                "problemTitle": "Maximum Subarray",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Maximum Subarray",
                "back": "Input: Example input for Maximum Subarray\nOutput: Expected output for Maximum Subarray\nExplanation: Explanation of how to solve Maximum Subarray",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 541,
                "problemId": 54,
                "problemTitle": "Spiral Matrix",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Spiral Matrix problem ask you to do?",
                "back": "Problem 54: Spiral Matrix - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 542,
                "problemId": 54,
                "problemTitle": "Spiral Matrix",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Spiral Matrix?",
                "back": "Algorithm: function spiralOrder(matrix):\n    if matrix.length == 0:\n        return []\n    \n    result = []\n    top = 0, bottom = matrix.length - 1\n    left = 0, right = matrix[0].length - 1\n    \n    while top <=...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 543,
                "problemId": 54,
                "problemTitle": "Spiral Matrix",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Spiral Matrix solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 544,
                "problemId": 54,
                "problemTitle": "Spiral Matrix",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Spiral Matrix solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 545,
                "problemId": 54,
                "problemTitle": "Spiral Matrix",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Spiral Matrix?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 546,
                "problemId": 54,
                "problemTitle": "Spiral Matrix",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Spiral Matrix in Python?",
                "back": "```python\ndef spiralOrder(matrix):\n    if not matrix:\n        return []\n    \n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Traverse right\n        for j in range(left, right + 1):\n            result.append(matrix[top][j])\n        top += 1\n        \n        # Traverse down\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            # Traverse left\n            for j in range(right, left - 1, -1):\n                result.append(matrix[bottom][j])\n            bottom -= 1\n        \n        if left <= right:\n            # Traverse up\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 547,
                "problemId": 54,
                "problemTitle": "Spiral Matrix",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Spiral Matrix?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 548,
                "problemId": 54,
                "problemTitle": "Spiral Matrix",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Spiral Matrix",
                "back": "Input: Example input for Spiral Matrix\nOutput: Expected output for Spiral Matrix\nExplanation: Explanation of how to solve Spiral Matrix",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 551,
                "problemId": 55,
                "problemTitle": "Jump Game",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Jump Game problem ask you to do?",
                "back": "Determine if you can reach the last index using dynamic programming approach.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 552,
                "problemId": 55,
                "problemTitle": "Jump Game",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Jump Game?",
                "back": "Track maximum reachable position\nGreedy approach",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 553,
                "problemId": 55,
                "problemTitle": "Jump Game",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Jump Game solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 554,
                "problemId": 55,
                "problemTitle": "Jump Game",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Jump Game solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 555,
                "problemId": 55,
                "problemTitle": "Jump Game",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Jump Game?",
                "back": "Track reachable position. Greedy approach. DP optimization",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 556,
                "problemId": 55,
                "problemTitle": "Jump Game",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Jump Game in Python?",
                "back": "```python\nGreedy approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 557,
                "problemId": 55,
                "problemTitle": "Jump Game",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Jump Game?",
                "back": "Tags: Array, Dynamic Programming, Greedy. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 558,
                "problemId": 55,
                "problemTitle": "Jump Game",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Jump Game",
                "back": "Input: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Can jump to the last index.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 561,
                "problemId": 56,
                "problemTitle": "Merge Intervals",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Merge Intervals problem ask you to do?",
                "back": "Problem 56: Merge Intervals - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 562,
                "problemId": 56,
                "problemTitle": "Merge Intervals",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Merge Intervals?",
                "back": "Algorithm: function merge(intervals):\n    if intervals.length == 0:\n        return []\n    \n    intervals.sort((a, b) => a[0] - b[0])\n    result = [intervals[0]]\n    \n    for i = 1 to intervals.length - 1:\n      ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 563,
                "problemId": 56,
                "problemTitle": "Merge Intervals",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Merge Intervals solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 564,
                "problemId": 56,
                "problemTitle": "Merge Intervals",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Merge Intervals solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 565,
                "problemId": 56,
                "problemTitle": "Merge Intervals",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Merge Intervals?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 566,
                "problemId": 56,
                "problemTitle": "Merge Intervals",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Merge Intervals in Python?",
                "back": "```python\ndef merge(intervals):\n    if not intervals:\n        return []\n    \n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n    \n    for i in range(1, len(intervals)):\n        current = intervals[i]\n        last = result[-1]\n        \n        if current[0] <= last[1]:\n            last[1] = max(last[1], current[1])\n        else:\n            result.append(current)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 567,
                "problemId": 56,
                "problemTitle": "Merge Intervals",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Merge Intervals?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 568,
                "problemId": 56,
                "problemTitle": "Merge Intervals",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Merge Intervals",
                "back": "Input: Example input for Merge Intervals\nOutput: Expected output for Merge Intervals\nExplanation: Explanation of how to solve Merge Intervals",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 571,
                "problemId": 57,
                "problemTitle": "Insert Interval",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Insert Interval problem ask you to do?",
                "back": "Problem 57: Insert Interval - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 572,
                "problemId": 57,
                "problemTitle": "Insert Interval",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Insert Interval?",
                "back": "Algorithm: function insert(intervals, newInterval):\n    result = []\n    i = 0\n    \n    // Add all intervals that come before newInterval\n    while i < intervals.length and intervals[i][1] < newInterval[0]:\n     ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 573,
                "problemId": 57,
                "problemTitle": "Insert Interval",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Insert Interval solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 574,
                "problemId": 57,
                "problemTitle": "Insert Interval",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Insert Interval solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 575,
                "problemId": 57,
                "problemTitle": "Insert Interval",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Insert Interval?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 576,
                "problemId": 57,
                "problemTitle": "Insert Interval",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Insert Interval in Python?",
                "back": "```python\ndef insert(intervals, newInterval):\n    result = []\n    i = 0\n    \n    # Add all intervals that come before newInterval\n    while i < len(intervals) and intervals[i][1] < newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n    \n    # Merge overlapping intervals\n    while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    \n    result.append(newInterval)\n    \n    # Add remaining intervals\n    while i < len(intervals):\n        result.append(intervals[i])\n        i += 1\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 577,
                "problemId": 57,
                "problemTitle": "Insert Interval",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Insert Interval?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 578,
                "problemId": 57,
                "problemTitle": "Insert Interval",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Insert Interval",
                "back": "Input: Example input for Insert Interval\nOutput: Expected output for Insert Interval\nExplanation: Explanation of how to solve Insert Interval",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 581,
                "problemId": 58,
                "problemTitle": "Length of Last Word",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Length of Last Word problem ask you to do?",
                "back": "Problem 58: Length of Last Word - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 582,
                "problemId": 58,
                "problemTitle": "Length of Last Word",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Length of Last Word?",
                "back": "Algorithm: function lengthOfLastWord(s):\n    // Trim trailing spaces\n    end = s.length - 1\n    while end >= 0 and s[end] == ' ':\n        end--\n    \n    // Find start of last word\n    start = end\n    while start...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 583,
                "problemId": 58,
                "problemTitle": "Length of Last Word",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Length of Last Word solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 584,
                "problemId": 58,
                "problemTitle": "Length of Last Word",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Length of Last Word solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 585,
                "problemId": 58,
                "problemTitle": "Length of Last Word",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Length of Last Word?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 586,
                "problemId": 58,
                "problemTitle": "Length of Last Word",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Length of Last Word in Python?",
                "back": "```python\ndef lengthOfLastWord(s):\n    # Trim trailing spaces\n    end = len(s) - 1\n    while end >= 0 and s[end] == ' ':\n        end -= 1\n    \n    # Find start of last word\n    start = end\n    while start >= 0 and s[start] != ' ':\n        start -= 1\n    \n    return end - start\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 587,
                "problemId": 58,
                "problemTitle": "Length of Last Word",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Length of Last Word?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 588,
                "problemId": 58,
                "problemTitle": "Length of Last Word",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Length of Last Word",
                "back": "Input: Example input for Length of Last Word\nOutput: Expected output for Length of Last Word\nExplanation: Explanation of how to solve Length of Last Word",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 591,
                "problemId": 59,
                "problemTitle": "Spiral Matrix II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Spiral Matrix II problem ask you to do?",
                "back": "Problem 59: Spiral Matrix II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 592,
                "problemId": 59,
                "problemTitle": "Spiral Matrix II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Spiral Matrix II?",
                "back": "Algorithm: function generateMatrix(n):\n    matrix = new Array(n).fill().map(() => new Array(n).fill(0))\n    top = 0, bottom = n - 1\n    left = 0, right = n - 1\n    num = 1\n    \n    while top <= bottom and left <...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 593,
                "problemId": 59,
                "problemTitle": "Spiral Matrix II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Spiral Matrix II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 594,
                "problemId": 59,
                "problemTitle": "Spiral Matrix II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Spiral Matrix II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 595,
                "problemId": 59,
                "problemTitle": "Spiral Matrix II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Spiral Matrix II?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 596,
                "problemId": 59,
                "problemTitle": "Spiral Matrix II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Spiral Matrix II in Python?",
                "back": "```python\ndef generateMatrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    top, bottom = 0, n - 1\n    left, right = 0, n - 1\n    num = 1\n    \n    while top <= bottom and left <= right:\n        # Fill top row\n        for j in range(left, right + 1):\n            matrix[top][j] = num\n            num += 1\n        top += 1\n        \n        # Fill right column\n        for i in range(top, bottom + 1):\n            matrix[i][right] = num\n            num += 1\n        right -= 1\n        \n        if top <= bottom:\n            # Fill bottom row\n            for j in range(right, left - 1, -1):\n                matrix[bottom][j] = num\n                num += 1\n            bottom -= 1\n        \n        if left <= right:\n            # Fill left column\n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n    \n    return matrix\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 597,
                "problemId": 59,
                "problemTitle": "Spiral Matrix II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Spiral Matrix II?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 598,
                "problemId": 59,
                "problemTitle": "Spiral Matrix II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Spiral Matrix II",
                "back": "Input: Example input for Spiral Matrix II\nOutput: Expected output for Spiral Matrix II\nExplanation: Explanation of how to solve Spiral Matrix II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 601,
                "problemId": 60,
                "problemTitle": "Permutation Sequence",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Permutation Sequence problem ask you to do?",
                "back": "Problem 60: Permutation Sequence - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 602,
                "problemId": 60,
                "problemTitle": "Permutation Sequence",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Permutation Sequence?",
                "back": "Algorithm: function getPermutation(n, k):\n    numbers = [1, 2, ..., n]\n    factorial = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n    result = \"\"\n    k--\n    \n    for i = n to 1:\n        index = Math.floor(...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 603,
                "problemId": 60,
                "problemTitle": "Permutation Sequence",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Permutation Sequence solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 604,
                "problemId": 60,
                "problemTitle": "Permutation Sequence",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Permutation Sequence solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 605,
                "problemId": 60,
                "problemTitle": "Permutation Sequence",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Permutation Sequence?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 606,
                "problemId": 60,
                "problemTitle": "Permutation Sequence",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Permutation Sequence in Python?",
                "back": "```python\ndef getPermutation(n, k):\n    numbers = list(range(1, n + 1))\n    factorial = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n    result = \"\"\n    k -= 1\n    \n    for i in range(n, 0, -1):\n        index = k // factorial[i-1]\n        result += str(numbers[index])\n        numbers.pop(index)\n        k %= factorial[i-1]\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 607,
                "problemId": 60,
                "problemTitle": "Permutation Sequence",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Permutation Sequence?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 608,
                "problemId": 60,
                "problemTitle": "Permutation Sequence",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Permutation Sequence",
                "back": "Input: Example input for Permutation Sequence\nOutput: Expected output for Permutation Sequence\nExplanation: Explanation of how to solve Permutation Sequence",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 611,
                "problemId": 61,
                "problemTitle": "Rotate List",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Rotate List problem ask you to do?",
                "back": "Problem 61: Rotate List - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 612,
                "problemId": 61,
                "problemTitle": "Rotate List",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Rotate List?",
                "back": "Algorithm: function rotateRight(head, k):\n    if head == null or head.next == null or k == 0:\n        return head\n    \n    // Count nodes\n    count = 1\n    current = head\n    while current.next != null:\n        ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 613,
                "problemId": 61,
                "problemTitle": "Rotate List",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Rotate List solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 614,
                "problemId": 61,
                "problemTitle": "Rotate List",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Rotate List solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 615,
                "problemId": 61,
                "problemTitle": "Rotate List",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Rotate List?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 616,
                "problemId": 61,
                "problemTitle": "Rotate List",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Rotate List in Python?",
                "back": "```python\ndef rotateRight(head, k):\n    if not head or not head.next or k == 0:\n        return head\n    \n    # Count nodes\n    count = 1\n    current = head\n    while current.next:\n        current = current.next\n        count += 1\n    \n    # Calculate actual rotation\n    k = k % count\n    if k == 0:\n        return head\n    \n    # Find new head position\n    new_head_pos = count - k\n    current = head\n    for i in range(1, new_head_pos):\n        current = current.next\n    \n    new_head = current.next\n    current.next = None\n    \n    # Connect end to original head\n    current = new_head\n    while current.next:\n        current = current.next\n    current.next = head\n    \n    return new_head\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 617,
                "problemId": 61,
                "problemTitle": "Rotate List",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Rotate List?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 618,
                "problemId": 61,
                "problemTitle": "Rotate List",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Rotate List",
                "back": "Input: Example input for Rotate List\nOutput: Expected output for Rotate List\nExplanation: Explanation of how to solve Rotate List",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 621,
                "problemId": 62,
                "problemTitle": "Unique Paths",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Unique Paths problem ask you to do?",
                "back": "Find number of unique paths from top-left to bottom-right using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 622,
                "problemId": 62,
                "problemTitle": "Unique Paths",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Unique Paths?",
                "back": "DP grid with path counting\nFill from top-left to bottom-right",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 623,
                "problemId": 62,
                "problemTitle": "Unique Paths",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Unique Paths solution?",
                "back": "O(mn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 624,
                "problemId": 62,
                "problemTitle": "Unique Paths",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Unique Paths solution?",
                "back": "O(mn) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 625,
                "problemId": 62,
                "problemTitle": "Unique Paths",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Unique Paths?",
                "back": "DP grid. Path counting. Fill systematically",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 626,
                "problemId": 62,
                "problemTitle": "Unique Paths",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Unique Paths in Python?",
                "back": "```python\nDP grid filling approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 627,
                "problemId": 62,
                "problemTitle": "Unique Paths",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Unique Paths?",
                "back": "Tags: Math, Dynamic Programming, Combinatorics. This problem focuses on Math algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 628,
                "problemId": 62,
                "problemTitle": "Unique Paths",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Unique Paths",
                "back": "Input: m = 3, n = 7\nOutput: 28\nExplanation: 28 unique paths exist.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 631,
                "problemId": 63,
                "problemTitle": "Unique Paths II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Unique Paths II problem ask you to do?",
                "back": "Find unique paths with obstacles using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 632,
                "problemId": 63,
                "problemTitle": "Unique Paths II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Unique Paths II?",
                "back": "DP with obstacle checking\nSkip blocked cells",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 633,
                "problemId": 63,
                "problemTitle": "Unique Paths II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Unique Paths II solution?",
                "back": "O(mn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 634,
                "problemId": 63,
                "problemTitle": "Unique Paths II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Unique Paths II solution?",
                "back": "O(mn) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 635,
                "problemId": 63,
                "problemTitle": "Unique Paths II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Unique Paths II?",
                "back": "Check obstacles. DP approach. Handle blocked cells",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 636,
                "problemId": 63,
                "problemTitle": "Unique Paths II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Unique Paths II in Python?",
                "back": "```python\nDP with obstacle handling\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 637,
                "problemId": 63,
                "problemTitle": "Unique Paths II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Unique Paths II?",
                "back": "Tags: Array, Dynamic Programming, Matrix. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 638,
                "problemId": 63,
                "problemTitle": "Unique Paths II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Unique Paths II",
                "back": "Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: Two paths avoiding obstacle.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 641,
                "problemId": 64,
                "problemTitle": "Minimum Path Sum",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Minimum Path Sum problem ask you to do?",
                "back": "Find minimum path sum from top-left to bottom-right using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 642,
                "problemId": 64,
                "problemTitle": "Minimum Path Sum",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Minimum Path Sum?",
                "back": "DP grid with path cost\nChoose minimum path at each step",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 643,
                "problemId": 64,
                "problemTitle": "Minimum Path Sum",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Minimum Path Sum solution?",
                "back": "O(mn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 644,
                "problemId": 64,
                "problemTitle": "Minimum Path Sum",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Minimum Path Sum solution?",
                "back": "O(mn) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 645,
                "problemId": 64,
                "problemTitle": "Minimum Path Sum",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Minimum Path Sum?",
                "back": "DP approach. Choose minimum path. Cost optimization",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 646,
                "problemId": 64,
                "problemTitle": "Minimum Path Sum",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Minimum Path Sum in Python?",
                "back": "```python\nDP grid filling with cost\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 647,
                "problemId": 64,
                "problemTitle": "Minimum Path Sum",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Minimum Path Sum?",
                "back": "Tags: Array, Dynamic Programming, Matrix. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 648,
                "problemId": 64,
                "problemTitle": "Minimum Path Sum",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Minimum Path Sum",
                "back": "Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Path 1\u21923\u21921\u21921\u21921 minimizes sum to 7.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 651,
                "problemId": 65,
                "problemTitle": "Valid Number",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Valid Number problem ask you to do?",
                "back": "Problem 65: Valid Number - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 652,
                "problemId": 65,
                "problemTitle": "Valid Number",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Valid Number?",
                "back": "Algorithm: function isNumber(s):\n    seenDigit = false\n    seenExponent = false\n    seenDot = false\n    \n    for i = 0 to s.length - 1:\n        char = s[i]\n        \n        if char.isDigit():\n            seenDig...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 653,
                "problemId": 65,
                "problemTitle": "Valid Number",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Valid Number solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 654,
                "problemId": 65,
                "problemTitle": "Valid Number",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Valid Number solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 655,
                "problemId": 65,
                "problemTitle": "Valid Number",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Valid Number?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 656,
                "problemId": 65,
                "problemTitle": "Valid Number",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Valid Number in Python?",
                "back": "```python\ndef isNumber(s):\n    seen_digit = False\n    seen_exponent = False\n    seen_dot = False\n    \n    for i, char in enumerate(s):\n        if char.isdigit():\n            seen_digit = True\n        elif char in ['+', '-']:\n            if i > 0 and s[i-1] not in ['e', 'E']:\n                return False\n        elif char in ['e', 'E']:\n            if seen_exponent or not seen_digit:\n                return False\n            seen_exponent = True\n            seen_digit = False\n        elif char == '.':\n            if seen_dot or seen_exponent:\n                return False\n            seen_dot = True\n        else:\n            return False\n    \n    return seen_digit\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 657,
                "problemId": 65,
                "problemTitle": "Valid Number",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Valid Number?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 658,
                "problemId": 65,
                "problemTitle": "Valid Number",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Valid Number",
                "back": "Input: Example input for Valid Number\nOutput: Expected output for Valid Number\nExplanation: Explanation of how to solve Valid Number",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 661,
                "problemId": 66,
                "problemTitle": "Plus One",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Plus One problem ask you to do?",
                "back": "Problem 66: Plus One - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 662,
                "problemId": 66,
                "problemTitle": "Plus One",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Plus One?",
                "back": "Algorithm: function plusOne(digits):\n    n = digits.length\n    \n    for i = n - 1 to 0:\n        if digits[i] < 9:\n            digits[i]++\n            return digits\n        digits[i] = 0\n    \n    // If we reach h...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 663,
                "problemId": 66,
                "problemTitle": "Plus One",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Plus One solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 664,
                "problemId": 66,
                "problemTitle": "Plus One",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Plus One solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 665,
                "problemId": 66,
                "problemTitle": "Plus One",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Plus One?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 666,
                "problemId": 66,
                "problemTitle": "Plus One",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Plus One in Python?",
                "back": "```python\ndef plusOne(digits):\n    n = len(digits)\n    \n    for i in range(n - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    \n    # If we reach here, all digits were 9\n    result = [0] * (n + 1)\n    result[0] = 1\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 667,
                "problemId": 66,
                "problemTitle": "Plus One",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Plus One?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 668,
                "problemId": 66,
                "problemTitle": "Plus One",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Plus One",
                "back": "Input: Example input for Plus One\nOutput: Expected output for Plus One\nExplanation: Explanation of how to solve Plus One",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 671,
                "problemId": 67,
                "problemTitle": "Add Binary",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Add Binary problem ask you to do?",
                "back": "Problem 67: Add Binary - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 672,
                "problemId": 67,
                "problemTitle": "Add Binary",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Add Binary?",
                "back": "Algorithm: function addBinary(a, b):\n    result = \"\"\n    carry = 0\n    i = a.length - 1\n    j = b.length - 1\n    \n    while i >= 0 or j >= 0 or carry > 0:\n        sum = carry\n        if i >= 0:\n            sum +...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 673,
                "problemId": 67,
                "problemTitle": "Add Binary",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Add Binary solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 674,
                "problemId": 67,
                "problemTitle": "Add Binary",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Add Binary solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 675,
                "problemId": 67,
                "problemTitle": "Add Binary",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Add Binary?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 676,
                "problemId": 67,
                "problemTitle": "Add Binary",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Add Binary in Python?",
                "back": "```python\ndef addBinary(a, b):\n    result = \"\"\n    carry = 0\n    i, j = len(a) - 1, len(b) - 1\n    \n    while i >= 0 or j >= 0 or carry:\n        total = carry\n        if i >= 0:\n            total += int(a[i])\n            i -= 1\n        if j >= 0:\n            total += int(b[j])\n            j -= 1\n        \n        result = str(total % 2) + result\n        carry = total // 2\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 677,
                "problemId": 67,
                "problemTitle": "Add Binary",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Add Binary?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 678,
                "problemId": 67,
                "problemTitle": "Add Binary",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Add Binary",
                "back": "Input: Example input for Add Binary\nOutput: Expected output for Add Binary\nExplanation: Explanation of how to solve Add Binary",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 681,
                "problemId": 68,
                "problemTitle": "Text Justification",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Text Justification problem ask you to do?",
                "back": "Problem 68: Text Justification - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 682,
                "problemId": 68,
                "problemTitle": "Text Justification",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Text Justification?",
                "back": "Algorithm: function fullJustify(words, maxWidth):\n    result = []\n    current = []\n    currentLength = 0\n    \n    for word in words:\n        if currentLength + word.length + len(current) <= maxWidth:\n           ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 683,
                "problemId": 68,
                "problemTitle": "Text Justification",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Text Justification solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 684,
                "problemId": 68,
                "problemTitle": "Text Justification",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Text Justification solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 685,
                "problemId": 68,
                "problemTitle": "Text Justification",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Text Justification?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 686,
                "problemId": 68,
                "problemTitle": "Text Justification",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Text Justification in Python?",
                "back": "```python\ndef fullJustify(words, maxWidth):\n    result = []\n    current = []\n    current_length = 0\n    \n    for word in words:\n        if current_length + len(word) + len(current) <= maxWidth:\n            current.append(word)\n            current_length += len(word)\n        else:\n            result.append(justify_line(current, maxWidth, False))\n            current = [word]\n            current_length = len(word)\n    \n    # Handle last line\n    if current:\n        result.append(justify_line(current, maxWidth, True))\n    \n    return result\n\ndef justify_line(words, max_width, is_last):\n    if len(words) == 1 or is_last:\n        return ' '.join(words).ljust(max_width)\n    \n    total_spaces = max_width - sum(len(word) for word in words)\n    gaps = len(words) - 1\n    spaces_per_gap = total_spaces // gaps\n    extra_spaces = total_spaces % gaps\n    \n    result = words[0]\n    for i in range(1, len(words)):\n        spaces = spaces_per_gap + (1 if i <= extra_spaces else 0)\n        result += ' ' * spaces + words[i]\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 687,
                "problemId": 68,
                "problemTitle": "Text Justification",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Text Justification?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 688,
                "problemId": 68,
                "problemTitle": "Text Justification",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Text Justification",
                "back": "Input: Example input for Text Justification\nOutput: Expected output for Text Justification\nExplanation: Explanation of how to solve Text Justification",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 691,
                "problemId": 69,
                "problemTitle": "Sqrt(x)",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Sqrt(x) problem ask you to do?",
                "back": "Problem 69: Sqrt(x) - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 692,
                "problemId": 69,
                "problemTitle": "Sqrt(x)",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Sqrt(x)?",
                "back": "Algorithm: function mySqrt(x):\n    if x < 2:\n        return x\n    \n    left = 2\n    right = x // 2\n    \n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        \n        if s...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 693,
                "problemId": 69,
                "problemTitle": "Sqrt(x)",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Sqrt(x) solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 694,
                "problemId": 69,
                "problemTitle": "Sqrt(x)",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Sqrt(x) solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 695,
                "problemId": 69,
                "problemTitle": "Sqrt(x)",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Sqrt(x)?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 696,
                "problemId": 69,
                "problemTitle": "Sqrt(x)",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Sqrt(x) in Python?",
                "back": "```python\ndef mySqrt(x):\n    if x < 2:\n        return x\n    \n    left, right = 2, x // 2\n    \n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        \n        if square == x:\n            return mid\n        elif square < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return right\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 697,
                "problemId": 69,
                "problemTitle": "Sqrt(x)",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Sqrt(x)?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 698,
                "problemId": 69,
                "problemTitle": "Sqrt(x)",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Sqrt(x)",
                "back": "Input: Example input for Sqrt(x)\nOutput: Expected output for Sqrt(x)\nExplanation: Explanation of how to solve Sqrt(x)",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 701,
                "problemId": 70,
                "problemTitle": "Climbing Stairs",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Climbing Stairs problem ask you to do?",
                "back": "Find number of distinct ways to climb to the top using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 702,
                "problemId": 70,
                "problemTitle": "Climbing Stairs",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Climbing Stairs?",
                "back": "Algorithm: function climbStairs(n):\n    if n <= 2:\n        return n\n    \n    oneStepBefore = 1\n    twoStepsBefore = 2\n    allWays = 0\n    \n    for i = 3 to n:\n        allWays = oneStepBefore + twoStepsBefore\n   ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 703,
                "problemId": 70,
                "problemTitle": "Climbing Stairs",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Climbing Stairs solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 704,
                "problemId": 70,
                "problemTitle": "Climbing Stairs",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Climbing Stairs solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 705,
                "problemId": 70,
                "problemTitle": "Climbing Stairs",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Climbing Stairs?",
                "back": "Fibonacci pattern. DP approach. Previous two values",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 706,
                "problemId": 70,
                "problemTitle": "Climbing Stairs",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Climbing Stairs in Python?",
                "back": "```python\ndef climbStairs(n):\n    if n <= 2:\n        return n\n    \n    one_step_before = 1\n    two_steps_before = 2\n    all_ways = 0\n    \n    for i in range(3, n + 1):\n        all_ways = one_step_before + two_steps_before\n        two_steps_before = one_step_before\n        one_step_before = all_ways\n    \n    return all_ways\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 707,
                "problemId": 70,
                "problemTitle": "Climbing Stairs",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Climbing Stairs?",
                "back": "Tags: Math, Dynamic Programming, Memoization. This problem focuses on Math algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 708,
                "problemId": 70,
                "problemTitle": "Climbing Stairs",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Climbing Stairs",
                "back": "Input: n = 3\nOutput: 3\nExplanation: Three ways: 1+1+1, 1+2, 2+1.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 711,
                "problemId": 71,
                "problemTitle": "Simplify Path",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Simplify Path problem ask you to do?",
                "back": "Problem 71: Simplify Path - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 712,
                "problemId": 71,
                "problemTitle": "Simplify Path",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Simplify Path?",
                "back": "Algorithm: function simplifyPath(path):\n    stack = []\n    components = path.split(\"/\")\n    \n    for component in components:\n        if component == \"\" or component == \".\":\n            continue\n        elif com...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 713,
                "problemId": 71,
                "problemTitle": "Simplify Path",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Simplify Path solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 714,
                "problemId": 71,
                "problemTitle": "Simplify Path",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Simplify Path solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 715,
                "problemId": 71,
                "problemTitle": "Simplify Path",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Simplify Path?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 716,
                "problemId": 71,
                "problemTitle": "Simplify Path",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Simplify Path in Python?",
                "back": "```python\ndef simplifyPath(path):\n    stack = []\n    components = path.split(\"/\")\n    \n    for component in components:\n        if component == \"\" or component == \".\":\n            continue\n        elif component == \"..\":\n            if stack:\n                stack.pop()\n        else:\n            stack.append(component)\n    \n    return \"/\" + \"/\".join(stack)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 717,
                "problemId": 71,
                "problemTitle": "Simplify Path",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Simplify Path?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 718,
                "problemId": 71,
                "problemTitle": "Simplify Path",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Simplify Path",
                "back": "Input: Example input for Simplify Path\nOutput: Expected output for Simplify Path\nExplanation: Explanation of how to solve Simplify Path",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 721,
                "problemId": 72,
                "problemTitle": "Edit Distance",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Edit Distance problem ask you to do?",
                "back": "Find minimum operations to convert word1 to word2 using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 722,
                "problemId": 72,
                "problemTitle": "Edit Distance",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Edit Distance?",
                "back": "Algorithm: function minDistance(word1, word2):\n    m = word1.length\n    n = word2.length\n    \n    dp = new Array(m+1).fill().map(() => new Array(n+1).fill(0))\n    \n    // Fill first row and column\n    for i = 0 ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 723,
                "problemId": 72,
                "problemTitle": "Edit Distance",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Edit Distance solution?",
                "back": "O(mn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 724,
                "problemId": 72,
                "problemTitle": "Edit Distance",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Edit Distance solution?",
                "back": "O(mn) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 725,
                "problemId": 72,
                "problemTitle": "Edit Distance",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Edit Distance?",
                "back": "DP matrix. Three operations. Minimum cost path",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 726,
                "problemId": 72,
                "problemTitle": "Edit Distance",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Edit Distance in Python?",
                "back": "```python\ndef minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    \n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill first row and column\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    # Fill dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[m][n]\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 727,
                "problemId": 72,
                "problemTitle": "Edit Distance",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Edit Distance?",
                "back": "Tags: String, Dynamic Programming. This problem focuses on String algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 728,
                "problemId": 72,
                "problemTitle": "Edit Distance",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Edit Distance",
                "back": "Input: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: horse \u2192 rorse \u2192 rose \u2192 ros",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 731,
                "problemId": 73,
                "problemTitle": "Set Matrix Zeroes",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Set Matrix Zeroes problem ask you to do?",
                "back": "Problem 73: Set Matrix Zeroes - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 732,
                "problemId": 73,
                "problemTitle": "Set Matrix Zeroes",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Set Matrix Zeroes?",
                "back": "Algorithm: function setZeroes(matrix):\n    m = matrix.length\n    n = matrix[0].length\n    firstRowHasZero = false\n    firstColHasZero = false\n    \n    // Check if first row has zero\n    for j = 0 to n - 1:\n     ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 733,
                "problemId": 73,
                "problemTitle": "Set Matrix Zeroes",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Set Matrix Zeroes solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 734,
                "problemId": 73,
                "problemTitle": "Set Matrix Zeroes",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Set Matrix Zeroes solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 735,
                "problemId": 73,
                "problemTitle": "Set Matrix Zeroes",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Set Matrix Zeroes?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 736,
                "problemId": 73,
                "problemTitle": "Set Matrix Zeroes",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Set Matrix Zeroes in Python?",
                "back": "```python\ndef setZeroes(matrix):\n    m, n = len(matrix), len(matrix[0])\n    first_row_has_zero = False\n    first_col_has_zero = False\n    \n    # Check if first row has zero\n    for j in range(n):\n        if matrix[0][j] == 0:\n            first_row_has_zero = True\n            break\n    \n    # Check if first column has zero\n    for i in range(m):\n        if matrix[i][0] == 0:\n            first_col_has_zero = True\n            break\n    \n    # Use first row and column as markers\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n    \n    # Set zeros based on markers\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n    \n    # Set first row to zero if needed\n    if first_row_has_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n    \n    # Set first column to zero if needed\n    if first_col_has_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 737,
                "problemId": 73,
                "problemTitle": "Set Matrix Zeroes",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Set Matrix Zeroes?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 738,
                "problemId": 73,
                "problemTitle": "Set Matrix Zeroes",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Set Matrix Zeroes",
                "back": "Input: Example input for Set Matrix Zeroes\nOutput: Expected output for Set Matrix Zeroes\nExplanation: Explanation of how to solve Set Matrix Zeroes",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 741,
                "problemId": 74,
                "problemTitle": "Search a 2D Matrix",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Search a 2D Matrix problem ask you to do?",
                "back": "Problem 74: Search a 2D Matrix - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 742,
                "problemId": 74,
                "problemTitle": "Search a 2D Matrix",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Search a 2D Matrix?",
                "back": "Algorithm: function solve74():\n    // Matrix traversal approach\n    if matrix.length == 0:\n        return []\n    \n    m = matrix.length\n    n = matrix[0].length\n    result = []\n    \n    for i = 0 to m - 1:\n     ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 743,
                "problemId": 74,
                "problemTitle": "Search a 2D Matrix",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Search a 2D Matrix solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 744,
                "problemId": 74,
                "problemTitle": "Search a 2D Matrix",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Search a 2D Matrix solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 745,
                "problemId": 74,
                "problemTitle": "Search a 2D Matrix",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Search a 2D Matrix?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 746,
                "problemId": 74,
                "problemTitle": "Search a 2D Matrix",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Search a 2D Matrix in Python?",
                "back": "```python\ndef solve_74():\n    # Matrix traversal approach\n    if not matrix:\n        return []\n    \n    m, n = len(matrix), len(matrix[0])\n    result = []\n    \n    for i in range(m):\n        for j in range(n):\n            # Your logic here\n            pass\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 747,
                "problemId": 74,
                "problemTitle": "Search a 2D Matrix",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Search a 2D Matrix?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 748,
                "problemId": 74,
                "problemTitle": "Search a 2D Matrix",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Search a 2D Matrix",
                "back": "Input: Input for Search a 2D Matrix\nOutput: Expected output for Search a 2D Matrix\nExplanation: Explanation of how to solve Search a 2D Matrix",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 751,
                "problemId": 75,
                "problemTitle": "Sort Colors",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Sort Colors problem ask you to do?",
                "back": "Problem 75: Sort Colors - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 752,
                "problemId": 75,
                "problemTitle": "Sort Colors",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Sort Colors?",
                "back": "Algorithm: function solve75():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 t...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 753,
                "problemId": 75,
                "problemTitle": "Sort Colors",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Sort Colors solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 754,
                "problemId": 75,
                "problemTitle": "Sort Colors",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Sort Colors solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 755,
                "problemId": 75,
                "problemTitle": "Sort Colors",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Sort Colors?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 756,
                "problemId": 75,
                "problemTitle": "Sort Colors",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Sort Colors in Python?",
                "back": "```python\ndef solve_75():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 757,
                "problemId": 75,
                "problemTitle": "Sort Colors",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Sort Colors?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 758,
                "problemId": 75,
                "problemTitle": "Sort Colors",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Sort Colors",
                "back": "Input: Input for Sort Colors\nOutput: Expected output for Sort Colors\nExplanation: Explanation of how to solve Sort Colors",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 761,
                "problemId": 76,
                "problemTitle": "Minimum Window Substring",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Minimum Window Substring problem ask you to do?",
                "back": "Problem 76: Minimum Window Substring - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 762,
                "problemId": 76,
                "problemTitle": "Minimum Window Substring",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Minimum Window Substring?",
                "back": "Algorithm: function minWindow(s, t):\n    if t.length == 0:\n        return \"\"\n    \n    countT = {}\n    for char in t:\n        countT[char] = countT.get(char, 0) + 1\n    \n    have = 0\n    need = countT.size\n    re...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 763,
                "problemId": 76,
                "problemTitle": "Minimum Window Substring",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Minimum Window Substring solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 764,
                "problemId": 76,
                "problemTitle": "Minimum Window Substring",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Minimum Window Substring solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 765,
                "problemId": 76,
                "problemTitle": "Minimum Window Substring",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Minimum Window Substring?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 766,
                "problemId": 76,
                "problemTitle": "Minimum Window Substring",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Minimum Window Substring in Python?",
                "back": "```python\ndef minWindow(s, t):\n    if not t:\n        return \"\"\n    \n    count_t = {}\n    for char in t:\n        count_t[char] = count_t.get(char, 0) + 1\n    \n    have = 0\n    need = len(count_t)\n    result = [-1, -1]\n    result_len = float('inf')\n    \n    window = {}\n    l = 0\n    \n    for r in range(len(s)):\n        c = s[r]\n        window[c] = window.get(c, 0) + 1\n        \n        if c in count_t and window[c] == count_t[c]:\n            have += 1\n        \n        while have == need:\n            if (r - l + 1) < result_len:\n                result = [l, r]\n                result_len = r - l + 1\n            \n            window[s[l]] -= 1\n            if s[l] in count_t and window[s[l]] < count_t[s[l]]:\n                have -= 1\n            l += 1\n    \n    l, r = result\n    return s[l:r+1] if result_len != float('inf') else \n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 767,
                "problemId": 76,
                "problemTitle": "Minimum Window Substring",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Minimum Window Substring?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 768,
                "problemId": 76,
                "problemTitle": "Minimum Window Substring",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Minimum Window Substring",
                "back": "Input: Example input for Minimum Window Substring\nOutput: Expected output for Minimum Window Substring\nExplanation: Explanation of how to solve Minimum Window Substring",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 771,
                "problemId": 77,
                "problemTitle": "Combinations",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Combinations problem ask you to do?",
                "back": "Problem 77: Combinations - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 772,
                "problemId": 77,
                "problemTitle": "Combinations",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Combinations?",
                "back": "Algorithm: function solve77():\n    // Algorithm approach for Combinations\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initial...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 773,
                "problemId": 77,
                "problemTitle": "Combinations",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Combinations solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 774,
                "problemId": 77,
                "problemTitle": "Combinations",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Combinations solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 775,
                "problemId": 77,
                "problemTitle": "Combinations",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Combinations?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 776,
                "problemId": 77,
                "problemTitle": "Combinations",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Combinations in Python?",
                "back": "```python\ndef solve_77():\n    # Algorithm approach for Combinations\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 777,
                "problemId": 77,
                "problemTitle": "Combinations",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Combinations?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 778,
                "problemId": 77,
                "problemTitle": "Combinations",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Combinations",
                "back": "Input: Input for Combinations\nOutput: Expected output for Combinations\nExplanation: Explanation of how to solve Combinations",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 781,
                "problemId": 78,
                "problemTitle": "Subsets",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Subsets problem ask you to do?",
                "back": "Problem 78: Subsets - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 782,
                "problemId": 78,
                "problemTitle": "Subsets",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Subsets?",
                "back": "Algorithm: function solve78():\n    // Algorithm approach for Subsets\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initialize v...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 783,
                "problemId": 78,
                "problemTitle": "Subsets",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Subsets solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 784,
                "problemId": 78,
                "problemTitle": "Subsets",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Subsets solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 785,
                "problemId": 78,
                "problemTitle": "Subsets",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Subsets?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 786,
                "problemId": 78,
                "problemTitle": "Subsets",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Subsets in Python?",
                "back": "```python\ndef solve_78():\n    # Algorithm approach for Subsets\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 787,
                "problemId": 78,
                "problemTitle": "Subsets",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Subsets?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 788,
                "problemId": 78,
                "problemTitle": "Subsets",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Subsets",
                "back": "Input: Input for Subsets\nOutput: Expected output for Subsets\nExplanation: Explanation of how to solve Subsets",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 791,
                "problemId": 79,
                "problemTitle": "Word Search",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Word Search problem ask you to do?",
                "back": "Problem 79: Word Search - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 792,
                "problemId": 79,
                "problemTitle": "Word Search",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Word Search?",
                "back": "Algorithm: function solve79():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the strin...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 793,
                "problemId": 79,
                "problemTitle": "Word Search",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Word Search solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 794,
                "problemId": 79,
                "problemTitle": "Word Search",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Word Search solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 795,
                "problemId": 79,
                "problemTitle": "Word Search",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Word Search?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 796,
                "problemId": 79,
                "problemTitle": "Word Search",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Word Search in Python?",
                "back": "```python\ndef solve_79():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 797,
                "problemId": 79,
                "problemTitle": "Word Search",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Word Search?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 798,
                "problemId": 79,
                "problemTitle": "Word Search",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Word Search",
                "back": "Input: Input for Word Search\nOutput: Expected output for Word Search\nExplanation: Explanation of how to solve Word Search",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 801,
                "problemId": 80,
                "problemTitle": "Remove Duplicates from Sorted Array II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Remove Duplicates from Sorted Array II problem ask you to do?",
                "back": "Problem 80: Remove Duplicates from Sorted Array II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 802,
                "problemId": 80,
                "problemTitle": "Remove Duplicates from Sorted Array II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Remove Duplicates from Sorted Array II?",
                "back": "Algorithm: function solve80():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 t...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 803,
                "problemId": 80,
                "problemTitle": "Remove Duplicates from Sorted Array II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Remove Duplicates from Sorted Array II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 804,
                "problemId": 80,
                "problemTitle": "Remove Duplicates from Sorted Array II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Remove Duplicates from Sorted Array II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 805,
                "problemId": 80,
                "problemTitle": "Remove Duplicates from Sorted Array II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Remove Duplicates from Sorted Array II?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 806,
                "problemId": 80,
                "problemTitle": "Remove Duplicates from Sorted Array II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Remove Duplicates from Sorted Array II in Python?",
                "back": "```python\ndef solve_80():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 807,
                "problemId": 80,
                "problemTitle": "Remove Duplicates from Sorted Array II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Remove Duplicates from Sorted Array II?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 808,
                "problemId": 80,
                "problemTitle": "Remove Duplicates from Sorted Array II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Remove Duplicates from Sorted Array II",
                "back": "Input: Input for Remove Duplicates from Sorted Array II\nOutput: Expected output for Remove Duplicates from Sorted Array II\nExplanation: Explanation of how to solve Remove Duplicates from Sorted Array II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 811,
                "problemId": 81,
                "problemTitle": "Search in Rotated Sorted Array II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Search in Rotated Sorted Array II problem ask you to do?",
                "back": "Problem 81: Search in Rotated Sorted Array II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 812,
                "problemId": 81,
                "problemTitle": "Search in Rotated Sorted Array II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Search in Rotated Sorted Array II?",
                "back": "Algorithm: function solve81():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 t...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 813,
                "problemId": 81,
                "problemTitle": "Search in Rotated Sorted Array II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Search in Rotated Sorted Array II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 814,
                "problemId": 81,
                "problemTitle": "Search in Rotated Sorted Array II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Search in Rotated Sorted Array II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 815,
                "problemId": 81,
                "problemTitle": "Search in Rotated Sorted Array II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Search in Rotated Sorted Array II?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 816,
                "problemId": 81,
                "problemTitle": "Search in Rotated Sorted Array II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Search in Rotated Sorted Array II in Python?",
                "back": "```python\ndef solve_81():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 817,
                "problemId": 81,
                "problemTitle": "Search in Rotated Sorted Array II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Search in Rotated Sorted Array II?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 818,
                "problemId": 81,
                "problemTitle": "Search in Rotated Sorted Array II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Search in Rotated Sorted Array II",
                "back": "Input: Input for Search in Rotated Sorted Array II\nOutput: Expected output for Search in Rotated Sorted Array II\nExplanation: Explanation of how to solve Search in Rotated Sorted Array II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 821,
                "problemId": 82,
                "problemTitle": "Remove Duplicates from Sorted List II",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Remove Duplicates from Sorted List II problem ask you to do?",
                "back": "Problem 82: Remove Duplicates from Sorted List II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 822,
                "problemId": 82,
                "problemTitle": "Remove Duplicates from Sorted List II",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Remove Duplicates from Sorted List II?",
                "back": "Algorithm: function solve82():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 t...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 823,
                "problemId": 82,
                "problemTitle": "Remove Duplicates from Sorted List II",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Remove Duplicates from Sorted List II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 824,
                "problemId": 82,
                "problemTitle": "Remove Duplicates from Sorted List II",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Remove Duplicates from Sorted List II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 825,
                "problemId": 82,
                "problemTitle": "Remove Duplicates from Sorted List II",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Remove Duplicates from Sorted List II?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 826,
                "problemId": 82,
                "problemTitle": "Remove Duplicates from Sorted List II",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Remove Duplicates from Sorted List II in Python?",
                "back": "```python\ndef solve_82():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 827,
                "problemId": 82,
                "problemTitle": "Remove Duplicates from Sorted List II",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Remove Duplicates from Sorted List II?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 828,
                "problemId": 82,
                "problemTitle": "Remove Duplicates from Sorted List II",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Remove Duplicates from Sorted List II",
                "back": "Input: Input for Remove Duplicates from Sorted List II\nOutput: Expected output for Remove Duplicates from Sorted List II\nExplanation: Explanation of how to solve Remove Duplicates from Sorted List II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 831,
                "problemId": 83,
                "problemTitle": "Remove Duplicates from Sorted List",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Remove Duplicates from Sorted List problem ask you to do?",
                "back": "Problem 83: Remove Duplicates from Sorted List - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 832,
                "problemId": 83,
                "problemTitle": "Remove Duplicates from Sorted List",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Remove Duplicates from Sorted List?",
                "back": "Algorithm: function solve83():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 t...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 833,
                "problemId": 83,
                "problemTitle": "Remove Duplicates from Sorted List",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Remove Duplicates from Sorted List solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 834,
                "problemId": 83,
                "problemTitle": "Remove Duplicates from Sorted List",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Remove Duplicates from Sorted List solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 835,
                "problemId": 83,
                "problemTitle": "Remove Duplicates from Sorted List",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Remove Duplicates from Sorted List?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 836,
                "problemId": 83,
                "problemTitle": "Remove Duplicates from Sorted List",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Remove Duplicates from Sorted List in Python?",
                "back": "```python\ndef solve_83():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 837,
                "problemId": 83,
                "problemTitle": "Remove Duplicates from Sorted List",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Remove Duplicates from Sorted List?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 838,
                "problemId": 83,
                "problemTitle": "Remove Duplicates from Sorted List",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Remove Duplicates from Sorted List",
                "back": "Input: Input for Remove Duplicates from Sorted List\nOutput: Expected output for Remove Duplicates from Sorted List\nExplanation: Explanation of how to solve Remove Duplicates from Sorted List",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 841,
                "problemId": 84,
                "problemTitle": "Largest Rectangle in Histogram",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Largest Rectangle in Histogram problem ask you to do?",
                "back": "Find largest rectangle area in histogram using dynamic programming approach.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 842,
                "problemId": 84,
                "problemTitle": "Largest Rectangle in Histogram",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Largest Rectangle in Histogram?",
                "back": "Algorithm: function largestRectangleArea(heights):\n    stack = []\n    maxArea = 0\n    \n    for i = 0 to heights.length:\n        h = heights[i] if i < heights.length else 0\n        \n        while stack and height...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 843,
                "problemId": 84,
                "problemTitle": "Largest Rectangle in Histogram",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Largest Rectangle in Histogram solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 844,
                "problemId": 84,
                "problemTitle": "Largest Rectangle in Histogram",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Largest Rectangle in Histogram solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 845,
                "problemId": 84,
                "problemTitle": "Largest Rectangle in Histogram",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Largest Rectangle in Histogram?",
                "back": "Monotonic stack. Calculate area. DP optimization",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 846,
                "problemId": 84,
                "problemTitle": "Largest Rectangle in Histogram",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Largest Rectangle in Histogram in Python?",
                "back": "```python\ndef largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    \n    for i in range(len(heights) + 1):\n        h = heights[i] if i < len(heights) else 0\n        \n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        stack.append(i)\n    \n    return max_area\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 847,
                "problemId": 84,
                "problemTitle": "Largest Rectangle in Histogram",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Largest Rectangle in Histogram?",
                "back": "Tags: Array, Stack, Monotonic Stack. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 848,
                "problemId": 84,
                "problemTitle": "Largest Rectangle in Histogram",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Largest Rectangle in Histogram",
                "back": "Input: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: Largest rectangle has area 10.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 851,
                "problemId": 85,
                "problemTitle": "Maximal Rectangle",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Maximal Rectangle problem ask you to do?",
                "back": "Find maximal rectangle containing only 1's using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 852,
                "problemId": 85,
                "problemTitle": "Maximal Rectangle",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Maximal Rectangle?",
                "back": "Convert to histogram for each row\nUse largest rectangle approach",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 853,
                "problemId": 85,
                "problemTitle": "Maximal Rectangle",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Maximal Rectangle solution?",
                "back": "O(mn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 854,
                "problemId": 85,
                "problemTitle": "Maximal Rectangle",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Maximal Rectangle solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 855,
                "problemId": 85,
                "problemTitle": "Maximal Rectangle",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Maximal Rectangle?",
                "back": "Convert to histogram. Use largest rectangle. DP approach",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 856,
                "problemId": 85,
                "problemTitle": "Maximal Rectangle",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Maximal Rectangle in Python?",
                "back": "```python\nHistogram method for each row\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 857,
                "problemId": 85,
                "problemTitle": "Maximal Rectangle",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Maximal Rectangle?",
                "back": "Tags: Array, Dynamic Programming, Stack, Matrix. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 858,
                "problemId": 85,
                "problemTitle": "Maximal Rectangle",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Maximal Rectangle",
                "back": "Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: Maximal rectangle has area 6.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 861,
                "problemId": 86,
                "problemTitle": "Partition List",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Partition List problem ask you to do?",
                "back": "Problem 86: Partition List - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 862,
                "problemId": 86,
                "problemTitle": "Partition List",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Partition List?",
                "back": "Algorithm: function solve86():\n    // Linked list traversal approach\n    if head == null:\n        return null\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.nex...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 863,
                "problemId": 86,
                "problemTitle": "Partition List",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Partition List solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 864,
                "problemId": 86,
                "problemTitle": "Partition List",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Partition List solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 865,
                "problemId": 86,
                "problemTitle": "Partition List",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Partition List?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 866,
                "problemId": 86,
                "problemTitle": "Partition List",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Partition List in Python?",
                "back": "```python\ndef solve_86():\n    # Linked list traversal approach\n    if not head:\n        return None\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Your logic here\n        current = current.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 867,
                "problemId": 86,
                "problemTitle": "Partition List",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Partition List?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 868,
                "problemId": 86,
                "problemTitle": "Partition List",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Partition List",
                "back": "Input: Input for Partition List\nOutput: Expected output for Partition List\nExplanation: Explanation of how to solve Partition List",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 871,
                "problemId": 87,
                "problemTitle": "Scramble String",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Scramble String problem ask you to do?",
                "back": "Determine if s2 is a scrambled string of s1 using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 872,
                "problemId": 87,
                "problemTitle": "Scramble String",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Scramble String?",
                "back": "DP with substring checking\nCheck all possible splits",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 873,
                "problemId": 87,
                "problemTitle": "Scramble String",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Scramble String solution?",
                "back": "O(n\u2074) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 874,
                "problemId": 87,
                "problemTitle": "Scramble String",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Scramble String solution?",
                "back": "O(n\u00b3) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 875,
                "problemId": 87,
                "problemTitle": "Scramble String",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Scramble String?",
                "back": "DP approach. Check all splits. Substring validation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 876,
                "problemId": 87,
                "problemTitle": "Scramble String",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Scramble String in Python?",
                "back": "```python\nDP approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 877,
                "problemId": 87,
                "problemTitle": "Scramble String",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Scramble String?",
                "back": "Tags: String, Dynamic Programming. This problem focuses on String algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 878,
                "problemId": 87,
                "problemTitle": "Scramble String",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Scramble String",
                "back": "Input: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: s2 is a scrambled string of s1.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 881,
                "problemId": 88,
                "problemTitle": "Merge Sorted Array",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Merge Sorted Array problem ask you to do?",
                "back": "Problem 88: Merge Sorted Array - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 882,
                "problemId": 88,
                "problemTitle": "Merge Sorted Array",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Merge Sorted Array?",
                "back": "Algorithm: function solve88():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 t...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 883,
                "problemId": 88,
                "problemTitle": "Merge Sorted Array",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Merge Sorted Array solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 884,
                "problemId": 88,
                "problemTitle": "Merge Sorted Array",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Merge Sorted Array solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 885,
                "problemId": 88,
                "problemTitle": "Merge Sorted Array",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Merge Sorted Array?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 886,
                "problemId": 88,
                "problemTitle": "Merge Sorted Array",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Merge Sorted Array in Python?",
                "back": "```python\ndef solve_88():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 887,
                "problemId": 88,
                "problemTitle": "Merge Sorted Array",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Merge Sorted Array?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 888,
                "problemId": 88,
                "problemTitle": "Merge Sorted Array",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Merge Sorted Array",
                "back": "Input: Input for Merge Sorted Array\nOutput: Expected output for Merge Sorted Array\nExplanation: Explanation of how to solve Merge Sorted Array",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 891,
                "problemId": 89,
                "problemTitle": "Gray Code",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Gray Code problem ask you to do?",
                "back": "Problem 89: Gray Code - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 892,
                "problemId": 89,
                "problemTitle": "Gray Code",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Gray Code?",
                "back": "Algorithm: function solve89():\n    // Algorithm approach for Gray Code\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initialize...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 893,
                "problemId": 89,
                "problemTitle": "Gray Code",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Gray Code solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 894,
                "problemId": 89,
                "problemTitle": "Gray Code",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Gray Code solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 895,
                "problemId": 89,
                "problemTitle": "Gray Code",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Gray Code?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 896,
                "problemId": 89,
                "problemTitle": "Gray Code",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Gray Code in Python?",
                "back": "```python\ndef solve_89():\n    # Algorithm approach for Gray Code\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 897,
                "problemId": 89,
                "problemTitle": "Gray Code",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Gray Code?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 898,
                "problemId": 89,
                "problemTitle": "Gray Code",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Gray Code",
                "back": "Input: Input for Gray Code\nOutput: Expected output for Gray Code\nExplanation: Explanation of how to solve Gray Code",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 901,
                "problemId": 90,
                "problemTitle": "Subsets II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Subsets II problem ask you to do?",
                "back": "Problem 90: Subsets II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 902,
                "problemId": 90,
                "problemTitle": "Subsets II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Subsets II?",
                "back": "Algorithm: function solve90():\n    // Algorithm approach for Subsets II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initializ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 903,
                "problemId": 90,
                "problemTitle": "Subsets II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Subsets II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 904,
                "problemId": 90,
                "problemTitle": "Subsets II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Subsets II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 905,
                "problemId": 90,
                "problemTitle": "Subsets II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Subsets II?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 906,
                "problemId": 90,
                "problemTitle": "Subsets II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Subsets II in Python?",
                "back": "```python\ndef solve_90():\n    # Algorithm approach for Subsets II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 907,
                "problemId": 90,
                "problemTitle": "Subsets II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Subsets II?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 908,
                "problemId": 90,
                "problemTitle": "Subsets II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Subsets II",
                "back": "Input: Input for Subsets II\nOutput: Expected output for Subsets II\nExplanation: Explanation of how to solve Subsets II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 911,
                "problemId": 91,
                "problemTitle": "Decode Ways",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Decode Ways problem ask you to do?",
                "back": "Find number of ways to decode a string using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 912,
                "problemId": 91,
                "problemTitle": "Decode Ways",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Decode Ways?",
                "back": "DP with decoding rules\nCheck valid 1-digit and 2-digit codes",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 913,
                "problemId": 91,
                "problemTitle": "Decode Ways",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Decode Ways solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 914,
                "problemId": 91,
                "problemTitle": "Decode Ways",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Decode Ways solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 915,
                "problemId": 91,
                "problemTitle": "Decode Ways",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Decode Ways?",
                "back": "DP approach. Valid codes. 1-digit and 2-digit",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 916,
                "problemId": 91,
                "problemTitle": "Decode Ways",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Decode Ways in Python?",
                "back": "```python\nDP approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 917,
                "problemId": 91,
                "problemTitle": "Decode Ways",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Decode Ways?",
                "back": "Tags: String, Dynamic Programming. This problem focuses on String algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 918,
                "problemId": 91,
                "problemTitle": "Decode Ways",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Decode Ways",
                "back": "Input: s = \"12\"\nOutput: 2\nExplanation: Could be decoded as 'AB' (1 2) or 'L' (12).",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 921,
                "problemId": 92,
                "problemTitle": "Reverse Linked List II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Reverse Linked List II problem ask you to do?",
                "back": "Problem 92: Reverse Linked List II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 922,
                "problemId": 92,
                "problemTitle": "Reverse Linked List II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Reverse Linked List II?",
                "back": "Algorithm: function solve92():\n    // Linked list traversal approach\n    if head == null:\n        return null\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.nex...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 923,
                "problemId": 92,
                "problemTitle": "Reverse Linked List II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Reverse Linked List II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 924,
                "problemId": 92,
                "problemTitle": "Reverse Linked List II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Reverse Linked List II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 925,
                "problemId": 92,
                "problemTitle": "Reverse Linked List II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Reverse Linked List II?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 926,
                "problemId": 92,
                "problemTitle": "Reverse Linked List II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Reverse Linked List II in Python?",
                "back": "```python\ndef solve_92():\n    # Linked list traversal approach\n    if not head:\n        return None\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Your logic here\n        current = current.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 927,
                "problemId": 92,
                "problemTitle": "Reverse Linked List II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Reverse Linked List II?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 928,
                "problemId": 92,
                "problemTitle": "Reverse Linked List II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Reverse Linked List II",
                "back": "Input: Input for Reverse Linked List II\nOutput: Expected output for Reverse Linked List II\nExplanation: Explanation of how to solve Reverse Linked List II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 931,
                "problemId": 93,
                "problemTitle": "Restore IP Addresses",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Restore IP Addresses problem ask you to do?",
                "back": "Problem 93: Restore IP Addresses - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 932,
                "problemId": 93,
                "problemTitle": "Restore IP Addresses",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Restore IP Addresses?",
                "back": "Algorithm: function solve93():\n    // Algorithm approach for Restore IP Addresses\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2:...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 933,
                "problemId": 93,
                "problemTitle": "Restore IP Addresses",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Restore IP Addresses solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 934,
                "problemId": 93,
                "problemTitle": "Restore IP Addresses",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Restore IP Addresses solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 935,
                "problemId": 93,
                "problemTitle": "Restore IP Addresses",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Restore IP Addresses?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 936,
                "problemId": 93,
                "problemTitle": "Restore IP Addresses",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Restore IP Addresses in Python?",
                "back": "```python\ndef solve_93():\n    # Algorithm approach for Restore IP Addresses\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 937,
                "problemId": 93,
                "problemTitle": "Restore IP Addresses",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Restore IP Addresses?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 938,
                "problemId": 93,
                "problemTitle": "Restore IP Addresses",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Restore IP Addresses",
                "back": "Input: Input for Restore IP Addresses\nOutput: Expected output for Restore IP Addresses\nExplanation: Explanation of how to solve Restore IP Addresses",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 941,
                "problemId": 94,
                "problemTitle": "Binary Tree Inorder Traversal",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Binary Tree Inorder Traversal problem ask you to do?",
                "back": "Problem 94: Binary Tree Inorder Traversal - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 942,
                "problemId": 94,
                "problemTitle": "Binary Tree Inorder Traversal",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Tree Inorder Traversal?",
                "back": "Algorithm: function solve94():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        if...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 943,
                "problemId": 94,
                "problemTitle": "Binary Tree Inorder Traversal",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Tree Inorder Traversal solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 944,
                "problemId": 94,
                "problemTitle": "Binary Tree Inorder Traversal",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Tree Inorder Traversal solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 945,
                "problemId": 94,
                "problemTitle": "Binary Tree Inorder Traversal",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Tree Inorder Traversal?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 946,
                "problemId": 94,
                "problemTitle": "Binary Tree Inorder Traversal",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Binary Tree Inorder Traversal in Python?",
                "back": "```python\ndef solve_94():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 947,
                "problemId": 94,
                "problemTitle": "Binary Tree Inorder Traversal",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Tree Inorder Traversal?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 948,
                "problemId": 94,
                "problemTitle": "Binary Tree Inorder Traversal",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Tree Inorder Traversal",
                "back": "Input: Input for Binary Tree Inorder Traversal\nOutput: Expected output for Binary Tree Inorder Traversal\nExplanation: Explanation of how to solve Binary Tree Inorder Traversal",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 951,
                "problemId": 95,
                "problemTitle": "Unique Binary Search Trees II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Unique Binary Search Trees II problem ask you to do?",
                "back": "Generate all structurally unique BST's using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 952,
                "problemId": 95,
                "problemTitle": "Unique Binary Search Trees II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Unique Binary Search Trees II?",
                "back": "Recursive tree building\nUse Catalan numbers",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 953,
                "problemId": 95,
                "problemTitle": "Unique Binary Search Trees II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Unique Binary Search Trees II solution?",
                "back": "O(4^n/\u221an) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 954,
                "problemId": 95,
                "problemTitle": "Unique Binary Search Trees II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Unique Binary Search Trees II solution?",
                "back": "O(4^n/\u221an) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 955,
                "problemId": 95,
                "problemTitle": "Unique Binary Search Trees II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Unique Binary Search Trees II?",
                "back": "Recursive building. Catalan numbers. DP optimization",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 956,
                "problemId": 95,
                "problemTitle": "Unique Binary Search Trees II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Unique Binary Search Trees II in Python?",
                "back": "```python\nRecursive approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 957,
                "problemId": 95,
                "problemTitle": "Unique Binary Search Trees II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Unique Binary Search Trees II?",
                "back": "Tags: Dynamic Programming, Tree, Binary Search Tree, Backtracking. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 958,
                "problemId": 95,
                "problemTitle": "Unique Binary Search Trees II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Unique Binary Search Trees II",
                "back": "Input: n = 3\nOutput: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\nExplanation: All unique BSTs.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 961,
                "problemId": 96,
                "problemTitle": "Unique Binary Search Trees",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Unique Binary Search Trees problem ask you to do?",
                "back": "Count structurally unique BST's using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 962,
                "problemId": 96,
                "problemTitle": "Unique Binary Search Trees",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Unique Binary Search Trees?",
                "back": "function numTrees(n):\n    dp = new Array(n + 1).fill(0)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i = 2 to n:\n        for j = 1 to i:\n            dp[i] += dp[j - 1] * dp[i - j]\n    \n    return dp[n]",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 963,
                "problemId": 96,
                "problemTitle": "Unique Binary Search Trees",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Unique Binary Search Trees solution?",
                "back": "O(n\u00b2) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 964,
                "problemId": 96,
                "problemTitle": "Unique Binary Search Trees",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Unique Binary Search Trees solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 965,
                "problemId": 96,
                "problemTitle": "Unique Binary Search Trees",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Unique Binary Search Trees?",
                "back": "Catalan numbers. DP approach. Formula application",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 966,
                "problemId": 96,
                "problemTitle": "Unique Binary Search Trees",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Unique Binary Search Trees in Python?",
                "back": "```python\ndef numTrees(n):\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    \n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            dp[i] += dp[j - 1] * dp[i - j]\n    \n    return dp[n]\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 967,
                "problemId": 96,
                "problemTitle": "Unique Binary Search Trees",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Unique Binary Search Trees?",
                "back": "Tags: Math, Dynamic Programming, Tree, Binary Search Tree. This problem focuses on Math algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 968,
                "problemId": 96,
                "problemTitle": "Unique Binary Search Trees",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Unique Binary Search Trees",
                "back": "Input: n = 3\nOutput: 5\nExplanation: 5 unique BSTs exist.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 971,
                "problemId": 97,
                "problemTitle": "Interleaving String",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Interleaving String problem ask you to do?",
                "back": "Check if s3 is formed by interleaving s1 and s2 using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 972,
                "problemId": 97,
                "problemTitle": "Interleaving String",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Interleaving String?",
                "back": "DP matrix for interleaving\nCheck all possibilities",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 973,
                "problemId": 97,
                "problemTitle": "Interleaving String",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Interleaving String solution?",
                "back": "O(mn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 974,
                "problemId": 97,
                "problemTitle": "Interleaving String",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Interleaving String solution?",
                "back": "O(mn) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 975,
                "problemId": 97,
                "problemTitle": "Interleaving String",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Interleaving String?",
                "back": "DP matrix. Check interleaving. All possibilities",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 976,
                "problemId": 97,
                "problemTitle": "Interleaving String",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Interleaving String in Python?",
                "back": "```python\nDP table approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 977,
                "problemId": 97,
                "problemTitle": "Interleaving String",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Interleaving String?",
                "back": "Tags: String, Dynamic Programming. This problem focuses on String algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 978,
                "problemId": 97,
                "problemTitle": "Interleaving String",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Interleaving String",
                "back": "Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\nOutput: true\nExplanation: s3 is interleaved from s1 and s2.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 981,
                "problemId": 98,
                "problemTitle": "Validate Binary Search Tree",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Validate Binary Search Tree problem ask you to do?",
                "back": "Problem 98: Validate Binary Search Tree - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 982,
                "problemId": 98,
                "problemTitle": "Validate Binary Search Tree",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Validate Binary Search Tree?",
                "back": "Algorithm: function solve98():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        if...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 983,
                "problemId": 98,
                "problemTitle": "Validate Binary Search Tree",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Validate Binary Search Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 984,
                "problemId": 98,
                "problemTitle": "Validate Binary Search Tree",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Validate Binary Search Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 985,
                "problemId": 98,
                "problemTitle": "Validate Binary Search Tree",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Validate Binary Search Tree?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 986,
                "problemId": 98,
                "problemTitle": "Validate Binary Search Tree",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Validate Binary Search Tree in Python?",
                "back": "```python\ndef solve_98():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 987,
                "problemId": 98,
                "problemTitle": "Validate Binary Search Tree",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Validate Binary Search Tree?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 988,
                "problemId": 98,
                "problemTitle": "Validate Binary Search Tree",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Validate Binary Search Tree",
                "back": "Input: Input for Validate Binary Search Tree\nOutput: Expected output for Validate Binary Search Tree\nExplanation: Explanation of how to solve Validate Binary Search Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 991,
                "problemId": 99,
                "problemTitle": "Recover Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Recover Binary Search Tree problem ask you to do?",
                "back": "Problem 99: Recover Binary Search Tree - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 992,
                "problemId": 99,
                "problemTitle": "Recover Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Recover Binary Search Tree?",
                "back": "Algorithm: function solve99():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        if...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 993,
                "problemId": 99,
                "problemTitle": "Recover Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Recover Binary Search Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 994,
                "problemId": 99,
                "problemTitle": "Recover Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Recover Binary Search Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 995,
                "problemId": 99,
                "problemTitle": "Recover Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Recover Binary Search Tree?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 996,
                "problemId": 99,
                "problemTitle": "Recover Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Recover Binary Search Tree in Python?",
                "back": "```python\ndef solve_99():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 997,
                "problemId": 99,
                "problemTitle": "Recover Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Recover Binary Search Tree?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 998,
                "problemId": 99,
                "problemTitle": "Recover Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Recover Binary Search Tree",
                "back": "Input: Input for Recover Binary Search Tree\nOutput: Expected output for Recover Binary Search Tree\nExplanation: Explanation of how to solve Recover Binary Search Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1001,
                "problemId": 100,
                "problemTitle": "Same Tree",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Same Tree problem ask you to do?",
                "back": "Problem 100: Same Tree - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1002,
                "problemId": 100,
                "problemTitle": "Same Tree",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Same Tree?",
                "back": "Algorithm: function solve100():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1003,
                "problemId": 100,
                "problemTitle": "Same Tree",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Same Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1004,
                "problemId": 100,
                "problemTitle": "Same Tree",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Same Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1005,
                "problemId": 100,
                "problemTitle": "Same Tree",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Same Tree?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1006,
                "problemId": 100,
                "problemTitle": "Same Tree",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Same Tree in Python?",
                "back": "```python\ndef solve_100():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1007,
                "problemId": 100,
                "problemTitle": "Same Tree",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Same Tree?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1008,
                "problemId": 100,
                "problemTitle": "Same Tree",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Same Tree",
                "back": "Input: Input for Same Tree\nOutput: Expected output for Same Tree\nExplanation: Explanation of how to solve Same Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1011,
                "problemId": 101,
                "problemTitle": "Symmetric Tree",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Symmetric Tree problem ask you to do?",
                "back": "Problem 101: Symmetric Tree - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1012,
                "problemId": 101,
                "problemTitle": "Symmetric Tree",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Symmetric Tree?",
                "back": "Algorithm: function solve101():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1013,
                "problemId": 101,
                "problemTitle": "Symmetric Tree",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Symmetric Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1014,
                "problemId": 101,
                "problemTitle": "Symmetric Tree",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Symmetric Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1015,
                "problemId": 101,
                "problemTitle": "Symmetric Tree",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Symmetric Tree?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1016,
                "problemId": 101,
                "problemTitle": "Symmetric Tree",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Symmetric Tree in Python?",
                "back": "```python\ndef solve_101():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1017,
                "problemId": 101,
                "problemTitle": "Symmetric Tree",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Symmetric Tree?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1018,
                "problemId": 101,
                "problemTitle": "Symmetric Tree",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Symmetric Tree",
                "back": "Input: Input for Symmetric Tree\nOutput: Expected output for Symmetric Tree\nExplanation: Explanation of how to solve Symmetric Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1021,
                "problemId": 102,
                "problemTitle": "Binary Tree Level Order Traversal",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Binary Tree Level Order Traversal problem ask you to do?",
                "back": "Problem 102: Binary Tree Level Order Traversal - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1022,
                "problemId": 102,
                "problemTitle": "Binary Tree Level Order Traversal",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Tree Level Order Traversal?",
                "back": "Algorithm: function solve102():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1023,
                "problemId": 102,
                "problemTitle": "Binary Tree Level Order Traversal",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Tree Level Order Traversal solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1024,
                "problemId": 102,
                "problemTitle": "Binary Tree Level Order Traversal",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Tree Level Order Traversal solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1025,
                "problemId": 102,
                "problemTitle": "Binary Tree Level Order Traversal",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Tree Level Order Traversal?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1026,
                "problemId": 102,
                "problemTitle": "Binary Tree Level Order Traversal",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Binary Tree Level Order Traversal in Python?",
                "back": "```python\ndef solve_102():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1027,
                "problemId": 102,
                "problemTitle": "Binary Tree Level Order Traversal",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Tree Level Order Traversal?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1028,
                "problemId": 102,
                "problemTitle": "Binary Tree Level Order Traversal",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Tree Level Order Traversal",
                "back": "Input: Input for Binary Tree Level Order Traversal\nOutput: Expected output for Binary Tree Level Order Traversal\nExplanation: Explanation of how to solve Binary Tree Level Order Traversal",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1031,
                "problemId": 103,
                "problemTitle": "Binary Tree Zigzag Level Order Traversal",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Binary Tree Zigzag Level Order Traversal problem ask you to do?",
                "back": "Problem 103: Binary Tree Zigzag Level Order Traversal - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1032,
                "problemId": 103,
                "problemTitle": "Binary Tree Zigzag Level Order Traversal",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Tree Zigzag Level Order Traversal?",
                "back": "Algorithm: function solve103():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1033,
                "problemId": 103,
                "problemTitle": "Binary Tree Zigzag Level Order Traversal",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Tree Zigzag Level Order Traversal solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1034,
                "problemId": 103,
                "problemTitle": "Binary Tree Zigzag Level Order Traversal",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Tree Zigzag Level Order Traversal solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1035,
                "problemId": 103,
                "problemTitle": "Binary Tree Zigzag Level Order Traversal",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Tree Zigzag Level Order Traversal?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1036,
                "problemId": 103,
                "problemTitle": "Binary Tree Zigzag Level Order Traversal",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Binary Tree Zigzag Level Order Traversal in Python?",
                "back": "```python\ndef solve_103():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1037,
                "problemId": 103,
                "problemTitle": "Binary Tree Zigzag Level Order Traversal",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Tree Zigzag Level Order Traversal?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1038,
                "problemId": 103,
                "problemTitle": "Binary Tree Zigzag Level Order Traversal",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Tree Zigzag Level Order Traversal",
                "back": "Input: Input for Binary Tree Zigzag Level Order Traversal\nOutput: Expected output for Binary Tree Zigzag Level Order Traversal\nExplanation: Explanation of how to solve Binary Tree Zigzag Level Order Traversal",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1041,
                "problemId": 104,
                "problemTitle": "Maximum Depth of Binary Tree",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Maximum Depth of Binary Tree problem ask you to do?",
                "back": "Problem 104: Maximum Depth of Binary Tree - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1042,
                "problemId": 104,
                "problemTitle": "Maximum Depth of Binary Tree",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Maximum Depth of Binary Tree?",
                "back": "Algorithm: function solve104():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1043,
                "problemId": 104,
                "problemTitle": "Maximum Depth of Binary Tree",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Maximum Depth of Binary Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1044,
                "problemId": 104,
                "problemTitle": "Maximum Depth of Binary Tree",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Maximum Depth of Binary Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1045,
                "problemId": 104,
                "problemTitle": "Maximum Depth of Binary Tree",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Maximum Depth of Binary Tree?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1046,
                "problemId": 104,
                "problemTitle": "Maximum Depth of Binary Tree",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Maximum Depth of Binary Tree in Python?",
                "back": "```python\ndef solve_104():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1047,
                "problemId": 104,
                "problemTitle": "Maximum Depth of Binary Tree",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Maximum Depth of Binary Tree?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1048,
                "problemId": 104,
                "problemTitle": "Maximum Depth of Binary Tree",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Maximum Depth of Binary Tree",
                "back": "Input: Input for Maximum Depth of Binary Tree\nOutput: Expected output for Maximum Depth of Binary Tree\nExplanation: Explanation of how to solve Maximum Depth of Binary Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1051,
                "problemId": 105,
                "problemTitle": "Construct Binary Tree from Preorder and Inorder Traversal",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Construct Binary Tree from Preorder and Inorder Traversal problem ask you to do?",
                "back": "Problem 105: Construct Binary Tree from Preorder and Inorder Traversal - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1052,
                "problemId": 105,
                "problemTitle": "Construct Binary Tree from Preorder and Inorder Traversal",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Construct Binary Tree from Preorder and Inorder Traversal?",
                "back": "Algorithm: function solve105():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1053,
                "problemId": 105,
                "problemTitle": "Construct Binary Tree from Preorder and Inorder Traversal",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Construct Binary Tree from Preorder and Inorder Traversal solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1054,
                "problemId": 105,
                "problemTitle": "Construct Binary Tree from Preorder and Inorder Traversal",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Construct Binary Tree from Preorder and Inorder Traversal solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1055,
                "problemId": 105,
                "problemTitle": "Construct Binary Tree from Preorder and Inorder Traversal",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Construct Binary Tree from Preorder and Inorder Traversal?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1056,
                "problemId": 105,
                "problemTitle": "Construct Binary Tree from Preorder and Inorder Traversal",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Construct Binary Tree from Preorder and Inorder Traversal in Python?",
                "back": "```python\ndef solve_105():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1057,
                "problemId": 105,
                "problemTitle": "Construct Binary Tree from Preorder and Inorder Traversal",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Construct Binary Tree from Preorder and Inorder Traversal?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1058,
                "problemId": 105,
                "problemTitle": "Construct Binary Tree from Preorder and Inorder Traversal",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Construct Binary Tree from Preorder and Inorder Traversal",
                "back": "Input: Input for Construct Binary Tree from Preorder and Inorder Traversal\nOutput: Expected output for Construct Binary Tree from Preorder and Inorder Traversal\nExplanation: Explanation of how to solve Construct Binary Tree from Preorder and Inorder Traversal",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1061,
                "problemId": 106,
                "problemTitle": "Construct Binary Tree from Inorder and Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Construct Binary Tree from Inorder and Postorder Traversal problem ask you to do?",
                "back": "Problem 106: Construct Binary Tree from Inorder and Postorder Traversal - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1062,
                "problemId": 106,
                "problemTitle": "Construct Binary Tree from Inorder and Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Construct Binary Tree from Inorder and Postorder Traversal?",
                "back": "Algorithm: function solve106():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1063,
                "problemId": 106,
                "problemTitle": "Construct Binary Tree from Inorder and Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Construct Binary Tree from Inorder and Postorder Traversal solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1064,
                "problemId": 106,
                "problemTitle": "Construct Binary Tree from Inorder and Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Construct Binary Tree from Inorder and Postorder Traversal solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1065,
                "problemId": 106,
                "problemTitle": "Construct Binary Tree from Inorder and Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Construct Binary Tree from Inorder and Postorder Traversal?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1066,
                "problemId": 106,
                "problemTitle": "Construct Binary Tree from Inorder and Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Construct Binary Tree from Inorder and Postorder Traversal in Python?",
                "back": "```python\ndef solve_106():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1067,
                "problemId": 106,
                "problemTitle": "Construct Binary Tree from Inorder and Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Construct Binary Tree from Inorder and Postorder Traversal?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1068,
                "problemId": 106,
                "problemTitle": "Construct Binary Tree from Inorder and Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Construct Binary Tree from Inorder and Postorder Traversal",
                "back": "Input: Input for Construct Binary Tree from Inorder and Postorder Traversal\nOutput: Expected output for Construct Binary Tree from Inorder and Postorder Traversal\nExplanation: Explanation of how to solve Construct Binary Tree from Inorder and Postorder Traversal",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1071,
                "problemId": 107,
                "problemTitle": "Binary Tree Level Order Traversal II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Binary Tree Level Order Traversal II problem ask you to do?",
                "back": "Problem 107: Binary Tree Level Order Traversal II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1072,
                "problemId": 107,
                "problemTitle": "Binary Tree Level Order Traversal II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Tree Level Order Traversal II?",
                "back": "Algorithm: function solve107():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1073,
                "problemId": 107,
                "problemTitle": "Binary Tree Level Order Traversal II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Tree Level Order Traversal II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1074,
                "problemId": 107,
                "problemTitle": "Binary Tree Level Order Traversal II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Tree Level Order Traversal II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1075,
                "problemId": 107,
                "problemTitle": "Binary Tree Level Order Traversal II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Tree Level Order Traversal II?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1076,
                "problemId": 107,
                "problemTitle": "Binary Tree Level Order Traversal II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Binary Tree Level Order Traversal II in Python?",
                "back": "```python\ndef solve_107():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1077,
                "problemId": 107,
                "problemTitle": "Binary Tree Level Order Traversal II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Tree Level Order Traversal II?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1078,
                "problemId": 107,
                "problemTitle": "Binary Tree Level Order Traversal II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Tree Level Order Traversal II",
                "back": "Input: Input for Binary Tree Level Order Traversal II\nOutput: Expected output for Binary Tree Level Order Traversal II\nExplanation: Explanation of how to solve Binary Tree Level Order Traversal II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1081,
                "problemId": 108,
                "problemTitle": "Convert Sorted Array to Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Convert Sorted Array to Binary Search Tree problem ask you to do?",
                "back": "Problem 108: Convert Sorted Array to Binary Search Tree - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1082,
                "problemId": 108,
                "problemTitle": "Convert Sorted Array to Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Convert Sorted Array to Binary Search Tree?",
                "back": "Algorithm: function solve108():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1083,
                "problemId": 108,
                "problemTitle": "Convert Sorted Array to Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Convert Sorted Array to Binary Search Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1084,
                "problemId": 108,
                "problemTitle": "Convert Sorted Array to Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Convert Sorted Array to Binary Search Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1085,
                "problemId": 108,
                "problemTitle": "Convert Sorted Array to Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Convert Sorted Array to Binary Search Tree?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1086,
                "problemId": 108,
                "problemTitle": "Convert Sorted Array to Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Convert Sorted Array to Binary Search Tree in Python?",
                "back": "```python\ndef solve_108():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1087,
                "problemId": 108,
                "problemTitle": "Convert Sorted Array to Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Convert Sorted Array to Binary Search Tree?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1088,
                "problemId": 108,
                "problemTitle": "Convert Sorted Array to Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Convert Sorted Array to Binary Search Tree",
                "back": "Input: Input for Convert Sorted Array to Binary Search Tree\nOutput: Expected output for Convert Sorted Array to Binary Search Tree\nExplanation: Explanation of how to solve Convert Sorted Array to Binary Search Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1091,
                "problemId": 109,
                "problemTitle": "Convert Sorted List to Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Convert Sorted List to Binary Search Tree problem ask you to do?",
                "back": "Problem 109: Convert Sorted List to Binary Search Tree - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1092,
                "problemId": 109,
                "problemTitle": "Convert Sorted List to Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Convert Sorted List to Binary Search Tree?",
                "back": "Algorithm: function solve109():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1093,
                "problemId": 109,
                "problemTitle": "Convert Sorted List to Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Convert Sorted List to Binary Search Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1094,
                "problemId": 109,
                "problemTitle": "Convert Sorted List to Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Convert Sorted List to Binary Search Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1095,
                "problemId": 109,
                "problemTitle": "Convert Sorted List to Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Convert Sorted List to Binary Search Tree?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1096,
                "problemId": 109,
                "problemTitle": "Convert Sorted List to Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Convert Sorted List to Binary Search Tree in Python?",
                "back": "```python\ndef solve_109():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1097,
                "problemId": 109,
                "problemTitle": "Convert Sorted List to Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Convert Sorted List to Binary Search Tree?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1098,
                "problemId": 109,
                "problemTitle": "Convert Sorted List to Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Convert Sorted List to Binary Search Tree",
                "back": "Input: Input for Convert Sorted List to Binary Search Tree\nOutput: Expected output for Convert Sorted List to Binary Search Tree\nExplanation: Explanation of how to solve Convert Sorted List to Binary Search Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1101,
                "problemId": 110,
                "problemTitle": "Balanced Binary Tree",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Balanced Binary Tree problem ask you to do?",
                "back": "Problem 110: Balanced Binary Tree - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1102,
                "problemId": 110,
                "problemTitle": "Balanced Binary Tree",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Balanced Binary Tree?",
                "back": "Algorithm: function solve110():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1103,
                "problemId": 110,
                "problemTitle": "Balanced Binary Tree",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Balanced Binary Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1104,
                "problemId": 110,
                "problemTitle": "Balanced Binary Tree",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Balanced Binary Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1105,
                "problemId": 110,
                "problemTitle": "Balanced Binary Tree",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Balanced Binary Tree?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1106,
                "problemId": 110,
                "problemTitle": "Balanced Binary Tree",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Balanced Binary Tree in Python?",
                "back": "```python\ndef solve_110():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1107,
                "problemId": 110,
                "problemTitle": "Balanced Binary Tree",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Balanced Binary Tree?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1108,
                "problemId": 110,
                "problemTitle": "Balanced Binary Tree",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Balanced Binary Tree",
                "back": "Input: Input for Balanced Binary Tree\nOutput: Expected output for Balanced Binary Tree\nExplanation: Explanation of how to solve Balanced Binary Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1111,
                "problemId": 111,
                "problemTitle": "Minimum Depth of Binary Tree",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Minimum Depth of Binary Tree problem ask you to do?",
                "back": "Problem 111: Minimum Depth of Binary Tree - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1112,
                "problemId": 111,
                "problemTitle": "Minimum Depth of Binary Tree",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Minimum Depth of Binary Tree?",
                "back": "Algorithm: function solve111():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1113,
                "problemId": 111,
                "problemTitle": "Minimum Depth of Binary Tree",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Minimum Depth of Binary Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1114,
                "problemId": 111,
                "problemTitle": "Minimum Depth of Binary Tree",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Minimum Depth of Binary Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1115,
                "problemId": 111,
                "problemTitle": "Minimum Depth of Binary Tree",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Minimum Depth of Binary Tree?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1116,
                "problemId": 111,
                "problemTitle": "Minimum Depth of Binary Tree",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Minimum Depth of Binary Tree in Python?",
                "back": "```python\ndef solve_111():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1117,
                "problemId": 111,
                "problemTitle": "Minimum Depth of Binary Tree",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Minimum Depth of Binary Tree?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1118,
                "problemId": 111,
                "problemTitle": "Minimum Depth of Binary Tree",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Minimum Depth of Binary Tree",
                "back": "Input: Input for Minimum Depth of Binary Tree\nOutput: Expected output for Minimum Depth of Binary Tree\nExplanation: Explanation of how to solve Minimum Depth of Binary Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1121,
                "problemId": 112,
                "problemTitle": "Path Sum",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Path Sum problem ask you to do?",
                "back": "Problem 112: Path Sum - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1122,
                "problemId": 112,
                "problemTitle": "Path Sum",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Path Sum?",
                "back": "Algorithm: function solve112():\n    // Algorithm approach for Path Sum\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initialize...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1123,
                "problemId": 112,
                "problemTitle": "Path Sum",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Path Sum solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1124,
                "problemId": 112,
                "problemTitle": "Path Sum",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Path Sum solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1125,
                "problemId": 112,
                "problemTitle": "Path Sum",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Path Sum?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1126,
                "problemId": 112,
                "problemTitle": "Path Sum",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Path Sum in Python?",
                "back": "```python\ndef solve_112():\n    # Algorithm approach for Path Sum\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1127,
                "problemId": 112,
                "problemTitle": "Path Sum",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Path Sum?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1128,
                "problemId": 112,
                "problemTitle": "Path Sum",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Path Sum",
                "back": "Input: Input for Path Sum\nOutput: Expected output for Path Sum\nExplanation: Explanation of how to solve Path Sum",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1131,
                "problemId": 113,
                "problemTitle": "Path Sum II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Path Sum II problem ask you to do?",
                "back": "Problem 113: Path Sum II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1132,
                "problemId": 113,
                "problemTitle": "Path Sum II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Path Sum II?",
                "back": "Algorithm: function solve113():\n    // Algorithm approach for Path Sum II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initial...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1133,
                "problemId": 113,
                "problemTitle": "Path Sum II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Path Sum II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1134,
                "problemId": 113,
                "problemTitle": "Path Sum II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Path Sum II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1135,
                "problemId": 113,
                "problemTitle": "Path Sum II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Path Sum II?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1136,
                "problemId": 113,
                "problemTitle": "Path Sum II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Path Sum II in Python?",
                "back": "```python\ndef solve_113():\n    # Algorithm approach for Path Sum II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1137,
                "problemId": 113,
                "problemTitle": "Path Sum II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Path Sum II?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1138,
                "problemId": 113,
                "problemTitle": "Path Sum II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Path Sum II",
                "back": "Input: Input for Path Sum II\nOutput: Expected output for Path Sum II\nExplanation: Explanation of how to solve Path Sum II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1141,
                "problemId": 114,
                "problemTitle": "Flatten Binary Tree to Linked List",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Flatten Binary Tree to Linked List problem ask you to do?",
                "back": "Problem 114: Flatten Binary Tree to Linked List - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1142,
                "problemId": 114,
                "problemTitle": "Flatten Binary Tree to Linked List",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Flatten Binary Tree to Linked List?",
                "back": "Algorithm: function solve114():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1143,
                "problemId": 114,
                "problemTitle": "Flatten Binary Tree to Linked List",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Flatten Binary Tree to Linked List solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1144,
                "problemId": 114,
                "problemTitle": "Flatten Binary Tree to Linked List",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Flatten Binary Tree to Linked List solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1145,
                "problemId": 114,
                "problemTitle": "Flatten Binary Tree to Linked List",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Flatten Binary Tree to Linked List?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1146,
                "problemId": 114,
                "problemTitle": "Flatten Binary Tree to Linked List",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Flatten Binary Tree to Linked List in Python?",
                "back": "```python\ndef solve_114():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1147,
                "problemId": 114,
                "problemTitle": "Flatten Binary Tree to Linked List",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Flatten Binary Tree to Linked List?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1148,
                "problemId": 114,
                "problemTitle": "Flatten Binary Tree to Linked List",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Flatten Binary Tree to Linked List",
                "back": "Input: Input for Flatten Binary Tree to Linked List\nOutput: Expected output for Flatten Binary Tree to Linked List\nExplanation: Explanation of how to solve Flatten Binary Tree to Linked List",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1151,
                "problemId": 115,
                "problemTitle": "Distinct Subsequences",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Distinct Subsequences problem ask you to do?",
                "back": "Count distinct subsequences of s that equal t using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1152,
                "problemId": 115,
                "problemTitle": "Distinct Subsequences",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Distinct Subsequences?",
                "back": "DP matrix for subsequence counting\nMatch characters",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1153,
                "problemId": 115,
                "problemTitle": "Distinct Subsequences",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Distinct Subsequences solution?",
                "back": "O(mn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1154,
                "problemId": 115,
                "problemTitle": "Distinct Subsequences",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Distinct Subsequences solution?",
                "back": "O(mn) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1155,
                "problemId": 115,
                "problemTitle": "Distinct Subsequences",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Distinct Subsequences?",
                "back": "DP matrix. Subsequence counting. Character matching",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1156,
                "problemId": 115,
                "problemTitle": "Distinct Subsequences",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Distinct Subsequences in Python?",
                "back": "```python\nDP approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1157,
                "problemId": 115,
                "problemTitle": "Distinct Subsequences",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Distinct Subsequences?",
                "back": "Tags: String, Dynamic Programming. This problem focuses on String algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1158,
                "problemId": 115,
                "problemTitle": "Distinct Subsequences",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Distinct Subsequences",
                "back": "Input: s = \"rabbbit\", t = \"rabbit\"\nOutput: 3\nExplanation: 3 distinct subsequences.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1161,
                "problemId": 116,
                "problemTitle": "Populating Next Right Pointers in Each Node",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Populating Next Right Pointers in Each Node problem ask you to do?",
                "back": "Problem 116: Populating Next Right Pointers in Each Node - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1162,
                "problemId": 116,
                "problemTitle": "Populating Next Right Pointers in Each Node",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Populating Next Right Pointers in Each Node?",
                "back": "Algorithm: function solve116():\n    // Algorithm approach for Populating Next Right Pointers in Each Node\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_v...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1163,
                "problemId": 116,
                "problemTitle": "Populating Next Right Pointers in Each Node",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Populating Next Right Pointers in Each Node solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1164,
                "problemId": 116,
                "problemTitle": "Populating Next Right Pointers in Each Node",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Populating Next Right Pointers in Each Node solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1165,
                "problemId": 116,
                "problemTitle": "Populating Next Right Pointers in Each Node",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Populating Next Right Pointers in Each Node?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1166,
                "problemId": 116,
                "problemTitle": "Populating Next Right Pointers in Each Node",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Populating Next Right Pointers in Each Node in Python?",
                "back": "```python\ndef solve_116():\n    # Algorithm approach for Populating Next Right Pointers in Each Node\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1167,
                "problemId": 116,
                "problemTitle": "Populating Next Right Pointers in Each Node",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Populating Next Right Pointers in Each Node?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1168,
                "problemId": 116,
                "problemTitle": "Populating Next Right Pointers in Each Node",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Populating Next Right Pointers in Each Node",
                "back": "Input: Input for Populating Next Right Pointers in Each Node\nOutput: Expected output for Populating Next Right Pointers in Each Node\nExplanation: Explanation of how to solve Populating Next Right Pointers in Each Node",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1171,
                "problemId": 117,
                "problemTitle": "Populating Next Right Pointers in Each Node II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Populating Next Right Pointers in Each Node II problem ask you to do?",
                "back": "Problem 117: Populating Next Right Pointers in Each Node II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1172,
                "problemId": 117,
                "problemTitle": "Populating Next Right Pointers in Each Node II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Populating Next Right Pointers in Each Node II?",
                "back": "Algorithm: function solve117():\n    // Algorithm approach for Populating Next Right Pointers in Each Node II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return defaul...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1173,
                "problemId": 117,
                "problemTitle": "Populating Next Right Pointers in Each Node II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Populating Next Right Pointers in Each Node II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1174,
                "problemId": 117,
                "problemTitle": "Populating Next Right Pointers in Each Node II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Populating Next Right Pointers in Each Node II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1175,
                "problemId": 117,
                "problemTitle": "Populating Next Right Pointers in Each Node II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Populating Next Right Pointers in Each Node II?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1176,
                "problemId": 117,
                "problemTitle": "Populating Next Right Pointers in Each Node II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Populating Next Right Pointers in Each Node II in Python?",
                "back": "```python\ndef solve_117():\n    # Algorithm approach for Populating Next Right Pointers in Each Node II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1177,
                "problemId": 117,
                "problemTitle": "Populating Next Right Pointers in Each Node II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Populating Next Right Pointers in Each Node II?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1178,
                "problemId": 117,
                "problemTitle": "Populating Next Right Pointers in Each Node II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Populating Next Right Pointers in Each Node II",
                "back": "Input: Input for Populating Next Right Pointers in Each Node II\nOutput: Expected output for Populating Next Right Pointers in Each Node II\nExplanation: Explanation of how to solve Populating Next Right Pointers in Each Node II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1181,
                "problemId": 118,
                "problemTitle": "Pascal's Triangle",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Pascal's Triangle problem ask you to do?",
                "back": "Problem 118: Pascal's Triangle - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1182,
                "problemId": 118,
                "problemTitle": "Pascal's Triangle",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Pascal's Triangle?",
                "back": "Algorithm: function solve118():\n    // Algorithm approach for Pascal's Triangle\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: I...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1183,
                "problemId": 118,
                "problemTitle": "Pascal's Triangle",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Pascal's Triangle solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1184,
                "problemId": 118,
                "problemTitle": "Pascal's Triangle",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Pascal's Triangle solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1185,
                "problemId": 118,
                "problemTitle": "Pascal's Triangle",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Pascal's Triangle?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1186,
                "problemId": 118,
                "problemTitle": "Pascal's Triangle",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Pascal's Triangle in Python?",
                "back": "```python\ndef solve_118():\n    # Algorithm approach for Pascal's Triangle\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1187,
                "problemId": 118,
                "problemTitle": "Pascal's Triangle",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Pascal's Triangle?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1188,
                "problemId": 118,
                "problemTitle": "Pascal's Triangle",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Pascal's Triangle",
                "back": "Input: Input for Pascal's Triangle\nOutput: Expected output for Pascal's Triangle\nExplanation: Explanation of how to solve Pascal's Triangle",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1191,
                "problemId": 119,
                "problemTitle": "Pascal's Triangle II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Pascal's Triangle II problem ask you to do?",
                "back": "Problem 119: Pascal's Triangle II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1192,
                "problemId": 119,
                "problemTitle": "Pascal's Triangle II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Pascal's Triangle II?",
                "back": "Algorithm: function solve119():\n    // Algorithm approach for Pascal's Triangle II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1193,
                "problemId": 119,
                "problemTitle": "Pascal's Triangle II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Pascal's Triangle II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1194,
                "problemId": 119,
                "problemTitle": "Pascal's Triangle II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Pascal's Triangle II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1195,
                "problemId": 119,
                "problemTitle": "Pascal's Triangle II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Pascal's Triangle II?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1196,
                "problemId": 119,
                "problemTitle": "Pascal's Triangle II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Pascal's Triangle II in Python?",
                "back": "```python\ndef solve_119():\n    # Algorithm approach for Pascal's Triangle II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1197,
                "problemId": 119,
                "problemTitle": "Pascal's Triangle II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Pascal's Triangle II?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1198,
                "problemId": 119,
                "problemTitle": "Pascal's Triangle II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Pascal's Triangle II",
                "back": "Input: Input for Pascal's Triangle II\nOutput: Expected output for Pascal's Triangle II\nExplanation: Explanation of how to solve Pascal's Triangle II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1201,
                "problemId": 120,
                "problemTitle": "Triangle",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Triangle problem ask you to do?",
                "back": "Find minimum path sum from top to bottom of triangle using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1202,
                "problemId": 120,
                "problemTitle": "Triangle",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Triangle?",
                "back": "Bottom-up DP\nChoose minimum of adjacent elements",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1203,
                "problemId": 120,
                "problemTitle": "Triangle",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Triangle solution?",
                "back": "O(n\u00b2) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1204,
                "problemId": 120,
                "problemTitle": "Triangle",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Triangle solution?",
                "back": "O(n\u00b2) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1205,
                "problemId": 120,
                "problemTitle": "Triangle",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Triangle?",
                "back": "Bottom-up DP. Choose minimum. Adjacent elements",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1206,
                "problemId": 120,
                "problemTitle": "Triangle",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Triangle in Python?",
                "back": "```python\nBottom-up DP approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1207,
                "problemId": 120,
                "problemTitle": "Triangle",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Triangle?",
                "back": "Tags: Array, Dynamic Programming. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1208,
                "problemId": 120,
                "problemTitle": "Triangle",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Triangle",
                "back": "Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: Path 2\u21923\u21925\u21921 minimizes sum to 11.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1211,
                "problemId": 121,
                "problemTitle": "Best Time to Buy and Sell Stock",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Best Time to Buy and Sell Stock problem ask you to do?",
                "back": "Find maximum profit from one transaction using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1212,
                "problemId": 121,
                "problemTitle": "Best Time to Buy and Sell Stock",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Best Time to Buy and Sell Stock?",
                "back": "Algorithm: function maxProfit(prices):\n    if prices.length < 2:\n        return 0\n    \n    minPrice = prices[0]\n    maxProfit = 0\n    \n    for i = 1 to prices.length - 1:\n        if prices[i] < minPrice:\n       ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1213,
                "problemId": 121,
                "problemTitle": "Best Time to Buy and Sell Stock",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Best Time to Buy and Sell Stock solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1214,
                "problemId": 121,
                "problemTitle": "Best Time to Buy and Sell Stock",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Best Time to Buy and Sell Stock solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1215,
                "problemId": 121,
                "problemTitle": "Best Time to Buy and Sell Stock",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Best Time to Buy and Sell Stock?",
                "back": "Track minimum. Calculate profit. DP optimization",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1216,
                "problemId": 121,
                "problemTitle": "Best Time to Buy and Sell Stock",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Best Time to Buy and Sell Stock in Python?",
                "back": "```python\ndef maxProfit(prices):\n    if len(prices) < 2:\n        return 0\n    \n    min_price = prices[0]\n    max_profit = 0\n    \n    for i in range(1, len(prices)):\n        if prices[i] < min_price:\n            min_price = prices[i]\n        else:\n            max_profit = max(max_profit, prices[i] - min_price)\n    \n    return max_profit\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1217,
                "problemId": 121,
                "problemTitle": "Best Time to Buy and Sell Stock",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Best Time to Buy and Sell Stock?",
                "back": "Tags: Array, Dynamic Programming. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1218,
                "problemId": 121,
                "problemTitle": "Best Time to Buy and Sell Stock",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Best Time to Buy and Sell Stock",
                "back": "Input: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy at 1, sell at 6 for profit 5.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1221,
                "problemId": 122,
                "problemTitle": "Best Time to Buy and Sell Stock II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Best Time to Buy and Sell Stock II problem ask you to do?",
                "back": "Find maximum profit from multiple transactions using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1222,
                "problemId": 122,
                "problemTitle": "Best Time to Buy and Sell Stock II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Best Time to Buy and Sell Stock II?",
                "back": "Greedy approach\nBuy low, sell high",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1223,
                "problemId": 122,
                "problemTitle": "Best Time to Buy and Sell Stock II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Best Time to Buy and Sell Stock II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1224,
                "problemId": 122,
                "problemTitle": "Best Time to Buy and Sell Stock II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Best Time to Buy and Sell Stock II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1225,
                "problemId": 122,
                "problemTitle": "Best Time to Buy and Sell Stock II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Best Time to Buy and Sell Stock II?",
                "back": "Greedy approach. Buy low sell high. DP optimization",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1226,
                "problemId": 122,
                "problemTitle": "Best Time to Buy and Sell Stock II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Best Time to Buy and Sell Stock II in Python?",
                "back": "```python\nGreedy with DP\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1227,
                "problemId": 122,
                "problemTitle": "Best Time to Buy and Sell Stock II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Best Time to Buy and Sell Stock II?",
                "back": "Tags: Array, Dynamic Programming, Greedy. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1228,
                "problemId": 122,
                "problemTitle": "Best Time to Buy and Sell Stock II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Best Time to Buy and Sell Stock II",
                "back": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy at 1, sell at 5; buy at 3, sell at 6.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1231,
                "problemId": 123,
                "problemTitle": "Best Time to Buy and Sell Stock III",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Best Time to Buy and Sell Stock III problem ask you to do?",
                "back": "Find maximum profit from at most two transactions using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1232,
                "problemId": 123,
                "problemTitle": "Best Time to Buy and Sell Stock III",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Best Time to Buy and Sell Stock III?",
                "back": "DP with state machine\nTrack buy/sell states",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1233,
                "problemId": 123,
                "problemTitle": "Best Time to Buy and Sell Stock III",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Best Time to Buy and Sell Stock III solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1234,
                "problemId": 123,
                "problemTitle": "Best Time to Buy and Sell Stock III",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Best Time to Buy and Sell Stock III solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1235,
                "problemId": 123,
                "problemTitle": "Best Time to Buy and Sell Stock III",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Best Time to Buy and Sell Stock III?",
                "back": "State machine. Buy/sell states. DP approach",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1236,
                "problemId": 123,
                "problemTitle": "Best Time to Buy and Sell Stock III",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Best Time to Buy and Sell Stock III in Python?",
                "back": "```python\nDP state machine\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1237,
                "problemId": 123,
                "problemTitle": "Best Time to Buy and Sell Stock III",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Best Time to Buy and Sell Stock III?",
                "back": "Tags: Array, Dynamic Programming. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1238,
                "problemId": 123,
                "problemTitle": "Best Time to Buy and Sell Stock III",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Best Time to Buy and Sell Stock III",
                "back": "Input: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy at 3, sell at 5; buy at 0, sell at 4.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1241,
                "problemId": 124,
                "problemTitle": "Binary Tree Maximum Path Sum",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Binary Tree Maximum Path Sum problem ask you to do?",
                "back": "Find maximum path sum in binary tree using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1242,
                "problemId": 124,
                "problemTitle": "Binary Tree Maximum Path Sum",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Tree Maximum Path Sum?",
                "back": "DFS with path tracking\nUpdate global maximum",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1243,
                "problemId": 124,
                "problemTitle": "Binary Tree Maximum Path Sum",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Tree Maximum Path Sum solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1244,
                "problemId": 124,
                "problemTitle": "Binary Tree Maximum Path Sum",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Tree Maximum Path Sum solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1245,
                "problemId": 124,
                "problemTitle": "Binary Tree Maximum Path Sum",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Tree Maximum Path Sum?",
                "back": "DFS approach. Path tracking. Global maximum",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1246,
                "problemId": 124,
                "problemTitle": "Binary Tree Maximum Path Sum",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Binary Tree Maximum Path Sum in Python?",
                "back": "```python\nDFS with DP\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1247,
                "problemId": 124,
                "problemTitle": "Binary Tree Maximum Path Sum",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Tree Maximum Path Sum?",
                "back": "Tags: Tree, Depth-First Search, Dynamic Programming. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1248,
                "problemId": 124,
                "problemTitle": "Binary Tree Maximum Path Sum",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Tree Maximum Path Sum",
                "back": "Input: root = [1,2,3]\nOutput: 6\nExplanation: Path 2\u21921\u21923 has maximum sum 6.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1251,
                "problemId": 125,
                "problemTitle": "Valid Palindrome",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Valid Palindrome problem ask you to do?",
                "back": "Problem 125: Valid Palindrome - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1252,
                "problemId": 125,
                "problemTitle": "Valid Palindrome",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Valid Palindrome?",
                "back": "Algorithm: function solve125():\n    // Algorithm approach for Valid Palindrome\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: In...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1253,
                "problemId": 125,
                "problemTitle": "Valid Palindrome",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Valid Palindrome solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1254,
                "problemId": 125,
                "problemTitle": "Valid Palindrome",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Valid Palindrome solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1255,
                "problemId": 125,
                "problemTitle": "Valid Palindrome",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Valid Palindrome?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1256,
                "problemId": 125,
                "problemTitle": "Valid Palindrome",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Valid Palindrome in Python?",
                "back": "```python\ndef solve_125():\n    # Algorithm approach for Valid Palindrome\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1257,
                "problemId": 125,
                "problemTitle": "Valid Palindrome",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Valid Palindrome?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1258,
                "problemId": 125,
                "problemTitle": "Valid Palindrome",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Valid Palindrome",
                "back": "Input: Input for Valid Palindrome\nOutput: Expected output for Valid Palindrome\nExplanation: Explanation of how to solve Valid Palindrome",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1261,
                "problemId": 126,
                "problemTitle": "Word Ladder II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Word Ladder II problem ask you to do?",
                "back": "Problem 126: Word Ladder II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1262,
                "problemId": 126,
                "problemTitle": "Word Ladder II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Word Ladder II?",
                "back": "Algorithm: function solve126():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1263,
                "problemId": 126,
                "problemTitle": "Word Ladder II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Word Ladder II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1264,
                "problemId": 126,
                "problemTitle": "Word Ladder II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Word Ladder II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1265,
                "problemId": 126,
                "problemTitle": "Word Ladder II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Word Ladder II?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1266,
                "problemId": 126,
                "problemTitle": "Word Ladder II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Word Ladder II in Python?",
                "back": "```python\ndef solve_126():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1267,
                "problemId": 126,
                "problemTitle": "Word Ladder II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Word Ladder II?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1268,
                "problemId": 126,
                "problemTitle": "Word Ladder II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Word Ladder II",
                "back": "Input: Input for Word Ladder II\nOutput: Expected output for Word Ladder II\nExplanation: Explanation of how to solve Word Ladder II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1271,
                "problemId": 127,
                "problemTitle": "Word Ladder",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Word Ladder problem ask you to do?",
                "back": "Problem 127: Word Ladder - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1272,
                "problemId": 127,
                "problemTitle": "Word Ladder",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Word Ladder?",
                "back": "Algorithm: function solve127():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1273,
                "problemId": 127,
                "problemTitle": "Word Ladder",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Word Ladder solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1274,
                "problemId": 127,
                "problemTitle": "Word Ladder",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Word Ladder solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1275,
                "problemId": 127,
                "problemTitle": "Word Ladder",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Word Ladder?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1276,
                "problemId": 127,
                "problemTitle": "Word Ladder",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Word Ladder in Python?",
                "back": "```python\ndef solve_127():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1277,
                "problemId": 127,
                "problemTitle": "Word Ladder",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Word Ladder?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1278,
                "problemId": 127,
                "problemTitle": "Word Ladder",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Word Ladder",
                "back": "Input: Input for Word Ladder\nOutput: Expected output for Word Ladder\nExplanation: Explanation of how to solve Word Ladder",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1281,
                "problemId": 128,
                "problemTitle": "Longest Consecutive Sequence",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Longest Consecutive Sequence problem ask you to do?",
                "back": "Problem 128: Longest Consecutive Sequence - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1282,
                "problemId": 128,
                "problemTitle": "Longest Consecutive Sequence",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Longest Consecutive Sequence?",
                "back": "Algorithm: function solve128():\n    // Algorithm approach for Longest Consecutive Sequence\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    /...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1283,
                "problemId": 128,
                "problemTitle": "Longest Consecutive Sequence",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Longest Consecutive Sequence solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1284,
                "problemId": 128,
                "problemTitle": "Longest Consecutive Sequence",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Longest Consecutive Sequence solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1285,
                "problemId": 128,
                "problemTitle": "Longest Consecutive Sequence",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Longest Consecutive Sequence?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1286,
                "problemId": 128,
                "problemTitle": "Longest Consecutive Sequence",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Longest Consecutive Sequence in Python?",
                "back": "```python\ndef solve_128():\n    # Algorithm approach for Longest Consecutive Sequence\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1287,
                "problemId": 128,
                "problemTitle": "Longest Consecutive Sequence",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Longest Consecutive Sequence?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1288,
                "problemId": 128,
                "problemTitle": "Longest Consecutive Sequence",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Longest Consecutive Sequence",
                "back": "Input: Input for Longest Consecutive Sequence\nOutput: Expected output for Longest Consecutive Sequence\nExplanation: Explanation of how to solve Longest Consecutive Sequence",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1291,
                "problemId": 129,
                "problemTitle": "Sum Root to Leaf Numbers",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Sum Root to Leaf Numbers problem ask you to do?",
                "back": "Problem 129: Sum Root to Leaf Numbers - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1292,
                "problemId": 129,
                "problemTitle": "Sum Root to Leaf Numbers",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Sum Root to Leaf Numbers?",
                "back": "Algorithm: function solve129():\n    // Algorithm approach for Sum Root to Leaf Numbers\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // St...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1293,
                "problemId": 129,
                "problemTitle": "Sum Root to Leaf Numbers",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Sum Root to Leaf Numbers solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1294,
                "problemId": 129,
                "problemTitle": "Sum Root to Leaf Numbers",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Sum Root to Leaf Numbers solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1295,
                "problemId": 129,
                "problemTitle": "Sum Root to Leaf Numbers",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Sum Root to Leaf Numbers?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1296,
                "problemId": 129,
                "problemTitle": "Sum Root to Leaf Numbers",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Sum Root to Leaf Numbers in Python?",
                "back": "```python\ndef solve_129():\n    # Algorithm approach for Sum Root to Leaf Numbers\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1297,
                "problemId": 129,
                "problemTitle": "Sum Root to Leaf Numbers",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Sum Root to Leaf Numbers?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1298,
                "problemId": 129,
                "problemTitle": "Sum Root to Leaf Numbers",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Sum Root to Leaf Numbers",
                "back": "Input: Input for Sum Root to Leaf Numbers\nOutput: Expected output for Sum Root to Leaf Numbers\nExplanation: Explanation of how to solve Sum Root to Leaf Numbers",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1301,
                "problemId": 130,
                "problemTitle": "Surrounded Regions",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Surrounded Regions problem ask you to do?",
                "back": "Problem 130: Surrounded Regions - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1302,
                "problemId": 130,
                "problemTitle": "Surrounded Regions",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Surrounded Regions?",
                "back": "Algorithm: function solve130():\n    // Algorithm approach for Surrounded Regions\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1303,
                "problemId": 130,
                "problemTitle": "Surrounded Regions",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Surrounded Regions solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1304,
                "problemId": 130,
                "problemTitle": "Surrounded Regions",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Surrounded Regions solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1305,
                "problemId": 130,
                "problemTitle": "Surrounded Regions",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Surrounded Regions?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1306,
                "problemId": 130,
                "problemTitle": "Surrounded Regions",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Surrounded Regions in Python?",
                "back": "```python\ndef solve_130():\n    # Algorithm approach for Surrounded Regions\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1307,
                "problemId": 130,
                "problemTitle": "Surrounded Regions",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Surrounded Regions?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1308,
                "problemId": 130,
                "problemTitle": "Surrounded Regions",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Surrounded Regions",
                "back": "Input: Input for Surrounded Regions\nOutput: Expected output for Surrounded Regions\nExplanation: Explanation of how to solve Surrounded Regions",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1311,
                "problemId": 131,
                "problemTitle": "Palindrome Partitioning",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Palindrome Partitioning problem ask you to do?",
                "back": "Partition string into palindromic substrings using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1312,
                "problemId": 131,
                "problemTitle": "Palindrome Partitioning",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Palindrome Partitioning?",
                "back": "Backtracking with palindrome check\nUse DP for optimization",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1313,
                "problemId": 131,
                "problemTitle": "Palindrome Partitioning",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Palindrome Partitioning solution?",
                "back": "O(n \u00d7 2^n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1314,
                "problemId": 131,
                "problemTitle": "Palindrome Partitioning",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Palindrome Partitioning solution?",
                "back": "O(n\u00b2) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1315,
                "problemId": 131,
                "problemTitle": "Palindrome Partitioning",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Palindrome Partitioning?",
                "back": "Backtracking. Palindrome check. DP optimization",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1316,
                "problemId": 131,
                "problemTitle": "Palindrome Partitioning",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Palindrome Partitioning in Python?",
                "back": "```python\nBacktracking with DP\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1317,
                "problemId": 131,
                "problemTitle": "Palindrome Partitioning",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Palindrome Partitioning?",
                "back": "Tags: String, Dynamic Programming, Backtracking. This problem focuses on String algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1318,
                "problemId": 131,
                "problemTitle": "Palindrome Partitioning",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Palindrome Partitioning",
                "back": "Input: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nExplanation: All palindromic partitions.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1321,
                "problemId": 132,
                "problemTitle": "Palindrome Partitioning II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Palindrome Partitioning II problem ask you to do?",
                "back": "Find minimum cuts for palindrome partitioning using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1322,
                "problemId": 132,
                "problemTitle": "Palindrome Partitioning II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Palindrome Partitioning II?",
                "back": "DP for palindrome check\nDP for minimum cuts",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1323,
                "problemId": 132,
                "problemTitle": "Palindrome Partitioning II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Palindrome Partitioning II solution?",
                "back": "O(n\u00b2) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1324,
                "problemId": 132,
                "problemTitle": "Palindrome Partitioning II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Palindrome Partitioning II solution?",
                "back": "O(n\u00b2) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1325,
                "problemId": 132,
                "problemTitle": "Palindrome Partitioning II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Palindrome Partitioning II?",
                "back": "Palindrome DP. Minimum cuts. Double DP",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1326,
                "problemId": 132,
                "problemTitle": "Palindrome Partitioning II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Palindrome Partitioning II in Python?",
                "back": "```python\nDouble DP approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1327,
                "problemId": 132,
                "problemTitle": "Palindrome Partitioning II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Palindrome Partitioning II?",
                "back": "Tags: String, Dynamic Programming. This problem focuses on String algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1328,
                "problemId": 132,
                "problemTitle": "Palindrome Partitioning II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Palindrome Partitioning II",
                "back": "Input: s = \"aab\"\nOutput: 1\nExplanation: Cut after 'aa' to get palindromes.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1331,
                "problemId": 133,
                "problemTitle": "Clone Graph",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Clone Graph problem ask you to do?",
                "back": "Problem 133: Clone Graph - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1332,
                "problemId": 133,
                "problemTitle": "Clone Graph",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Clone Graph?",
                "back": "Algorithm: function solve133():\n    // Algorithm approach for Clone Graph\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initial...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1333,
                "problemId": 133,
                "problemTitle": "Clone Graph",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Clone Graph solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1334,
                "problemId": 133,
                "problemTitle": "Clone Graph",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Clone Graph solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1335,
                "problemId": 133,
                "problemTitle": "Clone Graph",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Clone Graph?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1336,
                "problemId": 133,
                "problemTitle": "Clone Graph",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Clone Graph in Python?",
                "back": "```python\ndef solve_133():\n    # Algorithm approach for Clone Graph\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1337,
                "problemId": 133,
                "problemTitle": "Clone Graph",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Clone Graph?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1338,
                "problemId": 133,
                "problemTitle": "Clone Graph",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Clone Graph",
                "back": "Input: Input for Clone Graph\nOutput: Expected output for Clone Graph\nExplanation: Explanation of how to solve Clone Graph",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1341,
                "problemId": 134,
                "problemTitle": "Gas Station",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Gas Station problem ask you to do?",
                "back": "Problem 134: Gas Station - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1342,
                "problemId": 134,
                "problemTitle": "Gas Station",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Gas Station?",
                "back": "Algorithm: function solve134():\n    // Algorithm approach for Gas Station\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initial...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1343,
                "problemId": 134,
                "problemTitle": "Gas Station",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Gas Station solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1344,
                "problemId": 134,
                "problemTitle": "Gas Station",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Gas Station solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1345,
                "problemId": 134,
                "problemTitle": "Gas Station",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Gas Station?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1346,
                "problemId": 134,
                "problemTitle": "Gas Station",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Gas Station in Python?",
                "back": "```python\ndef solve_134():\n    # Algorithm approach for Gas Station\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1347,
                "problemId": 134,
                "problemTitle": "Gas Station",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Gas Station?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1348,
                "problemId": 134,
                "problemTitle": "Gas Station",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Gas Station",
                "back": "Input: Input for Gas Station\nOutput: Expected output for Gas Station\nExplanation: Explanation of how to solve Gas Station",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1351,
                "problemId": 135,
                "problemTitle": "Candy",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Candy problem ask you to do?",
                "back": "Problem 135: Candy - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1352,
                "problemId": 135,
                "problemTitle": "Candy",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Candy?",
                "back": "Algorithm: function solve135():\n    // Algorithm approach for Candy\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initialize va...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1353,
                "problemId": 135,
                "problemTitle": "Candy",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Candy solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1354,
                "problemId": 135,
                "problemTitle": "Candy",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Candy solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1355,
                "problemId": 135,
                "problemTitle": "Candy",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Candy?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1356,
                "problemId": 135,
                "problemTitle": "Candy",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Candy in Python?",
                "back": "```python\ndef solve_135():\n    # Algorithm approach for Candy\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1357,
                "problemId": 135,
                "problemTitle": "Candy",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Candy?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1358,
                "problemId": 135,
                "problemTitle": "Candy",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Candy",
                "back": "Input: Input for Candy\nOutput: Expected output for Candy\nExplanation: Explanation of how to solve Candy",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1361,
                "problemId": 136,
                "problemTitle": "Single Number",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Single Number problem ask you to do?",
                "back": "Problem 136: Single Number - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1362,
                "problemId": 136,
                "problemTitle": "Single Number",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Single Number?",
                "back": "Algorithm: function solve136():\n    // Algorithm approach for Single Number\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initi...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1363,
                "problemId": 136,
                "problemTitle": "Single Number",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Single Number solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1364,
                "problemId": 136,
                "problemTitle": "Single Number",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Single Number solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1365,
                "problemId": 136,
                "problemTitle": "Single Number",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Single Number?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1366,
                "problemId": 136,
                "problemTitle": "Single Number",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Single Number in Python?",
                "back": "```python\ndef solve_136():\n    # Algorithm approach for Single Number\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1367,
                "problemId": 136,
                "problemTitle": "Single Number",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Single Number?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1368,
                "problemId": 136,
                "problemTitle": "Single Number",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Single Number",
                "back": "Input: Input for Single Number\nOutput: Expected output for Single Number\nExplanation: Explanation of how to solve Single Number",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1371,
                "problemId": 137,
                "problemTitle": "Single Number II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Single Number II problem ask you to do?",
                "back": "Problem 137: Single Number II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1372,
                "problemId": 137,
                "problemTitle": "Single Number II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Single Number II?",
                "back": "Algorithm: function solve137():\n    // Algorithm approach for Single Number II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: In...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1373,
                "problemId": 137,
                "problemTitle": "Single Number II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Single Number II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1374,
                "problemId": 137,
                "problemTitle": "Single Number II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Single Number II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1375,
                "problemId": 137,
                "problemTitle": "Single Number II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Single Number II?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1376,
                "problemId": 137,
                "problemTitle": "Single Number II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Single Number II in Python?",
                "back": "```python\ndef solve_137():\n    # Algorithm approach for Single Number II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1377,
                "problemId": 137,
                "problemTitle": "Single Number II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Single Number II?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1378,
                "problemId": 137,
                "problemTitle": "Single Number II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Single Number II",
                "back": "Input: Input for Single Number II\nOutput: Expected output for Single Number II\nExplanation: Explanation of how to solve Single Number II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1381,
                "problemId": 138,
                "problemTitle": "Copy List with Random Pointer",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Copy List with Random Pointer problem ask you to do?",
                "back": "Problem 138: Copy List with Random Pointer - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1382,
                "problemId": 138,
                "problemTitle": "Copy List with Random Pointer",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Copy List with Random Pointer?",
                "back": "Algorithm: function solve138():\n    // Linked list traversal approach\n    if head == null:\n        return null\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.ne...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1383,
                "problemId": 138,
                "problemTitle": "Copy List with Random Pointer",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Copy List with Random Pointer solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1384,
                "problemId": 138,
                "problemTitle": "Copy List with Random Pointer",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Copy List with Random Pointer solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1385,
                "problemId": 138,
                "problemTitle": "Copy List with Random Pointer",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Copy List with Random Pointer?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1386,
                "problemId": 138,
                "problemTitle": "Copy List with Random Pointer",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Copy List with Random Pointer in Python?",
                "back": "```python\ndef solve_138():\n    # Linked list traversal approach\n    if not head:\n        return None\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Your logic here\n        current = current.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1387,
                "problemId": 138,
                "problemTitle": "Copy List with Random Pointer",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Copy List with Random Pointer?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1388,
                "problemId": 138,
                "problemTitle": "Copy List with Random Pointer",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Copy List with Random Pointer",
                "back": "Input: Input for Copy List with Random Pointer\nOutput: Expected output for Copy List with Random Pointer\nExplanation: Explanation of how to solve Copy List with Random Pointer",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1391,
                "problemId": 139,
                "problemTitle": "Word Break",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Word Break problem ask you to do?",
                "back": "Check if string can be segmented using dictionary words via dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1392,
                "problemId": 139,
                "problemTitle": "Word Break",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Word Break?",
                "back": "DP array for segmentation\nCheck all possible splits",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1393,
                "problemId": 139,
                "problemTitle": "Word Break",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Word Break solution?",
                "back": "O(n\u00b3) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1394,
                "problemId": 139,
                "problemTitle": "Word Break",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Word Break solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1395,
                "problemId": 139,
                "problemTitle": "Word Break",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Word Break?",
                "back": "DP array. Check splits. Word matching",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1396,
                "problemId": 139,
                "problemTitle": "Word Break",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Word Break in Python?",
                "back": "```python\nDP approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1397,
                "problemId": 139,
                "problemTitle": "Word Break",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Word Break?",
                "back": "Tags: Hash Table, String, Dynamic Programming. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1398,
                "problemId": 139,
                "problemTitle": "Word Break",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Word Break",
                "back": "Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\nExplanation: String can be segmented.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1401,
                "problemId": 140,
                "problemTitle": "Word Break II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Word Break II problem ask you to do?",
                "back": "Return all possible word break combinations using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1402,
                "problemId": 140,
                "problemTitle": "Word Break II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Word Break II?",
                "back": "DP with backtracking\nStore all valid combinations",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1403,
                "problemId": 140,
                "problemTitle": "Word Break II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Word Break II solution?",
                "back": "O(n\u00b3) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1404,
                "problemId": 140,
                "problemTitle": "Word Break II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Word Break II solution?",
                "back": "O(n\u00b3) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1405,
                "problemId": 140,
                "problemTitle": "Word Break II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Word Break II?",
                "back": "DP approach. Backtracking. Store combinations",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1406,
                "problemId": 140,
                "problemTitle": "Word Break II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Word Break II in Python?",
                "back": "```python\nDP with backtracking\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1407,
                "problemId": 140,
                "problemTitle": "Word Break II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Word Break II?",
                "back": "Tags: Hash Table, String, Dynamic Programming, Backtracking. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1408,
                "problemId": 140,
                "problemTitle": "Word Break II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Word Break II",
                "back": "Input: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\nOutput: [\"cats and dog\",\"cat sand dog\"]\nExplanation: All possible combinations.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1411,
                "problemId": 141,
                "problemTitle": "Linked List Cycle",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Linked List Cycle problem ask you to do?",
                "back": "Problem 141: Linked List Cycle - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1412,
                "problemId": 141,
                "problemTitle": "Linked List Cycle",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Linked List Cycle?",
                "back": "Algorithm: function solve141():\n    // Linked list traversal approach\n    if head == null:\n        return null\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.ne...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1413,
                "problemId": 141,
                "problemTitle": "Linked List Cycle",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Linked List Cycle solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1414,
                "problemId": 141,
                "problemTitle": "Linked List Cycle",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Linked List Cycle solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1415,
                "problemId": 141,
                "problemTitle": "Linked List Cycle",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Linked List Cycle?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1416,
                "problemId": 141,
                "problemTitle": "Linked List Cycle",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Linked List Cycle in Python?",
                "back": "```python\ndef solve_141():\n    # Linked list traversal approach\n    if not head:\n        return None\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Your logic here\n        current = current.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1417,
                "problemId": 141,
                "problemTitle": "Linked List Cycle",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Linked List Cycle?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1418,
                "problemId": 141,
                "problemTitle": "Linked List Cycle",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Linked List Cycle",
                "back": "Input: Input for Linked List Cycle\nOutput: Expected output for Linked List Cycle\nExplanation: Explanation of how to solve Linked List Cycle",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1421,
                "problemId": 142,
                "problemTitle": "Linked List Cycle II",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Linked List Cycle II problem ask you to do?",
                "back": "Problem 142: Linked List Cycle II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1422,
                "problemId": 142,
                "problemTitle": "Linked List Cycle II",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Linked List Cycle II?",
                "back": "Algorithm: function solve142():\n    // Linked list traversal approach\n    if head == null:\n        return null\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.ne...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1423,
                "problemId": 142,
                "problemTitle": "Linked List Cycle II",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Linked List Cycle II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1424,
                "problemId": 142,
                "problemTitle": "Linked List Cycle II",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Linked List Cycle II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1425,
                "problemId": 142,
                "problemTitle": "Linked List Cycle II",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Linked List Cycle II?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1426,
                "problemId": 142,
                "problemTitle": "Linked List Cycle II",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Linked List Cycle II in Python?",
                "back": "```python\ndef solve_142():\n    # Linked list traversal approach\n    if not head:\n        return None\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Your logic here\n        current = current.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1427,
                "problemId": 142,
                "problemTitle": "Linked List Cycle II",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Linked List Cycle II?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1428,
                "problemId": 142,
                "problemTitle": "Linked List Cycle II",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Linked List Cycle II",
                "back": "Input: Input for Linked List Cycle II\nOutput: Expected output for Linked List Cycle II\nExplanation: Explanation of how to solve Linked List Cycle II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1431,
                "problemId": 143,
                "problemTitle": "Reorder List",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Reorder List problem ask you to do?",
                "back": "Problem 143: Reorder List - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1432,
                "problemId": 143,
                "problemTitle": "Reorder List",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Reorder List?",
                "back": "Algorithm: function solve143():\n    // Linked list traversal approach\n    if head == null:\n        return null\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.ne...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1433,
                "problemId": 143,
                "problemTitle": "Reorder List",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Reorder List solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1434,
                "problemId": 143,
                "problemTitle": "Reorder List",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Reorder List solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1435,
                "problemId": 143,
                "problemTitle": "Reorder List",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Reorder List?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1436,
                "problemId": 143,
                "problemTitle": "Reorder List",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Reorder List in Python?",
                "back": "```python\ndef solve_143():\n    # Linked list traversal approach\n    if not head:\n        return None\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Your logic here\n        current = current.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1437,
                "problemId": 143,
                "problemTitle": "Reorder List",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Reorder List?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1438,
                "problemId": 143,
                "problemTitle": "Reorder List",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Reorder List",
                "back": "Input: Input for Reorder List\nOutput: Expected output for Reorder List\nExplanation: Explanation of how to solve Reorder List",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1441,
                "problemId": 144,
                "problemTitle": "Binary Tree Preorder Traversal",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Binary Tree Preorder Traversal problem ask you to do?",
                "back": "Problem 144: Binary Tree Preorder Traversal - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1442,
                "problemId": 144,
                "problemTitle": "Binary Tree Preorder Traversal",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Tree Preorder Traversal?",
                "back": "Algorithm: function solve144():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1443,
                "problemId": 144,
                "problemTitle": "Binary Tree Preorder Traversal",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Tree Preorder Traversal solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1444,
                "problemId": 144,
                "problemTitle": "Binary Tree Preorder Traversal",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Tree Preorder Traversal solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1445,
                "problemId": 144,
                "problemTitle": "Binary Tree Preorder Traversal",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Tree Preorder Traversal?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1446,
                "problemId": 144,
                "problemTitle": "Binary Tree Preorder Traversal",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Binary Tree Preorder Traversal in Python?",
                "back": "```python\ndef solve_144():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1447,
                "problemId": 144,
                "problemTitle": "Binary Tree Preorder Traversal",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Tree Preorder Traversal?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1448,
                "problemId": 144,
                "problemTitle": "Binary Tree Preorder Traversal",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Tree Preorder Traversal",
                "back": "Input: Input for Binary Tree Preorder Traversal\nOutput: Expected output for Binary Tree Preorder Traversal\nExplanation: Explanation of how to solve Binary Tree Preorder Traversal",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1451,
                "problemId": 145,
                "problemTitle": "Binary Tree Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Binary Tree Postorder Traversal problem ask you to do?",
                "back": "Problem 145: Binary Tree Postorder Traversal - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1452,
                "problemId": 145,
                "problemTitle": "Binary Tree Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Tree Postorder Traversal?",
                "back": "Algorithm: function solve145():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1453,
                "problemId": 145,
                "problemTitle": "Binary Tree Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Tree Postorder Traversal solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1454,
                "problemId": 145,
                "problemTitle": "Binary Tree Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Tree Postorder Traversal solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1455,
                "problemId": 145,
                "problemTitle": "Binary Tree Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Tree Postorder Traversal?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1456,
                "problemId": 145,
                "problemTitle": "Binary Tree Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Binary Tree Postorder Traversal in Python?",
                "back": "```python\ndef solve_145():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1457,
                "problemId": 145,
                "problemTitle": "Binary Tree Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Tree Postorder Traversal?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1458,
                "problemId": 145,
                "problemTitle": "Binary Tree Postorder Traversal",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Tree Postorder Traversal",
                "back": "Input: Input for Binary Tree Postorder Traversal\nOutput: Expected output for Binary Tree Postorder Traversal\nExplanation: Explanation of how to solve Binary Tree Postorder Traversal",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1461,
                "problemId": 146,
                "problemTitle": "LRU Cache",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the LRU Cache problem ask you to do?",
                "back": "Problem 146: LRU Cache - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1462,
                "problemId": 146,
                "problemTitle": "LRU Cache",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve LRU Cache?",
                "back": "Algorithm: function solve146():\n    // Algorithm approach for LRU Cache\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initializ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1463,
                "problemId": 146,
                "problemTitle": "LRU Cache",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal LRU Cache solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1464,
                "problemId": 146,
                "problemTitle": "LRU Cache",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal LRU Cache solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1465,
                "problemId": 146,
                "problemTitle": "LRU Cache",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving LRU Cache?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1466,
                "problemId": 146,
                "problemTitle": "LRU Cache",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement LRU Cache in Python?",
                "back": "```python\ndef solve_146():\n    # Algorithm approach for LRU Cache\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1467,
                "problemId": 146,
                "problemTitle": "LRU Cache",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for LRU Cache?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1468,
                "problemId": 146,
                "problemTitle": "LRU Cache",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for LRU Cache",
                "back": "Input: Input for LRU Cache\nOutput: Expected output for LRU Cache\nExplanation: Explanation of how to solve LRU Cache",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1471,
                "problemId": 147,
                "problemTitle": "Insertion Sort List",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Insertion Sort List problem ask you to do?",
                "back": "Problem 147: Insertion Sort List - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1472,
                "problemId": 147,
                "problemTitle": "Insertion Sort List",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Insertion Sort List?",
                "back": "Algorithm: function solve147():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1473,
                "problemId": 147,
                "problemTitle": "Insertion Sort List",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Insertion Sort List solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1474,
                "problemId": 147,
                "problemTitle": "Insertion Sort List",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Insertion Sort List solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1475,
                "problemId": 147,
                "problemTitle": "Insertion Sort List",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Insertion Sort List?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1476,
                "problemId": 147,
                "problemTitle": "Insertion Sort List",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Insertion Sort List in Python?",
                "back": "```python\ndef solve_147():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1477,
                "problemId": 147,
                "problemTitle": "Insertion Sort List",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Insertion Sort List?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1478,
                "problemId": 147,
                "problemTitle": "Insertion Sort List",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Insertion Sort List",
                "back": "Input: Input for Insertion Sort List\nOutput: Expected output for Insertion Sort List\nExplanation: Explanation of how to solve Insertion Sort List",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1481,
                "problemId": 148,
                "problemTitle": "Sort List",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Sort List problem ask you to do?",
                "back": "Problem 148: Sort List - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1482,
                "problemId": 148,
                "problemTitle": "Sort List",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Sort List?",
                "back": "Algorithm: function solve148():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1483,
                "problemId": 148,
                "problemTitle": "Sort List",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Sort List solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1484,
                "problemId": 148,
                "problemTitle": "Sort List",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Sort List solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1485,
                "problemId": 148,
                "problemTitle": "Sort List",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Sort List?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1486,
                "problemId": 148,
                "problemTitle": "Sort List",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Sort List in Python?",
                "back": "```python\ndef solve_148():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1487,
                "problemId": 148,
                "problemTitle": "Sort List",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Sort List?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1488,
                "problemId": 148,
                "problemTitle": "Sort List",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Sort List",
                "back": "Input: Input for Sort List\nOutput: Expected output for Sort List\nExplanation: Explanation of how to solve Sort List",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1491,
                "problemId": 149,
                "problemTitle": "Max Points on a Line",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Max Points on a Line problem ask you to do?",
                "back": "Problem 149: Max Points on a Line - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1492,
                "problemId": 149,
                "problemTitle": "Max Points on a Line",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Max Points on a Line?",
                "back": "Algorithm: function solve149():\n    // Algorithm approach for Max Points on a Line\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1493,
                "problemId": 149,
                "problemTitle": "Max Points on a Line",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Max Points on a Line solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1494,
                "problemId": 149,
                "problemTitle": "Max Points on a Line",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Max Points on a Line solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1495,
                "problemId": 149,
                "problemTitle": "Max Points on a Line",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Max Points on a Line?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1496,
                "problemId": 149,
                "problemTitle": "Max Points on a Line",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Max Points on a Line in Python?",
                "back": "```python\ndef solve_149():\n    # Algorithm approach for Max Points on a Line\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1497,
                "problemId": 149,
                "problemTitle": "Max Points on a Line",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Max Points on a Line?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1498,
                "problemId": 149,
                "problemTitle": "Max Points on a Line",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Max Points on a Line",
                "back": "Input: Input for Max Points on a Line\nOutput: Expected output for Max Points on a Line\nExplanation: Explanation of how to solve Max Points on a Line",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1501,
                "problemId": 150,
                "problemTitle": "Evaluate Reverse Polish Notation",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Evaluate Reverse Polish Notation problem ask you to do?",
                "back": "Problem 150: Evaluate Reverse Polish Notation - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1502,
                "problemId": 150,
                "problemTitle": "Evaluate Reverse Polish Notation",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Evaluate Reverse Polish Notation?",
                "back": "Algorithm: function solve150():\n    // Algorithm approach for Evaluate Reverse Polish Notation\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1503,
                "problemId": 150,
                "problemTitle": "Evaluate Reverse Polish Notation",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Evaluate Reverse Polish Notation solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1504,
                "problemId": 150,
                "problemTitle": "Evaluate Reverse Polish Notation",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Evaluate Reverse Polish Notation solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1505,
                "problemId": 150,
                "problemTitle": "Evaluate Reverse Polish Notation",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Evaluate Reverse Polish Notation?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1506,
                "problemId": 150,
                "problemTitle": "Evaluate Reverse Polish Notation",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Evaluate Reverse Polish Notation in Python?",
                "back": "```python\ndef solve_150():\n    # Algorithm approach for Evaluate Reverse Polish Notation\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1507,
                "problemId": 150,
                "problemTitle": "Evaluate Reverse Polish Notation",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Evaluate Reverse Polish Notation?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1508,
                "problemId": 150,
                "problemTitle": "Evaluate Reverse Polish Notation",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Evaluate Reverse Polish Notation",
                "back": "Input: Input for Evaluate Reverse Polish Notation\nOutput: Expected output for Evaluate Reverse Polish Notation\nExplanation: Explanation of how to solve Evaluate Reverse Polish Notation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1511,
                "problemId": 151,
                "problemTitle": "Reverse Words in a String",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Reverse Words in a String problem ask you to do?",
                "back": "Problem 151: Reverse Words in a String - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1512,
                "problemId": 151,
                "problemTitle": "Reverse Words in a String",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Reverse Words in a String?",
                "back": "Algorithm: function solve151():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1513,
                "problemId": 151,
                "problemTitle": "Reverse Words in a String",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Reverse Words in a String solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1514,
                "problemId": 151,
                "problemTitle": "Reverse Words in a String",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Reverse Words in a String solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1515,
                "problemId": 151,
                "problemTitle": "Reverse Words in a String",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Reverse Words in a String?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1516,
                "problemId": 151,
                "problemTitle": "Reverse Words in a String",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Reverse Words in a String in Python?",
                "back": "```python\ndef solve_151():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1517,
                "problemId": 151,
                "problemTitle": "Reverse Words in a String",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Reverse Words in a String?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1518,
                "problemId": 151,
                "problemTitle": "Reverse Words in a String",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Reverse Words in a String",
                "back": "Input: Input for Reverse Words in a String\nOutput: Expected output for Reverse Words in a String\nExplanation: Explanation of how to solve Reverse Words in a String",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1521,
                "problemId": 152,
                "problemTitle": "Maximum Product Subarray",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Maximum Product Subarray problem ask you to do?",
                "back": "Find maximum product subarray using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1522,
                "problemId": 152,
                "problemTitle": "Maximum Product Subarray",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Maximum Product Subarray?",
                "back": "Track min and max products\nHandle negative numbers",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1523,
                "problemId": 152,
                "problemTitle": "Maximum Product Subarray",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Maximum Product Subarray solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1524,
                "problemId": 152,
                "problemTitle": "Maximum Product Subarray",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Maximum Product Subarray solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1525,
                "problemId": 152,
                "problemTitle": "Maximum Product Subarray",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Maximum Product Subarray?",
                "back": "Track min/max. Handle negatives. DP approach",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1526,
                "problemId": 152,
                "problemTitle": "Maximum Product Subarray",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Maximum Product Subarray in Python?",
                "back": "```python\nDP with min/max tracking\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1527,
                "problemId": 152,
                "problemTitle": "Maximum Product Subarray",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Maximum Product Subarray?",
                "back": "Tags: Array, Dynamic Programming. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1528,
                "problemId": 152,
                "problemTitle": "Maximum Product Subarray",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Maximum Product Subarray",
                "back": "Input: nums = [2,3,-2,4]\nOutput: 6\nExplanation: Subarray [2,3] has maximum product 6.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1531,
                "problemId": 153,
                "problemTitle": "Find Minimum in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Find Minimum in Rotated Sorted Array problem ask you to do?",
                "back": "Problem 153: Find Minimum in Rotated Sorted Array - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1532,
                "problemId": 153,
                "problemTitle": "Find Minimum in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Find Minimum in Rotated Sorted Array?",
                "back": "Algorithm: function solve153():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1533,
                "problemId": 153,
                "problemTitle": "Find Minimum in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Find Minimum in Rotated Sorted Array solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1534,
                "problemId": 153,
                "problemTitle": "Find Minimum in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Find Minimum in Rotated Sorted Array solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1535,
                "problemId": 153,
                "problemTitle": "Find Minimum in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Find Minimum in Rotated Sorted Array?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1536,
                "problemId": 153,
                "problemTitle": "Find Minimum in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Find Minimum in Rotated Sorted Array in Python?",
                "back": "```python\ndef solve_153():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1537,
                "problemId": 153,
                "problemTitle": "Find Minimum in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Find Minimum in Rotated Sorted Array?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1538,
                "problemId": 153,
                "problemTitle": "Find Minimum in Rotated Sorted Array",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Find Minimum in Rotated Sorted Array",
                "back": "Input: Input for Find Minimum in Rotated Sorted Array\nOutput: Expected output for Find Minimum in Rotated Sorted Array\nExplanation: Explanation of how to solve Find Minimum in Rotated Sorted Array",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1541,
                "problemId": 154,
                "problemTitle": "Find Minimum in Rotated Sorted Array II",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Find Minimum in Rotated Sorted Array II problem ask you to do?",
                "back": "Problem 154: Find Minimum in Rotated Sorted Array II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1542,
                "problemId": 154,
                "problemTitle": "Find Minimum in Rotated Sorted Array II",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Find Minimum in Rotated Sorted Array II?",
                "back": "Algorithm: function solve154():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1543,
                "problemId": 154,
                "problemTitle": "Find Minimum in Rotated Sorted Array II",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Find Minimum in Rotated Sorted Array II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1544,
                "problemId": 154,
                "problemTitle": "Find Minimum in Rotated Sorted Array II",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Find Minimum in Rotated Sorted Array II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1545,
                "problemId": 154,
                "problemTitle": "Find Minimum in Rotated Sorted Array II",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Find Minimum in Rotated Sorted Array II?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1546,
                "problemId": 154,
                "problemTitle": "Find Minimum in Rotated Sorted Array II",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Find Minimum in Rotated Sorted Array II in Python?",
                "back": "```python\ndef solve_154():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1547,
                "problemId": 154,
                "problemTitle": "Find Minimum in Rotated Sorted Array II",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Find Minimum in Rotated Sorted Array II?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1548,
                "problemId": 154,
                "problemTitle": "Find Minimum in Rotated Sorted Array II",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Find Minimum in Rotated Sorted Array II",
                "back": "Input: Input for Find Minimum in Rotated Sorted Array II\nOutput: Expected output for Find Minimum in Rotated Sorted Array II\nExplanation: Explanation of how to solve Find Minimum in Rotated Sorted Array II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1551,
                "problemId": 155,
                "problemTitle": "Min Stack",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Min Stack problem ask you to do?",
                "back": "Problem 155: Min Stack - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1552,
                "problemId": 155,
                "problemTitle": "Min Stack",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Min Stack?",
                "back": "Algorithm: function solve155():\n    // Algorithm approach for Min Stack\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initializ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1553,
                "problemId": 155,
                "problemTitle": "Min Stack",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Min Stack solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1554,
                "problemId": 155,
                "problemTitle": "Min Stack",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Min Stack solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1555,
                "problemId": 155,
                "problemTitle": "Min Stack",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Min Stack?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1556,
                "problemId": 155,
                "problemTitle": "Min Stack",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Min Stack in Python?",
                "back": "```python\ndef solve_155():\n    # Algorithm approach for Min Stack\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1557,
                "problemId": 155,
                "problemTitle": "Min Stack",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Min Stack?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1558,
                "problemId": 155,
                "problemTitle": "Min Stack",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Min Stack",
                "back": "Input: Input for Min Stack\nOutput: Expected output for Min Stack\nExplanation: Explanation of how to solve Min Stack",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1561,
                "problemId": 156,
                "problemTitle": "Binary Tree Upside Down",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Binary Tree Upside Down problem ask you to do?",
                "back": "Problem 156: Binary Tree Upside Down - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1562,
                "problemId": 156,
                "problemTitle": "Binary Tree Upside Down",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Tree Upside Down?",
                "back": "Algorithm: function solve156():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1563,
                "problemId": 156,
                "problemTitle": "Binary Tree Upside Down",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Tree Upside Down solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1564,
                "problemId": 156,
                "problemTitle": "Binary Tree Upside Down",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Tree Upside Down solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1565,
                "problemId": 156,
                "problemTitle": "Binary Tree Upside Down",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Tree Upside Down?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1566,
                "problemId": 156,
                "problemTitle": "Binary Tree Upside Down",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Binary Tree Upside Down in Python?",
                "back": "```python\ndef solve_156():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1567,
                "problemId": 156,
                "problemTitle": "Binary Tree Upside Down",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Tree Upside Down?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1568,
                "problemId": 156,
                "problemTitle": "Binary Tree Upside Down",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Tree Upside Down",
                "back": "Input: Input for Binary Tree Upside Down\nOutput: Expected output for Binary Tree Upside Down\nExplanation: Explanation of how to solve Binary Tree Upside Down",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1571,
                "problemId": 157,
                "problemTitle": "Read N Characters Given Read4",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Read N Characters Given Read4 problem ask you to do?",
                "back": "Problem 157: Read N Characters Given Read4 - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1572,
                "problemId": 157,
                "problemTitle": "Read N Characters Given Read4",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Read N Characters Given Read4?",
                "back": "Algorithm: function solve157():\n    // Algorithm approach for Read N Characters Given Read4\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1573,
                "problemId": 157,
                "problemTitle": "Read N Characters Given Read4",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Read N Characters Given Read4 solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1574,
                "problemId": 157,
                "problemTitle": "Read N Characters Given Read4",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Read N Characters Given Read4 solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1575,
                "problemId": 157,
                "problemTitle": "Read N Characters Given Read4",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Read N Characters Given Read4?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1576,
                "problemId": 157,
                "problemTitle": "Read N Characters Given Read4",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Read N Characters Given Read4 in Python?",
                "back": "```python\ndef solve_157():\n    # Algorithm approach for Read N Characters Given Read4\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1577,
                "problemId": 157,
                "problemTitle": "Read N Characters Given Read4",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Read N Characters Given Read4?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1578,
                "problemId": 157,
                "problemTitle": "Read N Characters Given Read4",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Read N Characters Given Read4",
                "back": "Input: Input for Read N Characters Given Read4\nOutput: Expected output for Read N Characters Given Read4\nExplanation: Explanation of how to solve Read N Characters Given Read4",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1581,
                "problemId": 158,
                "problemTitle": "Read N Characters Given Read4 II - Call multiple times",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Read N Characters Given Read4 II - Call multiple times problem ask you to do?",
                "back": "Problem 158: Read N Characters Given Read4 II - Call multiple times - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1582,
                "problemId": 158,
                "problemTitle": "Read N Characters Given Read4 II - Call multiple times",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Read N Characters Given Read4 II - Call multiple times?",
                "back": "Algorithm: function solve158():\n    // Algorithm approach for Read N Characters Given Read4 II - Call multiple times\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        retur...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1583,
                "problemId": 158,
                "problemTitle": "Read N Characters Given Read4 II - Call multiple times",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Read N Characters Given Read4 II - Call multiple times solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1584,
                "problemId": 158,
                "problemTitle": "Read N Characters Given Read4 II - Call multiple times",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Read N Characters Given Read4 II - Call multiple times solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1585,
                "problemId": 158,
                "problemTitle": "Read N Characters Given Read4 II - Call multiple times",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Read N Characters Given Read4 II - Call multiple times?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1586,
                "problemId": 158,
                "problemTitle": "Read N Characters Given Read4 II - Call multiple times",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Read N Characters Given Read4 II - Call multiple times in Python?",
                "back": "```python\ndef solve_158():\n    # Algorithm approach for Read N Characters Given Read4 II - Call multiple times\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1587,
                "problemId": 158,
                "problemTitle": "Read N Characters Given Read4 II - Call multiple times",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Read N Characters Given Read4 II - Call multiple times?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1588,
                "problemId": 158,
                "problemTitle": "Read N Characters Given Read4 II - Call multiple times",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Read N Characters Given Read4 II - Call multiple times",
                "back": "Input: Input for Read N Characters Given Read4 II - Call multiple times\nOutput: Expected output for Read N Characters Given Read4 II - Call multiple times\nExplanation: Explanation of how to solve Read N Characters Given Read4 II - Call multiple times",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1591,
                "problemId": 159,
                "problemTitle": "Longest Substring with At Most Two Distinct Characters",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Longest Substring with At Most Two Distinct Characters problem ask you to do?",
                "back": "Problem 159: Longest Substring with At Most Two Distinct Characters - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1592,
                "problemId": 159,
                "problemTitle": "Longest Substring with At Most Two Distinct Characters",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Longest Substring with At Most Two Distinct Characters?",
                "back": "Algorithm: function solve159():\n    // Algorithm approach for Longest Substring with At Most Two Distinct Characters\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        retur...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1593,
                "problemId": 159,
                "problemTitle": "Longest Substring with At Most Two Distinct Characters",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Longest Substring with At Most Two Distinct Characters solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1594,
                "problemId": 159,
                "problemTitle": "Longest Substring with At Most Two Distinct Characters",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Longest Substring with At Most Two Distinct Characters solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1595,
                "problemId": 159,
                "problemTitle": "Longest Substring with At Most Two Distinct Characters",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Longest Substring with At Most Two Distinct Characters?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1596,
                "problemId": 159,
                "problemTitle": "Longest Substring with At Most Two Distinct Characters",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Longest Substring with At Most Two Distinct Characters in Python?",
                "back": "```python\ndef solve_159():\n    # Algorithm approach for Longest Substring with At Most Two Distinct Characters\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1597,
                "problemId": 159,
                "problemTitle": "Longest Substring with At Most Two Distinct Characters",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Longest Substring with At Most Two Distinct Characters?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1598,
                "problemId": 159,
                "problemTitle": "Longest Substring with At Most Two Distinct Characters",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Longest Substring with At Most Two Distinct Characters",
                "back": "Input: Input for Longest Substring with At Most Two Distinct Characters\nOutput: Expected output for Longest Substring with At Most Two Distinct Characters\nExplanation: Explanation of how to solve Longest Substring with At Most Two Distinct Characters",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1601,
                "problemId": 160,
                "problemTitle": "Intersection of Two Linked Lists",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Intersection of Two Linked Lists problem ask you to do?",
                "back": "Problem 160: Intersection of Two Linked Lists - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1602,
                "problemId": 160,
                "problemTitle": "Intersection of Two Linked Lists",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Intersection of Two Linked Lists?",
                "back": "Algorithm: function solve160():\n    // Linked list traversal approach\n    if head == null:\n        return null\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.ne...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1603,
                "problemId": 160,
                "problemTitle": "Intersection of Two Linked Lists",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Intersection of Two Linked Lists solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1604,
                "problemId": 160,
                "problemTitle": "Intersection of Two Linked Lists",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Intersection of Two Linked Lists solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1605,
                "problemId": 160,
                "problemTitle": "Intersection of Two Linked Lists",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Intersection of Two Linked Lists?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1606,
                "problemId": 160,
                "problemTitle": "Intersection of Two Linked Lists",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Intersection of Two Linked Lists in Python?",
                "back": "```python\ndef solve_160():\n    # Linked list traversal approach\n    if not head:\n        return None\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Your logic here\n        current = current.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1607,
                "problemId": 160,
                "problemTitle": "Intersection of Two Linked Lists",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Intersection of Two Linked Lists?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1608,
                "problemId": 160,
                "problemTitle": "Intersection of Two Linked Lists",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Intersection of Two Linked Lists",
                "back": "Input: Input for Intersection of Two Linked Lists\nOutput: Expected output for Intersection of Two Linked Lists\nExplanation: Explanation of how to solve Intersection of Two Linked Lists",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1611,
                "problemId": 161,
                "problemTitle": "One Edit Distance",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the One Edit Distance problem ask you to do?",
                "back": "Problem 161: One Edit Distance - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1612,
                "problemId": 161,
                "problemTitle": "One Edit Distance",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve One Edit Distance?",
                "back": "Algorithm: function solve161():\n    // Algorithm approach for One Edit Distance\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: I...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1613,
                "problemId": 161,
                "problemTitle": "One Edit Distance",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal One Edit Distance solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1614,
                "problemId": 161,
                "problemTitle": "One Edit Distance",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal One Edit Distance solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1615,
                "problemId": 161,
                "problemTitle": "One Edit Distance",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving One Edit Distance?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1616,
                "problemId": 161,
                "problemTitle": "One Edit Distance",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement One Edit Distance in Python?",
                "back": "```python\ndef solve_161():\n    # Algorithm approach for One Edit Distance\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1617,
                "problemId": 161,
                "problemTitle": "One Edit Distance",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for One Edit Distance?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1618,
                "problemId": 161,
                "problemTitle": "One Edit Distance",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for One Edit Distance",
                "back": "Input: Input for One Edit Distance\nOutput: Expected output for One Edit Distance\nExplanation: Explanation of how to solve One Edit Distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1621,
                "problemId": 162,
                "problemTitle": "Find Peak Element",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Find Peak Element problem ask you to do?",
                "back": "Problem 162: Find Peak Element - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1622,
                "problemId": 162,
                "problemTitle": "Find Peak Element",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Find Peak Element?",
                "back": "Algorithm: function solve162():\n    // Algorithm approach for Find Peak Element\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: I...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1623,
                "problemId": 162,
                "problemTitle": "Find Peak Element",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Find Peak Element solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1624,
                "problemId": 162,
                "problemTitle": "Find Peak Element",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Find Peak Element solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1625,
                "problemId": 162,
                "problemTitle": "Find Peak Element",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Find Peak Element?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1626,
                "problemId": 162,
                "problemTitle": "Find Peak Element",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Find Peak Element in Python?",
                "back": "```python\ndef solve_162():\n    # Algorithm approach for Find Peak Element\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1627,
                "problemId": 162,
                "problemTitle": "Find Peak Element",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Find Peak Element?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1628,
                "problemId": 162,
                "problemTitle": "Find Peak Element",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Find Peak Element",
                "back": "Input: Input for Find Peak Element\nOutput: Expected output for Find Peak Element\nExplanation: Explanation of how to solve Find Peak Element",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1631,
                "problemId": 163,
                "problemTitle": "Missing Ranges",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Missing Ranges problem ask you to do?",
                "back": "Problem 163: Missing Ranges - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1632,
                "problemId": 163,
                "problemTitle": "Missing Ranges",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Missing Ranges?",
                "back": "Algorithm: function solve163():\n    // Algorithm approach for Missing Ranges\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Init...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1633,
                "problemId": 163,
                "problemTitle": "Missing Ranges",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Missing Ranges solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1634,
                "problemId": 163,
                "problemTitle": "Missing Ranges",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Missing Ranges solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1635,
                "problemId": 163,
                "problemTitle": "Missing Ranges",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Missing Ranges?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1636,
                "problemId": 163,
                "problemTitle": "Missing Ranges",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Missing Ranges in Python?",
                "back": "```python\ndef solve_163():\n    # Algorithm approach for Missing Ranges\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1637,
                "problemId": 163,
                "problemTitle": "Missing Ranges",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Missing Ranges?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1638,
                "problemId": 163,
                "problemTitle": "Missing Ranges",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Missing Ranges",
                "back": "Input: Input for Missing Ranges\nOutput: Expected output for Missing Ranges\nExplanation: Explanation of how to solve Missing Ranges",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1641,
                "problemId": 164,
                "problemTitle": "Maximum Gap",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Maximum Gap problem ask you to do?",
                "back": "Problem 164: Maximum Gap - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1642,
                "problemId": 164,
                "problemTitle": "Maximum Gap",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Maximum Gap?",
                "back": "Algorithm: function solve164():\n    // Algorithm approach for Maximum Gap\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initial...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1643,
                "problemId": 164,
                "problemTitle": "Maximum Gap",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Maximum Gap solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1644,
                "problemId": 164,
                "problemTitle": "Maximum Gap",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Maximum Gap solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1645,
                "problemId": 164,
                "problemTitle": "Maximum Gap",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Maximum Gap?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1646,
                "problemId": 164,
                "problemTitle": "Maximum Gap",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Maximum Gap in Python?",
                "back": "```python\ndef solve_164():\n    # Algorithm approach for Maximum Gap\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1647,
                "problemId": 164,
                "problemTitle": "Maximum Gap",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Maximum Gap?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1648,
                "problemId": 164,
                "problemTitle": "Maximum Gap",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Maximum Gap",
                "back": "Input: Input for Maximum Gap\nOutput: Expected output for Maximum Gap\nExplanation: Explanation of how to solve Maximum Gap",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1651,
                "problemId": 165,
                "problemTitle": "Compare Version Numbers",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Compare Version Numbers problem ask you to do?",
                "back": "Problem 165: Compare Version Numbers - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1652,
                "problemId": 165,
                "problemTitle": "Compare Version Numbers",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Compare Version Numbers?",
                "back": "Algorithm: function solve165():\n    // Algorithm approach for Compare Version Numbers\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Ste...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1653,
                "problemId": 165,
                "problemTitle": "Compare Version Numbers",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Compare Version Numbers solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1654,
                "problemId": 165,
                "problemTitle": "Compare Version Numbers",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Compare Version Numbers solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1655,
                "problemId": 165,
                "problemTitle": "Compare Version Numbers",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Compare Version Numbers?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1656,
                "problemId": 165,
                "problemTitle": "Compare Version Numbers",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Compare Version Numbers in Python?",
                "back": "```python\ndef solve_165():\n    # Algorithm approach for Compare Version Numbers\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1657,
                "problemId": 165,
                "problemTitle": "Compare Version Numbers",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Compare Version Numbers?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1658,
                "problemId": 165,
                "problemTitle": "Compare Version Numbers",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Compare Version Numbers",
                "back": "Input: Input for Compare Version Numbers\nOutput: Expected output for Compare Version Numbers\nExplanation: Explanation of how to solve Compare Version Numbers",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1661,
                "problemId": 166,
                "problemTitle": "Fraction to Recurring Decimal",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Fraction to Recurring Decimal problem ask you to do?",
                "back": "Problem 166: Fraction to Recurring Decimal - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1662,
                "problemId": 166,
                "problemTitle": "Fraction to Recurring Decimal",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Fraction to Recurring Decimal?",
                "back": "Algorithm: function solve166():\n    // Algorithm approach for Fraction to Recurring Decimal\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1663,
                "problemId": 166,
                "problemTitle": "Fraction to Recurring Decimal",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Fraction to Recurring Decimal solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1664,
                "problemId": 166,
                "problemTitle": "Fraction to Recurring Decimal",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Fraction to Recurring Decimal solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1665,
                "problemId": 166,
                "problemTitle": "Fraction to Recurring Decimal",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Fraction to Recurring Decimal?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1666,
                "problemId": 166,
                "problemTitle": "Fraction to Recurring Decimal",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Fraction to Recurring Decimal in Python?",
                "back": "```python\ndef solve_166():\n    # Algorithm approach for Fraction to Recurring Decimal\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1667,
                "problemId": 166,
                "problemTitle": "Fraction to Recurring Decimal",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Fraction to Recurring Decimal?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1668,
                "problemId": 166,
                "problemTitle": "Fraction to Recurring Decimal",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Fraction to Recurring Decimal",
                "back": "Input: Input for Fraction to Recurring Decimal\nOutput: Expected output for Fraction to Recurring Decimal\nExplanation: Explanation of how to solve Fraction to Recurring Decimal",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1671,
                "problemId": 167,
                "problemTitle": "Two Sum II - Input Array Is Sorted",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Two Sum II - Input Array Is Sorted problem ask you to do?",
                "back": "Problem 167: Two Sum II - Input Array Is Sorted - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1672,
                "problemId": 167,
                "problemTitle": "Two Sum II - Input Array Is Sorted",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Two Sum II - Input Array Is Sorted?",
                "back": "Algorithm: function solve167():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1673,
                "problemId": 167,
                "problemTitle": "Two Sum II - Input Array Is Sorted",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Two Sum II - Input Array Is Sorted solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1674,
                "problemId": 167,
                "problemTitle": "Two Sum II - Input Array Is Sorted",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Two Sum II - Input Array Is Sorted solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1675,
                "problemId": 167,
                "problemTitle": "Two Sum II - Input Array Is Sorted",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Two Sum II - Input Array Is Sorted?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1676,
                "problemId": 167,
                "problemTitle": "Two Sum II - Input Array Is Sorted",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Two Sum II - Input Array Is Sorted in Python?",
                "back": "```python\ndef solve_167():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1677,
                "problemId": 167,
                "problemTitle": "Two Sum II - Input Array Is Sorted",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Two Sum II - Input Array Is Sorted?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1678,
                "problemId": 167,
                "problemTitle": "Two Sum II - Input Array Is Sorted",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Two Sum II - Input Array Is Sorted",
                "back": "Input: Input for Two Sum II - Input Array Is Sorted\nOutput: Expected output for Two Sum II - Input Array Is Sorted\nExplanation: Explanation of how to solve Two Sum II - Input Array Is Sorted",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1681,
                "problemId": 168,
                "problemTitle": "Excel Sheet Column Title",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Excel Sheet Column Title problem ask you to do?",
                "back": "Problem 168: Excel Sheet Column Title - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1682,
                "problemId": 168,
                "problemTitle": "Excel Sheet Column Title",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Excel Sheet Column Title?",
                "back": "Algorithm: function solve168():\n    // Algorithm approach for Excel Sheet Column Title\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // St...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1683,
                "problemId": 168,
                "problemTitle": "Excel Sheet Column Title",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Excel Sheet Column Title solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1684,
                "problemId": 168,
                "problemTitle": "Excel Sheet Column Title",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Excel Sheet Column Title solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1685,
                "problemId": 168,
                "problemTitle": "Excel Sheet Column Title",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Excel Sheet Column Title?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1686,
                "problemId": 168,
                "problemTitle": "Excel Sheet Column Title",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Excel Sheet Column Title in Python?",
                "back": "```python\ndef solve_168():\n    # Algorithm approach for Excel Sheet Column Title\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1687,
                "problemId": 168,
                "problemTitle": "Excel Sheet Column Title",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Excel Sheet Column Title?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1688,
                "problemId": 168,
                "problemTitle": "Excel Sheet Column Title",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Excel Sheet Column Title",
                "back": "Input: Input for Excel Sheet Column Title\nOutput: Expected output for Excel Sheet Column Title\nExplanation: Explanation of how to solve Excel Sheet Column Title",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1691,
                "problemId": 169,
                "problemTitle": "Majority Element",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Majority Element problem ask you to do?",
                "back": "Problem 169: Majority Element - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1692,
                "problemId": 169,
                "problemTitle": "Majority Element",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Majority Element?",
                "back": "Algorithm: function solve169():\n    // Algorithm approach for Majority Element\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: In...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1693,
                "problemId": 169,
                "problemTitle": "Majority Element",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Majority Element solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1694,
                "problemId": 169,
                "problemTitle": "Majority Element",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Majority Element solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1695,
                "problemId": 169,
                "problemTitle": "Majority Element",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Majority Element?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1696,
                "problemId": 169,
                "problemTitle": "Majority Element",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Majority Element in Python?",
                "back": "```python\ndef solve_169():\n    # Algorithm approach for Majority Element\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1697,
                "problemId": 169,
                "problemTitle": "Majority Element",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Majority Element?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1698,
                "problemId": 169,
                "problemTitle": "Majority Element",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Majority Element",
                "back": "Input: Input for Majority Element\nOutput: Expected output for Majority Element\nExplanation: Explanation of how to solve Majority Element",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1701,
                "problemId": 170,
                "problemTitle": "Two Sum III - Data structure design",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Two Sum III - Data structure design problem ask you to do?",
                "back": "Problem 170: Two Sum III - Data structure design - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1702,
                "problemId": 170,
                "problemTitle": "Two Sum III - Data structure design",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Two Sum III - Data structure design?",
                "back": "Algorithm: function solve170():\n    // Algorithm approach for Two Sum III - Data structure design\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n   ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1703,
                "problemId": 170,
                "problemTitle": "Two Sum III - Data structure design",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Two Sum III - Data structure design solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1704,
                "problemId": 170,
                "problemTitle": "Two Sum III - Data structure design",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Two Sum III - Data structure design solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1705,
                "problemId": 170,
                "problemTitle": "Two Sum III - Data structure design",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Two Sum III - Data structure design?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1706,
                "problemId": 170,
                "problemTitle": "Two Sum III - Data structure design",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Two Sum III - Data structure design in Python?",
                "back": "```python\ndef solve_170():\n    # Algorithm approach for Two Sum III - Data structure design\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1707,
                "problemId": 170,
                "problemTitle": "Two Sum III - Data structure design",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Two Sum III - Data structure design?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1708,
                "problemId": 170,
                "problemTitle": "Two Sum III - Data structure design",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Two Sum III - Data structure design",
                "back": "Input: Input for Two Sum III - Data structure design\nOutput: Expected output for Two Sum III - Data structure design\nExplanation: Explanation of how to solve Two Sum III - Data structure design",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1711,
                "problemId": 171,
                "problemTitle": "Excel Sheet Column Number",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Excel Sheet Column Number problem ask you to do?",
                "back": "Problem 171: Excel Sheet Column Number - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1712,
                "problemId": 171,
                "problemTitle": "Excel Sheet Column Number",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Excel Sheet Column Number?",
                "back": "Algorithm: function solve171():\n    // Algorithm approach for Excel Sheet Column Number\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // S...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1713,
                "problemId": 171,
                "problemTitle": "Excel Sheet Column Number",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Excel Sheet Column Number solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1714,
                "problemId": 171,
                "problemTitle": "Excel Sheet Column Number",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Excel Sheet Column Number solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1715,
                "problemId": 171,
                "problemTitle": "Excel Sheet Column Number",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Excel Sheet Column Number?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1716,
                "problemId": 171,
                "problemTitle": "Excel Sheet Column Number",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Excel Sheet Column Number in Python?",
                "back": "```python\ndef solve_171():\n    # Algorithm approach for Excel Sheet Column Number\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1717,
                "problemId": 171,
                "problemTitle": "Excel Sheet Column Number",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Excel Sheet Column Number?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1718,
                "problemId": 171,
                "problemTitle": "Excel Sheet Column Number",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Excel Sheet Column Number",
                "back": "Input: Input for Excel Sheet Column Number\nOutput: Expected output for Excel Sheet Column Number\nExplanation: Explanation of how to solve Excel Sheet Column Number",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1721,
                "problemId": 172,
                "problemTitle": "Factorial Trailing Zeroes",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Factorial Trailing Zeroes problem ask you to do?",
                "back": "Problem 172: Factorial Trailing Zeroes - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1722,
                "problemId": 172,
                "problemTitle": "Factorial Trailing Zeroes",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Factorial Trailing Zeroes?",
                "back": "Algorithm: function solve172():\n    // Algorithm approach for Factorial Trailing Zeroes\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // S...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1723,
                "problemId": 172,
                "problemTitle": "Factorial Trailing Zeroes",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Factorial Trailing Zeroes solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1724,
                "problemId": 172,
                "problemTitle": "Factorial Trailing Zeroes",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Factorial Trailing Zeroes solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1725,
                "problemId": 172,
                "problemTitle": "Factorial Trailing Zeroes",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Factorial Trailing Zeroes?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1726,
                "problemId": 172,
                "problemTitle": "Factorial Trailing Zeroes",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Factorial Trailing Zeroes in Python?",
                "back": "```python\ndef solve_172():\n    # Algorithm approach for Factorial Trailing Zeroes\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1727,
                "problemId": 172,
                "problemTitle": "Factorial Trailing Zeroes",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Factorial Trailing Zeroes?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1728,
                "problemId": 172,
                "problemTitle": "Factorial Trailing Zeroes",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Factorial Trailing Zeroes",
                "back": "Input: Input for Factorial Trailing Zeroes\nOutput: Expected output for Factorial Trailing Zeroes\nExplanation: Explanation of how to solve Factorial Trailing Zeroes",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1731,
                "problemId": 173,
                "problemTitle": "Binary Search Tree Iterator",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Binary Search Tree Iterator problem ask you to do?",
                "back": "Problem 173: Binary Search Tree Iterator - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1732,
                "problemId": 173,
                "problemTitle": "Binary Search Tree Iterator",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Search Tree Iterator?",
                "back": "Algorithm: function solve173():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1733,
                "problemId": 173,
                "problemTitle": "Binary Search Tree Iterator",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Search Tree Iterator solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1734,
                "problemId": 173,
                "problemTitle": "Binary Search Tree Iterator",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Search Tree Iterator solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1735,
                "problemId": 173,
                "problemTitle": "Binary Search Tree Iterator",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Search Tree Iterator?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1736,
                "problemId": 173,
                "problemTitle": "Binary Search Tree Iterator",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Binary Search Tree Iterator in Python?",
                "back": "```python\ndef solve_173():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1737,
                "problemId": 173,
                "problemTitle": "Binary Search Tree Iterator",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Search Tree Iterator?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1738,
                "problemId": 173,
                "problemTitle": "Binary Search Tree Iterator",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Search Tree Iterator",
                "back": "Input: Input for Binary Search Tree Iterator\nOutput: Expected output for Binary Search Tree Iterator\nExplanation: Explanation of how to solve Binary Search Tree Iterator",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1741,
                "problemId": 174,
                "problemTitle": "Dungeon Game",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Dungeon Game problem ask you to do?",
                "back": "Find minimum initial health for dungeon game using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1742,
                "problemId": 174,
                "problemTitle": "Dungeon Game",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Dungeon Game?",
                "back": "Bottom-up DP from end\nCalculate minimum health needed",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1743,
                "problemId": 174,
                "problemTitle": "Dungeon Game",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Dungeon Game solution?",
                "back": "O(mn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1744,
                "problemId": 174,
                "problemTitle": "Dungeon Game",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Dungeon Game solution?",
                "back": "O(mn) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1745,
                "problemId": 174,
                "problemTitle": "Dungeon Game",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Dungeon Game?",
                "back": "Bottom-up DP. Minimum health. End to start",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1746,
                "problemId": 174,
                "problemTitle": "Dungeon Game",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Dungeon Game in Python?",
                "back": "```python\nBottom-up DP approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1747,
                "problemId": 174,
                "problemTitle": "Dungeon Game",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Dungeon Game?",
                "back": "Tags: Array, Dynamic Programming, Matrix. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1748,
                "problemId": 174,
                "problemTitle": "Dungeon Game",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Dungeon Game",
                "back": "Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\nOutput: 7\nExplanation: Minimum initial health is 7.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1751,
                "problemId": 175,
                "problemTitle": "Combine Two Tables",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Combine Two Tables problem ask you to do?",
                "back": "Problem 175: Combine Two Tables - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1752,
                "problemId": 175,
                "problemTitle": "Combine Two Tables",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Combine Two Tables?",
                "back": "Algorithm: function solve175():\n    // Algorithm approach for Combine Two Tables\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1753,
                "problemId": 175,
                "problemTitle": "Combine Two Tables",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Combine Two Tables solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1754,
                "problemId": 175,
                "problemTitle": "Combine Two Tables",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Combine Two Tables solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1755,
                "problemId": 175,
                "problemTitle": "Combine Two Tables",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Combine Two Tables?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1756,
                "problemId": 175,
                "problemTitle": "Combine Two Tables",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Combine Two Tables in Python?",
                "back": "```python\ndef solve_175():\n    # Algorithm approach for Combine Two Tables\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1757,
                "problemId": 175,
                "problemTitle": "Combine Two Tables",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Combine Two Tables?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1758,
                "problemId": 175,
                "problemTitle": "Combine Two Tables",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Combine Two Tables",
                "back": "Input: Input for Combine Two Tables\nOutput: Expected output for Combine Two Tables\nExplanation: Explanation of how to solve Combine Two Tables",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1761,
                "problemId": 176,
                "problemTitle": "Second Highest Salary",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Second Highest Salary problem ask you to do?",
                "back": "Problem 176: Second Highest Salary - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1762,
                "problemId": 176,
                "problemTitle": "Second Highest Salary",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Second Highest Salary?",
                "back": "Algorithm: function solve176():\n    // Algorithm approach for Second Highest Salary\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1763,
                "problemId": 176,
                "problemTitle": "Second Highest Salary",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Second Highest Salary solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1764,
                "problemId": 176,
                "problemTitle": "Second Highest Salary",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Second Highest Salary solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1765,
                "problemId": 176,
                "problemTitle": "Second Highest Salary",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Second Highest Salary?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1766,
                "problemId": 176,
                "problemTitle": "Second Highest Salary",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Second Highest Salary in Python?",
                "back": "```python\ndef solve_176():\n    # Algorithm approach for Second Highest Salary\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1767,
                "problemId": 176,
                "problemTitle": "Second Highest Salary",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Second Highest Salary?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1768,
                "problemId": 176,
                "problemTitle": "Second Highest Salary",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Second Highest Salary",
                "back": "Input: Input for Second Highest Salary\nOutput: Expected output for Second Highest Salary\nExplanation: Explanation of how to solve Second Highest Salary",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1771,
                "problemId": 177,
                "problemTitle": "Nth Highest Salary",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Nth Highest Salary problem ask you to do?",
                "back": "Problem 177: Nth Highest Salary - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1772,
                "problemId": 177,
                "problemTitle": "Nth Highest Salary",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Nth Highest Salary?",
                "back": "Algorithm: function solve177():\n    // Algorithm approach for Nth Highest Salary\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1773,
                "problemId": 177,
                "problemTitle": "Nth Highest Salary",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Nth Highest Salary solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1774,
                "problemId": 177,
                "problemTitle": "Nth Highest Salary",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Nth Highest Salary solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1775,
                "problemId": 177,
                "problemTitle": "Nth Highest Salary",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Nth Highest Salary?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1776,
                "problemId": 177,
                "problemTitle": "Nth Highest Salary",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Nth Highest Salary in Python?",
                "back": "```python\ndef solve_177():\n    # Algorithm approach for Nth Highest Salary\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1777,
                "problemId": 177,
                "problemTitle": "Nth Highest Salary",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Nth Highest Salary?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1778,
                "problemId": 177,
                "problemTitle": "Nth Highest Salary",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Nth Highest Salary",
                "back": "Input: Input for Nth Highest Salary\nOutput: Expected output for Nth Highest Salary\nExplanation: Explanation of how to solve Nth Highest Salary",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1781,
                "problemId": 178,
                "problemTitle": "Rank Scores",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Rank Scores problem ask you to do?",
                "back": "Problem 178: Rank Scores - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1782,
                "problemId": 178,
                "problemTitle": "Rank Scores",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Rank Scores?",
                "back": "Algorithm: function solve178():\n    // Algorithm approach for Rank Scores\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initial...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1783,
                "problemId": 178,
                "problemTitle": "Rank Scores",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Rank Scores solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1784,
                "problemId": 178,
                "problemTitle": "Rank Scores",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Rank Scores solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1785,
                "problemId": 178,
                "problemTitle": "Rank Scores",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Rank Scores?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1786,
                "problemId": 178,
                "problemTitle": "Rank Scores",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Rank Scores in Python?",
                "back": "```python\ndef solve_178():\n    # Algorithm approach for Rank Scores\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1787,
                "problemId": 178,
                "problemTitle": "Rank Scores",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Rank Scores?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1788,
                "problemId": 178,
                "problemTitle": "Rank Scores",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Rank Scores",
                "back": "Input: Input for Rank Scores\nOutput: Expected output for Rank Scores\nExplanation: Explanation of how to solve Rank Scores",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1791,
                "problemId": 179,
                "problemTitle": "Largest Number",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Largest Number problem ask you to do?",
                "back": "Problem 179: Largest Number - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1792,
                "problemId": 179,
                "problemTitle": "Largest Number",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Largest Number?",
                "back": "Algorithm: function solve179():\n    // Algorithm approach for Largest Number\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Init...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1793,
                "problemId": 179,
                "problemTitle": "Largest Number",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Largest Number solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1794,
                "problemId": 179,
                "problemTitle": "Largest Number",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Largest Number solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1795,
                "problemId": 179,
                "problemTitle": "Largest Number",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Largest Number?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1796,
                "problemId": 179,
                "problemTitle": "Largest Number",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Largest Number in Python?",
                "back": "```python\ndef solve_179():\n    # Algorithm approach for Largest Number\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1797,
                "problemId": 179,
                "problemTitle": "Largest Number",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Largest Number?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1798,
                "problemId": 179,
                "problemTitle": "Largest Number",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Largest Number",
                "back": "Input: Input for Largest Number\nOutput: Expected output for Largest Number\nExplanation: Explanation of how to solve Largest Number",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1801,
                "problemId": 180,
                "problemTitle": "Consecutive Numbers",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Consecutive Numbers problem ask you to do?",
                "back": "Problem 180: Consecutive Numbers - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1802,
                "problemId": 180,
                "problemTitle": "Consecutive Numbers",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Consecutive Numbers?",
                "back": "Algorithm: function solve180():\n    // Algorithm approach for Consecutive Numbers\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2:...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1803,
                "problemId": 180,
                "problemTitle": "Consecutive Numbers",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Consecutive Numbers solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1804,
                "problemId": 180,
                "problemTitle": "Consecutive Numbers",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Consecutive Numbers solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1805,
                "problemId": 180,
                "problemTitle": "Consecutive Numbers",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Consecutive Numbers?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1806,
                "problemId": 180,
                "problemTitle": "Consecutive Numbers",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Consecutive Numbers in Python?",
                "back": "```python\ndef solve_180():\n    # Algorithm approach for Consecutive Numbers\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1807,
                "problemId": 180,
                "problemTitle": "Consecutive Numbers",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Consecutive Numbers?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1808,
                "problemId": 180,
                "problemTitle": "Consecutive Numbers",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Consecutive Numbers",
                "back": "Input: Input for Consecutive Numbers\nOutput: Expected output for Consecutive Numbers\nExplanation: Explanation of how to solve Consecutive Numbers",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1811,
                "problemId": 181,
                "problemTitle": "Employees Earning More Than Their Managers",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Employees Earning More Than Their Managers problem ask you to do?",
                "back": "Problem 181: Employees Earning More Than Their Managers - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1812,
                "problemId": 181,
                "problemTitle": "Employees Earning More Than Their Managers",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Employees Earning More Than Their Managers?",
                "back": "Algorithm: function solve181():\n    // Algorithm approach for Employees Earning More Than Their Managers\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_va...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1813,
                "problemId": 181,
                "problemTitle": "Employees Earning More Than Their Managers",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Employees Earning More Than Their Managers solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1814,
                "problemId": 181,
                "problemTitle": "Employees Earning More Than Their Managers",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Employees Earning More Than Their Managers solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1815,
                "problemId": 181,
                "problemTitle": "Employees Earning More Than Their Managers",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Employees Earning More Than Their Managers?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1816,
                "problemId": 181,
                "problemTitle": "Employees Earning More Than Their Managers",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Employees Earning More Than Their Managers in Python?",
                "back": "```python\ndef solve_181():\n    # Algorithm approach for Employees Earning More Than Their Managers\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1817,
                "problemId": 181,
                "problemTitle": "Employees Earning More Than Their Managers",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Employees Earning More Than Their Managers?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1818,
                "problemId": 181,
                "problemTitle": "Employees Earning More Than Their Managers",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Employees Earning More Than Their Managers",
                "back": "Input: Input for Employees Earning More Than Their Managers\nOutput: Expected output for Employees Earning More Than Their Managers\nExplanation: Explanation of how to solve Employees Earning More Than Their Managers",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1821,
                "problemId": 182,
                "problemTitle": "Duplicate Emails",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Duplicate Emails problem ask you to do?",
                "back": "Problem 182: Duplicate Emails - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1822,
                "problemId": 182,
                "problemTitle": "Duplicate Emails",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Duplicate Emails?",
                "back": "Algorithm: function solve182():\n    // Algorithm approach for Duplicate Emails\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: In...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1823,
                "problemId": 182,
                "problemTitle": "Duplicate Emails",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Duplicate Emails solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1824,
                "problemId": 182,
                "problemTitle": "Duplicate Emails",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Duplicate Emails solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1825,
                "problemId": 182,
                "problemTitle": "Duplicate Emails",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Duplicate Emails?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1826,
                "problemId": 182,
                "problemTitle": "Duplicate Emails",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Duplicate Emails in Python?",
                "back": "```python\ndef solve_182():\n    # Algorithm approach for Duplicate Emails\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1827,
                "problemId": 182,
                "problemTitle": "Duplicate Emails",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Duplicate Emails?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1828,
                "problemId": 182,
                "problemTitle": "Duplicate Emails",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Duplicate Emails",
                "back": "Input: Input for Duplicate Emails\nOutput: Expected output for Duplicate Emails\nExplanation: Explanation of how to solve Duplicate Emails",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1831,
                "problemId": 183,
                "problemTitle": "Customers Who Never Order",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Customers Who Never Order problem ask you to do?",
                "back": "Problem 183: Customers Who Never Order - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1832,
                "problemId": 183,
                "problemTitle": "Customers Who Never Order",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Customers Who Never Order?",
                "back": "Algorithm: function solve183():\n    // Algorithm approach for Customers Who Never Order\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // S...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1833,
                "problemId": 183,
                "problemTitle": "Customers Who Never Order",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Customers Who Never Order solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1834,
                "problemId": 183,
                "problemTitle": "Customers Who Never Order",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Customers Who Never Order solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1835,
                "problemId": 183,
                "problemTitle": "Customers Who Never Order",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Customers Who Never Order?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1836,
                "problemId": 183,
                "problemTitle": "Customers Who Never Order",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Customers Who Never Order in Python?",
                "back": "```python\ndef solve_183():\n    # Algorithm approach for Customers Who Never Order\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1837,
                "problemId": 183,
                "problemTitle": "Customers Who Never Order",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Customers Who Never Order?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1838,
                "problemId": 183,
                "problemTitle": "Customers Who Never Order",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Customers Who Never Order",
                "back": "Input: Input for Customers Who Never Order\nOutput: Expected output for Customers Who Never Order\nExplanation: Explanation of how to solve Customers Who Never Order",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1841,
                "problemId": 184,
                "problemTitle": "Department Highest Salary",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Department Highest Salary problem ask you to do?",
                "back": "Problem 184: Department Highest Salary - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1842,
                "problemId": 184,
                "problemTitle": "Department Highest Salary",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Department Highest Salary?",
                "back": "Algorithm: function solve184():\n    // Algorithm approach for Department Highest Salary\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // S...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1843,
                "problemId": 184,
                "problemTitle": "Department Highest Salary",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Department Highest Salary solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1844,
                "problemId": 184,
                "problemTitle": "Department Highest Salary",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Department Highest Salary solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1845,
                "problemId": 184,
                "problemTitle": "Department Highest Salary",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Department Highest Salary?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1846,
                "problemId": 184,
                "problemTitle": "Department Highest Salary",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Department Highest Salary in Python?",
                "back": "```python\ndef solve_184():\n    # Algorithm approach for Department Highest Salary\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1847,
                "problemId": 184,
                "problemTitle": "Department Highest Salary",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Department Highest Salary?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1848,
                "problemId": 184,
                "problemTitle": "Department Highest Salary",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Department Highest Salary",
                "back": "Input: Input for Department Highest Salary\nOutput: Expected output for Department Highest Salary\nExplanation: Explanation of how to solve Department Highest Salary",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1851,
                "problemId": 185,
                "problemTitle": "Department Top Three Salaries",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Department Top Three Salaries problem ask you to do?",
                "back": "Problem 185: Department Top Three Salaries - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1852,
                "problemId": 185,
                "problemTitle": "Department Top Three Salaries",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Department Top Three Salaries?",
                "back": "Algorithm: function solve185():\n    // Algorithm approach for Department Top Three Salaries\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1853,
                "problemId": 185,
                "problemTitle": "Department Top Three Salaries",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Department Top Three Salaries solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1854,
                "problemId": 185,
                "problemTitle": "Department Top Three Salaries",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Department Top Three Salaries solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1855,
                "problemId": 185,
                "problemTitle": "Department Top Three Salaries",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Department Top Three Salaries?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1856,
                "problemId": 185,
                "problemTitle": "Department Top Three Salaries",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Department Top Three Salaries in Python?",
                "back": "```python\ndef solve_185():\n    # Algorithm approach for Department Top Three Salaries\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1857,
                "problemId": 185,
                "problemTitle": "Department Top Three Salaries",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Department Top Three Salaries?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1858,
                "problemId": 185,
                "problemTitle": "Department Top Three Salaries",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Department Top Three Salaries",
                "back": "Input: Input for Department Top Three Salaries\nOutput: Expected output for Department Top Three Salaries\nExplanation: Explanation of how to solve Department Top Three Salaries",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1861,
                "problemId": 186,
                "problemTitle": "Reverse Words in a String II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Reverse Words in a String II problem ask you to do?",
                "back": "Problem 186: Reverse Words in a String II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1862,
                "problemId": 186,
                "problemTitle": "Reverse Words in a String II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Reverse Words in a String II?",
                "back": "Algorithm: function solve186():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1863,
                "problemId": 186,
                "problemTitle": "Reverse Words in a String II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Reverse Words in a String II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1864,
                "problemId": 186,
                "problemTitle": "Reverse Words in a String II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Reverse Words in a String II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1865,
                "problemId": 186,
                "problemTitle": "Reverse Words in a String II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Reverse Words in a String II?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1866,
                "problemId": 186,
                "problemTitle": "Reverse Words in a String II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Reverse Words in a String II in Python?",
                "back": "```python\ndef solve_186():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1867,
                "problemId": 186,
                "problemTitle": "Reverse Words in a String II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Reverse Words in a String II?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1868,
                "problemId": 186,
                "problemTitle": "Reverse Words in a String II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Reverse Words in a String II",
                "back": "Input: Input for Reverse Words in a String II\nOutput: Expected output for Reverse Words in a String II\nExplanation: Explanation of how to solve Reverse Words in a String II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1871,
                "problemId": 187,
                "problemTitle": "Repeated DNA Sequences",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Repeated DNA Sequences problem ask you to do?",
                "back": "Problem 187: Repeated DNA Sequences - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1872,
                "problemId": 187,
                "problemTitle": "Repeated DNA Sequences",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Repeated DNA Sequences?",
                "back": "Algorithm: function solve187():\n    // Algorithm approach for Repeated DNA Sequences\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1873,
                "problemId": 187,
                "problemTitle": "Repeated DNA Sequences",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Repeated DNA Sequences solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1874,
                "problemId": 187,
                "problemTitle": "Repeated DNA Sequences",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Repeated DNA Sequences solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1875,
                "problemId": 187,
                "problemTitle": "Repeated DNA Sequences",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Repeated DNA Sequences?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1876,
                "problemId": 187,
                "problemTitle": "Repeated DNA Sequences",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Repeated DNA Sequences in Python?",
                "back": "```python\ndef solve_187():\n    # Algorithm approach for Repeated DNA Sequences\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1877,
                "problemId": 187,
                "problemTitle": "Repeated DNA Sequences",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Repeated DNA Sequences?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1878,
                "problemId": 187,
                "problemTitle": "Repeated DNA Sequences",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Repeated DNA Sequences",
                "back": "Input: Input for Repeated DNA Sequences\nOutput: Expected output for Repeated DNA Sequences\nExplanation: Explanation of how to solve Repeated DNA Sequences",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1881,
                "problemId": 188,
                "problemTitle": "Best Time to Buy and Sell Stock IV",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Best Time to Buy and Sell Stock IV problem ask you to do?",
                "back": "Find maximum profit from at most k transactions using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1882,
                "problemId": 188,
                "problemTitle": "Best Time to Buy and Sell Stock IV",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Best Time to Buy and Sell Stock IV?",
                "back": "DP with k transactions\nTrack buy/sell states",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1883,
                "problemId": 188,
                "problemTitle": "Best Time to Buy and Sell Stock IV",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Best Time to Buy and Sell Stock IV solution?",
                "back": "O(kn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1884,
                "problemId": 188,
                "problemTitle": "Best Time to Buy and Sell Stock IV",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Best Time to Buy and Sell Stock IV solution?",
                "back": "O(kn) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1885,
                "problemId": 188,
                "problemTitle": "Best Time to Buy and Sell Stock IV",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Best Time to Buy and Sell Stock IV?",
                "back": "K transactions. State tracking. DP approach",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1886,
                "problemId": 188,
                "problemTitle": "Best Time to Buy and Sell Stock IV",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Best Time to Buy and Sell Stock IV in Python?",
                "back": "```python\nDP with k states\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1887,
                "problemId": 188,
                "problemTitle": "Best Time to Buy and Sell Stock IV",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Best Time to Buy and Sell Stock IV?",
                "back": "Tags: Array, Dynamic Programming. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1888,
                "problemId": 188,
                "problemTitle": "Best Time to Buy and Sell Stock IV",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Best Time to Buy and Sell Stock IV",
                "back": "Input: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy at 2, sell at 4 for profit 2.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1891,
                "problemId": 189,
                "problemTitle": "Rotate Array",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Rotate Array problem ask you to do?",
                "back": "Problem 189: Rotate Array - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1892,
                "problemId": 189,
                "problemTitle": "Rotate Array",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Rotate Array?",
                "back": "Algorithm: function solve189():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1893,
                "problemId": 189,
                "problemTitle": "Rotate Array",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Rotate Array solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1894,
                "problemId": 189,
                "problemTitle": "Rotate Array",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Rotate Array solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1895,
                "problemId": 189,
                "problemTitle": "Rotate Array",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Rotate Array?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1896,
                "problemId": 189,
                "problemTitle": "Rotate Array",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Rotate Array in Python?",
                "back": "```python\ndef solve_189():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1897,
                "problemId": 189,
                "problemTitle": "Rotate Array",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Rotate Array?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1898,
                "problemId": 189,
                "problemTitle": "Rotate Array",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Rotate Array",
                "back": "Input: Input for Rotate Array\nOutput: Expected output for Rotate Array\nExplanation: Explanation of how to solve Rotate Array",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1901,
                "problemId": 190,
                "problemTitle": "Reverse Bits",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Reverse Bits problem ask you to do?",
                "back": "Problem 190: Reverse Bits - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1902,
                "problemId": 190,
                "problemTitle": "Reverse Bits",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Reverse Bits?",
                "back": "Algorithm: function solve190():\n    // Algorithm approach for Reverse Bits\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initia...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1903,
                "problemId": 190,
                "problemTitle": "Reverse Bits",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Reverse Bits solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1904,
                "problemId": 190,
                "problemTitle": "Reverse Bits",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Reverse Bits solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1905,
                "problemId": 190,
                "problemTitle": "Reverse Bits",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Reverse Bits?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1906,
                "problemId": 190,
                "problemTitle": "Reverse Bits",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Reverse Bits in Python?",
                "back": "```python\ndef solve_190():\n    # Algorithm approach for Reverse Bits\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1907,
                "problemId": 190,
                "problemTitle": "Reverse Bits",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Reverse Bits?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1908,
                "problemId": 190,
                "problemTitle": "Reverse Bits",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Reverse Bits",
                "back": "Input: Input for Reverse Bits\nOutput: Expected output for Reverse Bits\nExplanation: Explanation of how to solve Reverse Bits",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1911,
                "problemId": 191,
                "problemTitle": "Number of 1 Bits",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Number of 1 Bits problem ask you to do?",
                "back": "Problem 191: Number of 1 Bits - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1912,
                "problemId": 191,
                "problemTitle": "Number of 1 Bits",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Number of 1 Bits?",
                "back": "Algorithm: function solve191():\n    // Algorithm approach for Number of 1 Bits\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: In...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1913,
                "problemId": 191,
                "problemTitle": "Number of 1 Bits",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Number of 1 Bits solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1914,
                "problemId": 191,
                "problemTitle": "Number of 1 Bits",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Number of 1 Bits solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1915,
                "problemId": 191,
                "problemTitle": "Number of 1 Bits",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Number of 1 Bits?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1916,
                "problemId": 191,
                "problemTitle": "Number of 1 Bits",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Number of 1 Bits in Python?",
                "back": "```python\ndef solve_191():\n    # Algorithm approach for Number of 1 Bits\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1917,
                "problemId": 191,
                "problemTitle": "Number of 1 Bits",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Number of 1 Bits?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1918,
                "problemId": 191,
                "problemTitle": "Number of 1 Bits",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Number of 1 Bits",
                "back": "Input: Input for Number of 1 Bits\nOutput: Expected output for Number of 1 Bits\nExplanation: Explanation of how to solve Number of 1 Bits",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1921,
                "problemId": 192,
                "problemTitle": "Word Frequency",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Word Frequency problem ask you to do?",
                "back": "Problem 192: Word Frequency - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1922,
                "problemId": 192,
                "problemTitle": "Word Frequency",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Word Frequency?",
                "back": "Algorithm: function solve192():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1923,
                "problemId": 192,
                "problemTitle": "Word Frequency",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Word Frequency solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1924,
                "problemId": 192,
                "problemTitle": "Word Frequency",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Word Frequency solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1925,
                "problemId": 192,
                "problemTitle": "Word Frequency",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Word Frequency?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1926,
                "problemId": 192,
                "problemTitle": "Word Frequency",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Word Frequency in Python?",
                "back": "```python\ndef solve_192():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1927,
                "problemId": 192,
                "problemTitle": "Word Frequency",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Word Frequency?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1928,
                "problemId": 192,
                "problemTitle": "Word Frequency",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Word Frequency",
                "back": "Input: Input for Word Frequency\nOutput: Expected output for Word Frequency\nExplanation: Explanation of how to solve Word Frequency",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1931,
                "problemId": 193,
                "problemTitle": "Valid Phone Numbers",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Valid Phone Numbers problem ask you to do?",
                "back": "Problem 193: Valid Phone Numbers - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1932,
                "problemId": 193,
                "problemTitle": "Valid Phone Numbers",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Valid Phone Numbers?",
                "back": "Algorithm: function solve193():\n    // Algorithm approach for Valid Phone Numbers\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2:...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1933,
                "problemId": 193,
                "problemTitle": "Valid Phone Numbers",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Valid Phone Numbers solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1934,
                "problemId": 193,
                "problemTitle": "Valid Phone Numbers",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Valid Phone Numbers solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1935,
                "problemId": 193,
                "problemTitle": "Valid Phone Numbers",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Valid Phone Numbers?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1936,
                "problemId": 193,
                "problemTitle": "Valid Phone Numbers",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Valid Phone Numbers in Python?",
                "back": "```python\ndef solve_193():\n    # Algorithm approach for Valid Phone Numbers\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1937,
                "problemId": 193,
                "problemTitle": "Valid Phone Numbers",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Valid Phone Numbers?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1938,
                "problemId": 193,
                "problemTitle": "Valid Phone Numbers",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Valid Phone Numbers",
                "back": "Input: Input for Valid Phone Numbers\nOutput: Expected output for Valid Phone Numbers\nExplanation: Explanation of how to solve Valid Phone Numbers",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1941,
                "problemId": 194,
                "problemTitle": "Transpose File",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Transpose File problem ask you to do?",
                "back": "Problem 194: Transpose File - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1942,
                "problemId": 194,
                "problemTitle": "Transpose File",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Transpose File?",
                "back": "Algorithm: function solve194():\n    // Algorithm approach for Transpose File\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Init...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1943,
                "problemId": 194,
                "problemTitle": "Transpose File",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Transpose File solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1944,
                "problemId": 194,
                "problemTitle": "Transpose File",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Transpose File solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1945,
                "problemId": 194,
                "problemTitle": "Transpose File",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Transpose File?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1946,
                "problemId": 194,
                "problemTitle": "Transpose File",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Transpose File in Python?",
                "back": "```python\ndef solve_194():\n    # Algorithm approach for Transpose File\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1947,
                "problemId": 194,
                "problemTitle": "Transpose File",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Transpose File?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1948,
                "problemId": 194,
                "problemTitle": "Transpose File",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Transpose File",
                "back": "Input: Input for Transpose File\nOutput: Expected output for Transpose File\nExplanation: Explanation of how to solve Transpose File",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1951,
                "problemId": 195,
                "problemTitle": "Tenth Line",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Tenth Line problem ask you to do?",
                "back": "Problem 195: Tenth Line - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1952,
                "problemId": 195,
                "problemTitle": "Tenth Line",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Tenth Line?",
                "back": "Algorithm: function solve195():\n    // Algorithm approach for Tenth Line\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initiali...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1953,
                "problemId": 195,
                "problemTitle": "Tenth Line",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Tenth Line solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1954,
                "problemId": 195,
                "problemTitle": "Tenth Line",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Tenth Line solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1955,
                "problemId": 195,
                "problemTitle": "Tenth Line",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Tenth Line?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1956,
                "problemId": 195,
                "problemTitle": "Tenth Line",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Tenth Line in Python?",
                "back": "```python\ndef solve_195():\n    # Algorithm approach for Tenth Line\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1957,
                "problemId": 195,
                "problemTitle": "Tenth Line",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Tenth Line?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1958,
                "problemId": 195,
                "problemTitle": "Tenth Line",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Tenth Line",
                "back": "Input: Input for Tenth Line\nOutput: Expected output for Tenth Line\nExplanation: Explanation of how to solve Tenth Line",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1961,
                "problemId": 196,
                "problemTitle": "Delete Duplicate Emails",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Delete Duplicate Emails problem ask you to do?",
                "back": "Problem 196: Delete Duplicate Emails - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1962,
                "problemId": 196,
                "problemTitle": "Delete Duplicate Emails",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Delete Duplicate Emails?",
                "back": "Algorithm: function solve196():\n    // Algorithm approach for Delete Duplicate Emails\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Ste...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1963,
                "problemId": 196,
                "problemTitle": "Delete Duplicate Emails",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Delete Duplicate Emails solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1964,
                "problemId": 196,
                "problemTitle": "Delete Duplicate Emails",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Delete Duplicate Emails solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1965,
                "problemId": 196,
                "problemTitle": "Delete Duplicate Emails",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Delete Duplicate Emails?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1966,
                "problemId": 196,
                "problemTitle": "Delete Duplicate Emails",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Delete Duplicate Emails in Python?",
                "back": "```python\ndef solve_196():\n    # Algorithm approach for Delete Duplicate Emails\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1967,
                "problemId": 196,
                "problemTitle": "Delete Duplicate Emails",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Delete Duplicate Emails?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1968,
                "problemId": 196,
                "problemTitle": "Delete Duplicate Emails",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Delete Duplicate Emails",
                "back": "Input: Input for Delete Duplicate Emails\nOutput: Expected output for Delete Duplicate Emails\nExplanation: Explanation of how to solve Delete Duplicate Emails",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1971,
                "problemId": 197,
                "problemTitle": "Rising Temperature",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Rising Temperature problem ask you to do?",
                "back": "Problem 197: Rising Temperature - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1972,
                "problemId": 197,
                "problemTitle": "Rising Temperature",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Rising Temperature?",
                "back": "Algorithm: function solve197():\n    // Algorithm approach for Rising Temperature\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1973,
                "problemId": 197,
                "problemTitle": "Rising Temperature",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Rising Temperature solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1974,
                "problemId": 197,
                "problemTitle": "Rising Temperature",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Rising Temperature solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1975,
                "problemId": 197,
                "problemTitle": "Rising Temperature",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Rising Temperature?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1976,
                "problemId": 197,
                "problemTitle": "Rising Temperature",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Rising Temperature in Python?",
                "back": "```python\ndef solve_197():\n    # Algorithm approach for Rising Temperature\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1977,
                "problemId": 197,
                "problemTitle": "Rising Temperature",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Rising Temperature?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1978,
                "problemId": 197,
                "problemTitle": "Rising Temperature",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Rising Temperature",
                "back": "Input: Input for Rising Temperature\nOutput: Expected output for Rising Temperature\nExplanation: Explanation of how to solve Rising Temperature",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1981,
                "problemId": 198,
                "problemTitle": "House Robber",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the House Robber problem ask you to do?",
                "back": "Find maximum money that can be robbed without alerting police using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1982,
                "problemId": 198,
                "problemTitle": "House Robber",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve House Robber?",
                "back": "Algorithm: function rob(nums):\n    if nums.length == 0:\n        return 0\n    if nums.length == 1:\n        return nums[0]\n    \n    prev1 = nums[0]\n    prev2 = max(nums[0], nums[1])\n    \n    for i = 2 to nums.leng...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1983,
                "problemId": 198,
                "problemTitle": "House Robber",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal House Robber solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1984,
                "problemId": 198,
                "problemTitle": "House Robber",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal House Robber solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1985,
                "problemId": 198,
                "problemTitle": "House Robber",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving House Robber?",
                "back": "Skip/rob decision. Choose maximum. DP optimization",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1986,
                "problemId": 198,
                "problemTitle": "House Robber",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement House Robber in Python?",
                "back": "```python\ndef rob(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    prev1 = nums[0]\n    prev2 = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        current = max(prev2, prev1 + nums[i])\n        prev1 = prev2\n        prev2 = current\n    \n    return prev2\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1987,
                "problemId": 198,
                "problemTitle": "House Robber",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for House Robber?",
                "back": "Tags: Array, Dynamic Programming. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1988,
                "problemId": 198,
                "problemTitle": "House Robber",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for House Robber",
                "back": "Input: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 and 3 for maximum 4.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1991,
                "problemId": 199,
                "problemTitle": "Binary Tree Right Side View",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Binary Tree Right Side View problem ask you to do?",
                "back": "Problem 199: Binary Tree Right Side View - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1992,
                "problemId": 199,
                "problemTitle": "Binary Tree Right Side View",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Tree Right Side View?",
                "back": "Algorithm: function solve199():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1993,
                "problemId": 199,
                "problemTitle": "Binary Tree Right Side View",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Tree Right Side View solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1994,
                "problemId": 199,
                "problemTitle": "Binary Tree Right Side View",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Tree Right Side View solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1995,
                "problemId": 199,
                "problemTitle": "Binary Tree Right Side View",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Tree Right Side View?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1996,
                "problemId": 199,
                "problemTitle": "Binary Tree Right Side View",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Binary Tree Right Side View in Python?",
                "back": "```python\ndef solve_199():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1997,
                "problemId": 199,
                "problemTitle": "Binary Tree Right Side View",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Tree Right Side View?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 1998,
                "problemId": 199,
                "problemTitle": "Binary Tree Right Side View",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Tree Right Side View",
                "back": "Input: Input for Binary Tree Right Side View\nOutput: Expected output for Binary Tree Right Side View\nExplanation: Explanation of how to solve Binary Tree Right Side View",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2001,
                "problemId": 200,
                "problemTitle": "Number of Islands",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Number of Islands problem ask you to do?",
                "back": "Problem 200: Number of Islands - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2002,
                "problemId": 200,
                "problemTitle": "Number of Islands",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Number of Islands?",
                "back": "Algorithm: function solve200():\n    // Algorithm approach for Number of Islands\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: I...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2003,
                "problemId": 200,
                "problemTitle": "Number of Islands",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Number of Islands solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2004,
                "problemId": 200,
                "problemTitle": "Number of Islands",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Number of Islands solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2005,
                "problemId": 200,
                "problemTitle": "Number of Islands",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Number of Islands?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2006,
                "problemId": 200,
                "problemTitle": "Number of Islands",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Number of Islands in Python?",
                "back": "```python\ndef solve_200():\n    # Algorithm approach for Number of Islands\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2007,
                "problemId": 200,
                "problemTitle": "Number of Islands",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Number of Islands?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2008,
                "problemId": 200,
                "problemTitle": "Number of Islands",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Number of Islands",
                "back": "Input: Input for Number of Islands\nOutput: Expected output for Number of Islands\nExplanation: Explanation of how to solve Number of Islands",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2011,
                "problemId": 201,
                "problemTitle": "Bitwise AND of Numbers Range",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Bitwise AND of Numbers Range problem ask you to do?",
                "back": "Problem 201: Bitwise AND of Numbers Range - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2012,
                "problemId": 201,
                "problemTitle": "Bitwise AND of Numbers Range",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Bitwise AND of Numbers Range?",
                "back": "Algorithm: function solve201():\n    // Algorithm approach for Bitwise AND of Numbers Range\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    /...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2013,
                "problemId": 201,
                "problemTitle": "Bitwise AND of Numbers Range",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Bitwise AND of Numbers Range solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2014,
                "problemId": 201,
                "problemTitle": "Bitwise AND of Numbers Range",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Bitwise AND of Numbers Range solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2015,
                "problemId": 201,
                "problemTitle": "Bitwise AND of Numbers Range",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Bitwise AND of Numbers Range?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2016,
                "problemId": 201,
                "problemTitle": "Bitwise AND of Numbers Range",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Bitwise AND of Numbers Range in Python?",
                "back": "```python\ndef solve_201():\n    # Algorithm approach for Bitwise AND of Numbers Range\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2017,
                "problemId": 201,
                "problemTitle": "Bitwise AND of Numbers Range",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Bitwise AND of Numbers Range?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2018,
                "problemId": 201,
                "problemTitle": "Bitwise AND of Numbers Range",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Bitwise AND of Numbers Range",
                "back": "Input: Input for Bitwise AND of Numbers Range\nOutput: Expected output for Bitwise AND of Numbers Range\nExplanation: Explanation of how to solve Bitwise AND of Numbers Range",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2021,
                "problemId": 202,
                "problemTitle": "Happy Number",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Happy Number problem ask you to do?",
                "back": "Problem 202: Happy Number - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2022,
                "problemId": 202,
                "problemTitle": "Happy Number",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Happy Number?",
                "back": "Algorithm: function solve202():\n    // Algorithm approach for Happy Number\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initia...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2023,
                "problemId": 202,
                "problemTitle": "Happy Number",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Happy Number solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2024,
                "problemId": 202,
                "problemTitle": "Happy Number",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Happy Number solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2025,
                "problemId": 202,
                "problemTitle": "Happy Number",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Happy Number?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2026,
                "problemId": 202,
                "problemTitle": "Happy Number",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Happy Number in Python?",
                "back": "```python\ndef solve_202():\n    # Algorithm approach for Happy Number\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2027,
                "problemId": 202,
                "problemTitle": "Happy Number",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Happy Number?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2028,
                "problemId": 202,
                "problemTitle": "Happy Number",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Happy Number",
                "back": "Input: Input for Happy Number\nOutput: Expected output for Happy Number\nExplanation: Explanation of how to solve Happy Number",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2031,
                "problemId": 203,
                "problemTitle": "Remove Linked List Elements",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Remove Linked List Elements problem ask you to do?",
                "back": "Problem 203: Remove Linked List Elements - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2032,
                "problemId": 203,
                "problemTitle": "Remove Linked List Elements",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Remove Linked List Elements?",
                "back": "Algorithm: function solve203():\n    // Linked list traversal approach\n    if head == null:\n        return null\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.ne...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2033,
                "problemId": 203,
                "problemTitle": "Remove Linked List Elements",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Remove Linked List Elements solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2034,
                "problemId": 203,
                "problemTitle": "Remove Linked List Elements",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Remove Linked List Elements solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2035,
                "problemId": 203,
                "problemTitle": "Remove Linked List Elements",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Remove Linked List Elements?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2036,
                "problemId": 203,
                "problemTitle": "Remove Linked List Elements",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Remove Linked List Elements in Python?",
                "back": "```python\ndef solve_203():\n    # Linked list traversal approach\n    if not head:\n        return None\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Your logic here\n        current = current.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2037,
                "problemId": 203,
                "problemTitle": "Remove Linked List Elements",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Remove Linked List Elements?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2038,
                "problemId": 203,
                "problemTitle": "Remove Linked List Elements",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Remove Linked List Elements",
                "back": "Input: Input for Remove Linked List Elements\nOutput: Expected output for Remove Linked List Elements\nExplanation: Explanation of how to solve Remove Linked List Elements",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2041,
                "problemId": 204,
                "problemTitle": "Count Primes",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Count Primes problem ask you to do?",
                "back": "Problem 204: Count Primes - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2042,
                "problemId": 204,
                "problemTitle": "Count Primes",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Count Primes?",
                "back": "Algorithm: function solve204():\n    // Algorithm approach for Count Primes\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initia...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2043,
                "problemId": 204,
                "problemTitle": "Count Primes",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Count Primes solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2044,
                "problemId": 204,
                "problemTitle": "Count Primes",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Count Primes solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2045,
                "problemId": 204,
                "problemTitle": "Count Primes",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Count Primes?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2046,
                "problemId": 204,
                "problemTitle": "Count Primes",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Count Primes in Python?",
                "back": "```python\ndef solve_204():\n    # Algorithm approach for Count Primes\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2047,
                "problemId": 204,
                "problemTitle": "Count Primes",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Count Primes?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2048,
                "problemId": 204,
                "problemTitle": "Count Primes",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Count Primes",
                "back": "Input: Input for Count Primes\nOutput: Expected output for Count Primes\nExplanation: Explanation of how to solve Count Primes",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2051,
                "problemId": 205,
                "problemTitle": "Isomorphic Strings",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Isomorphic Strings problem ask you to do?",
                "back": "Problem 205: Isomorphic Strings - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2052,
                "problemId": 205,
                "problemTitle": "Isomorphic Strings",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Isomorphic Strings?",
                "back": "Algorithm: function solve205():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2053,
                "problemId": 205,
                "problemTitle": "Isomorphic Strings",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Isomorphic Strings solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2054,
                "problemId": 205,
                "problemTitle": "Isomorphic Strings",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Isomorphic Strings solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2055,
                "problemId": 205,
                "problemTitle": "Isomorphic Strings",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Isomorphic Strings?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2056,
                "problemId": 205,
                "problemTitle": "Isomorphic Strings",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Isomorphic Strings in Python?",
                "back": "```python\ndef solve_205():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2057,
                "problemId": 205,
                "problemTitle": "Isomorphic Strings",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Isomorphic Strings?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2058,
                "problemId": 205,
                "problemTitle": "Isomorphic Strings",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Isomorphic Strings",
                "back": "Input: Input for Isomorphic Strings\nOutput: Expected output for Isomorphic Strings\nExplanation: Explanation of how to solve Isomorphic Strings",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2061,
                "problemId": 206,
                "problemTitle": "Reverse Linked List",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Reverse Linked List problem ask you to do?",
                "back": "Problem 206: Reverse Linked List - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2062,
                "problemId": 206,
                "problemTitle": "Reverse Linked List",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Reverse Linked List?",
                "back": "Algorithm: function solve206():\n    // Linked list traversal approach\n    if head == null:\n        return null\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.ne...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2063,
                "problemId": 206,
                "problemTitle": "Reverse Linked List",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Reverse Linked List solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2064,
                "problemId": 206,
                "problemTitle": "Reverse Linked List",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Reverse Linked List solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2065,
                "problemId": 206,
                "problemTitle": "Reverse Linked List",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Reverse Linked List?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2066,
                "problemId": 206,
                "problemTitle": "Reverse Linked List",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Reverse Linked List in Python?",
                "back": "```python\ndef solve_206():\n    # Linked list traversal approach\n    if not head:\n        return None\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Your logic here\n        current = current.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2067,
                "problemId": 206,
                "problemTitle": "Reverse Linked List",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Reverse Linked List?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2068,
                "problemId": 206,
                "problemTitle": "Reverse Linked List",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Reverse Linked List",
                "back": "Input: Input for Reverse Linked List\nOutput: Expected output for Reverse Linked List\nExplanation: Explanation of how to solve Reverse Linked List",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2071,
                "problemId": 207,
                "problemTitle": "Course Schedule",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Course Schedule problem ask you to do?",
                "back": "Problem 207: Course Schedule - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2072,
                "problemId": 207,
                "problemTitle": "Course Schedule",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Course Schedule?",
                "back": "Algorithm: function solve207():\n    // Algorithm approach for Course Schedule\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Ini...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2073,
                "problemId": 207,
                "problemTitle": "Course Schedule",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Course Schedule solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2074,
                "problemId": 207,
                "problemTitle": "Course Schedule",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Course Schedule solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2075,
                "problemId": 207,
                "problemTitle": "Course Schedule",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Course Schedule?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2076,
                "problemId": 207,
                "problemTitle": "Course Schedule",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Course Schedule in Python?",
                "back": "```python\ndef solve_207():\n    # Algorithm approach for Course Schedule\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2077,
                "problemId": 207,
                "problemTitle": "Course Schedule",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Course Schedule?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2078,
                "problemId": 207,
                "problemTitle": "Course Schedule",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Course Schedule",
                "back": "Input: Input for Course Schedule\nOutput: Expected output for Course Schedule\nExplanation: Explanation of how to solve Course Schedule",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2081,
                "problemId": 208,
                "problemTitle": "Implement Trie (Prefix Tree)",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Implement Trie (Prefix Tree) problem ask you to do?",
                "back": "Problem 208: Implement Trie (Prefix Tree) - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2082,
                "problemId": 208,
                "problemTitle": "Implement Trie (Prefix Tree)",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Implement Trie (Prefix Tree)?",
                "back": "Algorithm: function solve208():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2083,
                "problemId": 208,
                "problemTitle": "Implement Trie (Prefix Tree)",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Implement Trie (Prefix Tree) solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2084,
                "problemId": 208,
                "problemTitle": "Implement Trie (Prefix Tree)",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Implement Trie (Prefix Tree) solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2085,
                "problemId": 208,
                "problemTitle": "Implement Trie (Prefix Tree)",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Implement Trie (Prefix Tree)?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2086,
                "problemId": 208,
                "problemTitle": "Implement Trie (Prefix Tree)",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Implement Trie (Prefix Tree) in Python?",
                "back": "```python\ndef solve_208():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2087,
                "problemId": 208,
                "problemTitle": "Implement Trie (Prefix Tree)",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Implement Trie (Prefix Tree)?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2088,
                "problemId": 208,
                "problemTitle": "Implement Trie (Prefix Tree)",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Implement Trie (Prefix Tree)",
                "back": "Input: Input for Implement Trie (Prefix Tree)\nOutput: Expected output for Implement Trie (Prefix Tree)\nExplanation: Explanation of how to solve Implement Trie (Prefix Tree)",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2091,
                "problemId": 209,
                "problemTitle": "Minimum Size Subarray Sum",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Minimum Size Subarray Sum problem ask you to do?",
                "back": "Problem 209: Minimum Size Subarray Sum - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2092,
                "problemId": 209,
                "problemTitle": "Minimum Size Subarray Sum",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Minimum Size Subarray Sum?",
                "back": "Algorithm: function solve209():\n    // Algorithm approach for Minimum Size Subarray Sum\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // S...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2093,
                "problemId": 209,
                "problemTitle": "Minimum Size Subarray Sum",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Minimum Size Subarray Sum solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2094,
                "problemId": 209,
                "problemTitle": "Minimum Size Subarray Sum",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Minimum Size Subarray Sum solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2095,
                "problemId": 209,
                "problemTitle": "Minimum Size Subarray Sum",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Minimum Size Subarray Sum?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2096,
                "problemId": 209,
                "problemTitle": "Minimum Size Subarray Sum",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Minimum Size Subarray Sum in Python?",
                "back": "```python\ndef solve_209():\n    # Algorithm approach for Minimum Size Subarray Sum\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2097,
                "problemId": 209,
                "problemTitle": "Minimum Size Subarray Sum",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Minimum Size Subarray Sum?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2098,
                "problemId": 209,
                "problemTitle": "Minimum Size Subarray Sum",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Minimum Size Subarray Sum",
                "back": "Input: Input for Minimum Size Subarray Sum\nOutput: Expected output for Minimum Size Subarray Sum\nExplanation: Explanation of how to solve Minimum Size Subarray Sum",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2101,
                "problemId": 210,
                "problemTitle": "Course Schedule II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Course Schedule II problem ask you to do?",
                "back": "Problem 210: Course Schedule II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2102,
                "problemId": 210,
                "problemTitle": "Course Schedule II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Course Schedule II?",
                "back": "Algorithm: function solve210():\n    // Algorithm approach for Course Schedule II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2103,
                "problemId": 210,
                "problemTitle": "Course Schedule II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Course Schedule II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2104,
                "problemId": 210,
                "problemTitle": "Course Schedule II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Course Schedule II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2105,
                "problemId": 210,
                "problemTitle": "Course Schedule II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Course Schedule II?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2106,
                "problemId": 210,
                "problemTitle": "Course Schedule II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Course Schedule II in Python?",
                "back": "```python\ndef solve_210():\n    # Algorithm approach for Course Schedule II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2107,
                "problemId": 210,
                "problemTitle": "Course Schedule II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Course Schedule II?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2108,
                "problemId": 210,
                "problemTitle": "Course Schedule II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Course Schedule II",
                "back": "Input: Input for Course Schedule II\nOutput: Expected output for Course Schedule II\nExplanation: Explanation of how to solve Course Schedule II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2111,
                "problemId": 211,
                "problemTitle": "Design Add and Search Words Data Structure",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Design Add and Search Words Data Structure problem ask you to do?",
                "back": "Problem 211: Design Add and Search Words Data Structure - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2112,
                "problemId": 211,
                "problemTitle": "Design Add and Search Words Data Structure",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Design Add and Search Words Data Structure?",
                "back": "Algorithm: function solve211():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2113,
                "problemId": 211,
                "problemTitle": "Design Add and Search Words Data Structure",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Design Add and Search Words Data Structure solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2114,
                "problemId": 211,
                "problemTitle": "Design Add and Search Words Data Structure",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Design Add and Search Words Data Structure solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2115,
                "problemId": 211,
                "problemTitle": "Design Add and Search Words Data Structure",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Design Add and Search Words Data Structure?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2116,
                "problemId": 211,
                "problemTitle": "Design Add and Search Words Data Structure",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Design Add and Search Words Data Structure in Python?",
                "back": "```python\ndef solve_211():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2117,
                "problemId": 211,
                "problemTitle": "Design Add and Search Words Data Structure",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Design Add and Search Words Data Structure?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2118,
                "problemId": 211,
                "problemTitle": "Design Add and Search Words Data Structure",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Design Add and Search Words Data Structure",
                "back": "Input: Input for Design Add and Search Words Data Structure\nOutput: Expected output for Design Add and Search Words Data Structure\nExplanation: Explanation of how to solve Design Add and Search Words Data Structure",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2121,
                "problemId": 212,
                "problemTitle": "Word Search II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Word Search II problem ask you to do?",
                "back": "Problem 212: Word Search II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2122,
                "problemId": 212,
                "problemTitle": "Word Search II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Word Search II?",
                "back": "Algorithm: function solve212():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2123,
                "problemId": 212,
                "problemTitle": "Word Search II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Word Search II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2124,
                "problemId": 212,
                "problemTitle": "Word Search II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Word Search II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2125,
                "problemId": 212,
                "problemTitle": "Word Search II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Word Search II?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2126,
                "problemId": 212,
                "problemTitle": "Word Search II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Word Search II in Python?",
                "back": "```python\ndef solve_212():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2127,
                "problemId": 212,
                "problemTitle": "Word Search II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Word Search II?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2128,
                "problemId": 212,
                "problemTitle": "Word Search II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Word Search II",
                "back": "Input: Input for Word Search II\nOutput: Expected output for Word Search II\nExplanation: Explanation of how to solve Word Search II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2131,
                "problemId": 213,
                "problemTitle": "House Robber II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the House Robber II problem ask you to do?",
                "back": "House robber problem with circular arrangement using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2132,
                "problemId": 213,
                "problemTitle": "House Robber II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve House Robber II?",
                "back": "Two DP runs\nExclude first or last house",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2133,
                "problemId": 213,
                "problemTitle": "House Robber II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal House Robber II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2134,
                "problemId": 213,
                "problemTitle": "House Robber II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal House Robber II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2135,
                "problemId": 213,
                "problemTitle": "House Robber II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving House Robber II?",
                "back": "Two DP runs. Exclude first/last. Circular constraint",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2136,
                "problemId": 213,
                "problemTitle": "House Robber II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement House Robber II in Python?",
                "back": "```python\nTwo DP approaches\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2137,
                "problemId": 213,
                "problemTitle": "House Robber II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for House Robber II?",
                "back": "Tags: Array, Dynamic Programming. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2138,
                "problemId": 213,
                "problemTitle": "House Robber II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for House Robber II",
                "back": "Input: nums = [2,3,2]\nOutput: 3\nExplanation: Rob house 2 for maximum 3.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2141,
                "problemId": 214,
                "problemTitle": "Shortest Palindrome",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Shortest Palindrome problem ask you to do?",
                "back": "Problem 214: Shortest Palindrome - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2142,
                "problemId": 214,
                "problemTitle": "Shortest Palindrome",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Shortest Palindrome?",
                "back": "Algorithm: function solve214():\n    // Algorithm approach for Shortest Palindrome\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2:...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2143,
                "problemId": 214,
                "problemTitle": "Shortest Palindrome",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Shortest Palindrome solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2144,
                "problemId": 214,
                "problemTitle": "Shortest Palindrome",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Shortest Palindrome solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2145,
                "problemId": 214,
                "problemTitle": "Shortest Palindrome",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Shortest Palindrome?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2146,
                "problemId": 214,
                "problemTitle": "Shortest Palindrome",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Shortest Palindrome in Python?",
                "back": "```python\ndef solve_214():\n    # Algorithm approach for Shortest Palindrome\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2147,
                "problemId": 214,
                "problemTitle": "Shortest Palindrome",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Shortest Palindrome?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2148,
                "problemId": 214,
                "problemTitle": "Shortest Palindrome",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Shortest Palindrome",
                "back": "Input: Input for Shortest Palindrome\nOutput: Expected output for Shortest Palindrome\nExplanation: Explanation of how to solve Shortest Palindrome",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2151,
                "problemId": 215,
                "problemTitle": "Kth Largest Element in an Array",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Kth Largest Element in an Array problem ask you to do?",
                "back": "Problem 215: Kth Largest Element in an Array - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2152,
                "problemId": 215,
                "problemTitle": "Kth Largest Element in an Array",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Kth Largest Element in an Array?",
                "back": "Algorithm: function solve215():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2153,
                "problemId": 215,
                "problemTitle": "Kth Largest Element in an Array",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Kth Largest Element in an Array solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2154,
                "problemId": 215,
                "problemTitle": "Kth Largest Element in an Array",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Kth Largest Element in an Array solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2155,
                "problemId": 215,
                "problemTitle": "Kth Largest Element in an Array",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Kth Largest Element in an Array?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2156,
                "problemId": 215,
                "problemTitle": "Kth Largest Element in an Array",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Kth Largest Element in an Array in Python?",
                "back": "```python\ndef solve_215():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2157,
                "problemId": 215,
                "problemTitle": "Kth Largest Element in an Array",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Kth Largest Element in an Array?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2158,
                "problemId": 215,
                "problemTitle": "Kth Largest Element in an Array",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Kth Largest Element in an Array",
                "back": "Input: Input for Kth Largest Element in an Array\nOutput: Expected output for Kth Largest Element in an Array\nExplanation: Explanation of how to solve Kth Largest Element in an Array",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2161,
                "problemId": 216,
                "problemTitle": "Combination Sum III",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Combination Sum III problem ask you to do?",
                "back": "Problem 216: Combination Sum III - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2162,
                "problemId": 216,
                "problemTitle": "Combination Sum III",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Combination Sum III?",
                "back": "Algorithm: function solve216():\n    // Algorithm approach for Combination Sum III\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2:...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2163,
                "problemId": 216,
                "problemTitle": "Combination Sum III",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Combination Sum III solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2164,
                "problemId": 216,
                "problemTitle": "Combination Sum III",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Combination Sum III solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2165,
                "problemId": 216,
                "problemTitle": "Combination Sum III",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Combination Sum III?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2166,
                "problemId": 216,
                "problemTitle": "Combination Sum III",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Combination Sum III in Python?",
                "back": "```python\ndef solve_216():\n    # Algorithm approach for Combination Sum III\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2167,
                "problemId": 216,
                "problemTitle": "Combination Sum III",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Combination Sum III?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2168,
                "problemId": 216,
                "problemTitle": "Combination Sum III",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Combination Sum III",
                "back": "Input: Input for Combination Sum III\nOutput: Expected output for Combination Sum III\nExplanation: Explanation of how to solve Combination Sum III",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2171,
                "problemId": 217,
                "problemTitle": "Contains Duplicate",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Contains Duplicate problem ask you to do?",
                "back": "Problem 217: Contains Duplicate - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2172,
                "problemId": 217,
                "problemTitle": "Contains Duplicate",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Contains Duplicate?",
                "back": "Algorithm: function solve217():\n    // Algorithm approach for Contains Duplicate\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2173,
                "problemId": 217,
                "problemTitle": "Contains Duplicate",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Contains Duplicate solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2174,
                "problemId": 217,
                "problemTitle": "Contains Duplicate",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Contains Duplicate solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2175,
                "problemId": 217,
                "problemTitle": "Contains Duplicate",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Contains Duplicate?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2176,
                "problemId": 217,
                "problemTitle": "Contains Duplicate",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Contains Duplicate in Python?",
                "back": "```python\ndef solve_217():\n    # Algorithm approach for Contains Duplicate\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2177,
                "problemId": 217,
                "problemTitle": "Contains Duplicate",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Contains Duplicate?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2178,
                "problemId": 217,
                "problemTitle": "Contains Duplicate",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Contains Duplicate",
                "back": "Input: Input for Contains Duplicate\nOutput: Expected output for Contains Duplicate\nExplanation: Explanation of how to solve Contains Duplicate",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2181,
                "problemId": 218,
                "problemTitle": "The Skyline Problem",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the The Skyline Problem problem ask you to do?",
                "back": "Problem 218: The Skyline Problem - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2182,
                "problemId": 218,
                "problemTitle": "The Skyline Problem",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve The Skyline Problem?",
                "back": "Algorithm: function solve218():\n    // Algorithm approach for The Skyline Problem\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2:...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2183,
                "problemId": 218,
                "problemTitle": "The Skyline Problem",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal The Skyline Problem solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2184,
                "problemId": 218,
                "problemTitle": "The Skyline Problem",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal The Skyline Problem solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2185,
                "problemId": 218,
                "problemTitle": "The Skyline Problem",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving The Skyline Problem?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2186,
                "problemId": 218,
                "problemTitle": "The Skyline Problem",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement The Skyline Problem in Python?",
                "back": "```python\ndef solve_218():\n    # Algorithm approach for The Skyline Problem\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2187,
                "problemId": 218,
                "problemTitle": "The Skyline Problem",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for The Skyline Problem?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2188,
                "problemId": 218,
                "problemTitle": "The Skyline Problem",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for The Skyline Problem",
                "back": "Input: Input for The Skyline Problem\nOutput: Expected output for The Skyline Problem\nExplanation: Explanation of how to solve The Skyline Problem",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2191,
                "problemId": 219,
                "problemTitle": "Contains Duplicate II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Contains Duplicate II problem ask you to do?",
                "back": "Problem 219: Contains Duplicate II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2192,
                "problemId": 219,
                "problemTitle": "Contains Duplicate II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Contains Duplicate II?",
                "back": "Algorithm: function solve219():\n    // Algorithm approach for Contains Duplicate II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2193,
                "problemId": 219,
                "problemTitle": "Contains Duplicate II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Contains Duplicate II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2194,
                "problemId": 219,
                "problemTitle": "Contains Duplicate II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Contains Duplicate II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2195,
                "problemId": 219,
                "problemTitle": "Contains Duplicate II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Contains Duplicate II?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2196,
                "problemId": 219,
                "problemTitle": "Contains Duplicate II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Contains Duplicate II in Python?",
                "back": "```python\ndef solve_219():\n    # Algorithm approach for Contains Duplicate II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2197,
                "problemId": 219,
                "problemTitle": "Contains Duplicate II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Contains Duplicate II?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2198,
                "problemId": 219,
                "problemTitle": "Contains Duplicate II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Contains Duplicate II",
                "back": "Input: Input for Contains Duplicate II\nOutput: Expected output for Contains Duplicate II\nExplanation: Explanation of how to solve Contains Duplicate II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2201,
                "problemId": 220,
                "problemTitle": "Contains Duplicate III",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Contains Duplicate III problem ask you to do?",
                "back": "Problem 220: Contains Duplicate III - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2202,
                "problemId": 220,
                "problemTitle": "Contains Duplicate III",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Contains Duplicate III?",
                "back": "Algorithm: function solve220():\n    // Algorithm approach for Contains Duplicate III\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2203,
                "problemId": 220,
                "problemTitle": "Contains Duplicate III",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Contains Duplicate III solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2204,
                "problemId": 220,
                "problemTitle": "Contains Duplicate III",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Contains Duplicate III solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2205,
                "problemId": 220,
                "problemTitle": "Contains Duplicate III",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Contains Duplicate III?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2206,
                "problemId": 220,
                "problemTitle": "Contains Duplicate III",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Contains Duplicate III in Python?",
                "back": "```python\ndef solve_220():\n    # Algorithm approach for Contains Duplicate III\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2207,
                "problemId": 220,
                "problemTitle": "Contains Duplicate III",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Contains Duplicate III?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2208,
                "problemId": 220,
                "problemTitle": "Contains Duplicate III",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Contains Duplicate III",
                "back": "Input: Input for Contains Duplicate III\nOutput: Expected output for Contains Duplicate III\nExplanation: Explanation of how to solve Contains Duplicate III",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2211,
                "problemId": 221,
                "problemTitle": "Maximal Square",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Maximal Square problem ask you to do?",
                "back": "Find largest square containing only 1's using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2212,
                "problemId": 221,
                "problemTitle": "Maximal Square",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Maximal Square?",
                "back": "DP matrix for square size\nUpdate based on neighbors",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2213,
                "problemId": 221,
                "problemTitle": "Maximal Square",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Maximal Square solution?",
                "back": "O(mn) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2214,
                "problemId": 221,
                "problemTitle": "Maximal Square",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Maximal Square solution?",
                "back": "O(mn) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2215,
                "problemId": 221,
                "problemTitle": "Maximal Square",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Maximal Square?",
                "back": "DP matrix. Square size. Neighbor update",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2216,
                "problemId": 221,
                "problemTitle": "Maximal Square",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Maximal Square in Python?",
                "back": "```python\nDP matrix approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2217,
                "problemId": 221,
                "problemTitle": "Maximal Square",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Maximal Square?",
                "back": "Tags: Array, Dynamic Programming, Matrix. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2218,
                "problemId": 221,
                "problemTitle": "Maximal Square",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Maximal Square",
                "back": "Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 4\nExplanation: Largest square has area 4.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2221,
                "problemId": 222,
                "problemTitle": "Count Complete Tree Nodes",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Count Complete Tree Nodes problem ask you to do?",
                "back": "Problem 222: Count Complete Tree Nodes - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2222,
                "problemId": 222,
                "problemTitle": "Count Complete Tree Nodes",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Count Complete Tree Nodes?",
                "back": "Algorithm: function solve222():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2223,
                "problemId": 222,
                "problemTitle": "Count Complete Tree Nodes",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Count Complete Tree Nodes solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2224,
                "problemId": 222,
                "problemTitle": "Count Complete Tree Nodes",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Count Complete Tree Nodes solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2225,
                "problemId": 222,
                "problemTitle": "Count Complete Tree Nodes",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Count Complete Tree Nodes?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2226,
                "problemId": 222,
                "problemTitle": "Count Complete Tree Nodes",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Count Complete Tree Nodes in Python?",
                "back": "```python\ndef solve_222():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2227,
                "problemId": 222,
                "problemTitle": "Count Complete Tree Nodes",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Count Complete Tree Nodes?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2228,
                "problemId": 222,
                "problemTitle": "Count Complete Tree Nodes",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Count Complete Tree Nodes",
                "back": "Input: Input for Count Complete Tree Nodes\nOutput: Expected output for Count Complete Tree Nodes\nExplanation: Explanation of how to solve Count Complete Tree Nodes",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2231,
                "problemId": 223,
                "problemTitle": "Rectangle Area",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Rectangle Area problem ask you to do?",
                "back": "Problem 223: Rectangle Area - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2232,
                "problemId": 223,
                "problemTitle": "Rectangle Area",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Rectangle Area?",
                "back": "Algorithm: function solve223():\n    // Algorithm approach for Rectangle Area\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Init...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2233,
                "problemId": 223,
                "problemTitle": "Rectangle Area",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Rectangle Area solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2234,
                "problemId": 223,
                "problemTitle": "Rectangle Area",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Rectangle Area solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2235,
                "problemId": 223,
                "problemTitle": "Rectangle Area",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Rectangle Area?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2236,
                "problemId": 223,
                "problemTitle": "Rectangle Area",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Rectangle Area in Python?",
                "back": "```python\ndef solve_223():\n    # Algorithm approach for Rectangle Area\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2237,
                "problemId": 223,
                "problemTitle": "Rectangle Area",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Rectangle Area?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2238,
                "problemId": 223,
                "problemTitle": "Rectangle Area",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Rectangle Area",
                "back": "Input: Input for Rectangle Area\nOutput: Expected output for Rectangle Area\nExplanation: Explanation of how to solve Rectangle Area",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2241,
                "problemId": 224,
                "problemTitle": "Basic Calculator",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Basic Calculator problem ask you to do?",
                "back": "Problem 224: Basic Calculator - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2242,
                "problemId": 224,
                "problemTitle": "Basic Calculator",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Basic Calculator?",
                "back": "Algorithm: function solve224():\n    // Algorithm approach for Basic Calculator\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: In...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2243,
                "problemId": 224,
                "problemTitle": "Basic Calculator",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Basic Calculator solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2244,
                "problemId": 224,
                "problemTitle": "Basic Calculator",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Basic Calculator solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2245,
                "problemId": 224,
                "problemTitle": "Basic Calculator",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Basic Calculator?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2246,
                "problemId": 224,
                "problemTitle": "Basic Calculator",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Basic Calculator in Python?",
                "back": "```python\ndef solve_224():\n    # Algorithm approach for Basic Calculator\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2247,
                "problemId": 224,
                "problemTitle": "Basic Calculator",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Basic Calculator?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2248,
                "problemId": 224,
                "problemTitle": "Basic Calculator",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Basic Calculator",
                "back": "Input: Input for Basic Calculator\nOutput: Expected output for Basic Calculator\nExplanation: Explanation of how to solve Basic Calculator",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2251,
                "problemId": 225,
                "problemTitle": "Implement Stack using Queues",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Implement Stack using Queues problem ask you to do?",
                "back": "Problem 225: Implement Stack using Queues - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2252,
                "problemId": 225,
                "problemTitle": "Implement Stack using Queues",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Implement Stack using Queues?",
                "back": "Algorithm: function solve225():\n    // Algorithm approach for Implement Stack using Queues\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    /...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2253,
                "problemId": 225,
                "problemTitle": "Implement Stack using Queues",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Implement Stack using Queues solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2254,
                "problemId": 225,
                "problemTitle": "Implement Stack using Queues",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Implement Stack using Queues solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2255,
                "problemId": 225,
                "problemTitle": "Implement Stack using Queues",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Implement Stack using Queues?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2256,
                "problemId": 225,
                "problemTitle": "Implement Stack using Queues",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Implement Stack using Queues in Python?",
                "back": "```python\ndef solve_225():\n    # Algorithm approach for Implement Stack using Queues\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2257,
                "problemId": 225,
                "problemTitle": "Implement Stack using Queues",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Implement Stack using Queues?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2258,
                "problemId": 225,
                "problemTitle": "Implement Stack using Queues",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Implement Stack using Queues",
                "back": "Input: Input for Implement Stack using Queues\nOutput: Expected output for Implement Stack using Queues\nExplanation: Explanation of how to solve Implement Stack using Queues",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2261,
                "problemId": 226,
                "problemTitle": "Invert Binary Tree",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Invert Binary Tree problem ask you to do?",
                "back": "Problem 226: Invert Binary Tree - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2262,
                "problemId": 226,
                "problemTitle": "Invert Binary Tree",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Invert Binary Tree?",
                "back": "Algorithm: function solve226():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2263,
                "problemId": 226,
                "problemTitle": "Invert Binary Tree",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Invert Binary Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2264,
                "problemId": 226,
                "problemTitle": "Invert Binary Tree",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Invert Binary Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2265,
                "problemId": 226,
                "problemTitle": "Invert Binary Tree",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Invert Binary Tree?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2266,
                "problemId": 226,
                "problemTitle": "Invert Binary Tree",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Invert Binary Tree in Python?",
                "back": "```python\ndef solve_226():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2267,
                "problemId": 226,
                "problemTitle": "Invert Binary Tree",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Invert Binary Tree?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2268,
                "problemId": 226,
                "problemTitle": "Invert Binary Tree",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Invert Binary Tree",
                "back": "Input: Input for Invert Binary Tree\nOutput: Expected output for Invert Binary Tree\nExplanation: Explanation of how to solve Invert Binary Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2271,
                "problemId": 227,
                "problemTitle": "Basic Calculator II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Basic Calculator II problem ask you to do?",
                "back": "Problem 227: Basic Calculator II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2272,
                "problemId": 227,
                "problemTitle": "Basic Calculator II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Basic Calculator II?",
                "back": "Algorithm: function solve227():\n    // Algorithm approach for Basic Calculator II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2:...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2273,
                "problemId": 227,
                "problemTitle": "Basic Calculator II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Basic Calculator II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2274,
                "problemId": 227,
                "problemTitle": "Basic Calculator II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Basic Calculator II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2275,
                "problemId": 227,
                "problemTitle": "Basic Calculator II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Basic Calculator II?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2276,
                "problemId": 227,
                "problemTitle": "Basic Calculator II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Basic Calculator II in Python?",
                "back": "```python\ndef solve_227():\n    # Algorithm approach for Basic Calculator II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2277,
                "problemId": 227,
                "problemTitle": "Basic Calculator II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Basic Calculator II?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2278,
                "problemId": 227,
                "problemTitle": "Basic Calculator II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Basic Calculator II",
                "back": "Input: Input for Basic Calculator II\nOutput: Expected output for Basic Calculator II\nExplanation: Explanation of how to solve Basic Calculator II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2281,
                "problemId": 228,
                "problemTitle": "Summary Ranges",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Summary Ranges problem ask you to do?",
                "back": "Problem 228: Summary Ranges - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2282,
                "problemId": 228,
                "problemTitle": "Summary Ranges",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Summary Ranges?",
                "back": "Algorithm: function solve228():\n    // Algorithm approach for Summary Ranges\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Init...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2283,
                "problemId": 228,
                "problemTitle": "Summary Ranges",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Summary Ranges solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2284,
                "problemId": 228,
                "problemTitle": "Summary Ranges",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Summary Ranges solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2285,
                "problemId": 228,
                "problemTitle": "Summary Ranges",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Summary Ranges?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2286,
                "problemId": 228,
                "problemTitle": "Summary Ranges",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Summary Ranges in Python?",
                "back": "```python\ndef solve_228():\n    # Algorithm approach for Summary Ranges\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2287,
                "problemId": 228,
                "problemTitle": "Summary Ranges",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Summary Ranges?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2288,
                "problemId": 228,
                "problemTitle": "Summary Ranges",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Summary Ranges",
                "back": "Input: Input for Summary Ranges\nOutput: Expected output for Summary Ranges\nExplanation: Explanation of how to solve Summary Ranges",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2291,
                "problemId": 229,
                "problemTitle": "Majority Element II",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Majority Element II problem ask you to do?",
                "back": "Problem 229: Majority Element II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2292,
                "problemId": 229,
                "problemTitle": "Majority Element II",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Majority Element II?",
                "back": "Algorithm: function solve229():\n    // Algorithm approach for Majority Element II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2:...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2293,
                "problemId": 229,
                "problemTitle": "Majority Element II",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Majority Element II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2294,
                "problemId": 229,
                "problemTitle": "Majority Element II",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Majority Element II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2295,
                "problemId": 229,
                "problemTitle": "Majority Element II",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Majority Element II?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2296,
                "problemId": 229,
                "problemTitle": "Majority Element II",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Majority Element II in Python?",
                "back": "```python\ndef solve_229():\n    # Algorithm approach for Majority Element II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2297,
                "problemId": 229,
                "problemTitle": "Majority Element II",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Majority Element II?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2298,
                "problemId": 229,
                "problemTitle": "Majority Element II",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Majority Element II",
                "back": "Input: Input for Majority Element II\nOutput: Expected output for Majority Element II\nExplanation: Explanation of how to solve Majority Element II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2301,
                "problemId": 230,
                "problemTitle": "Kth Smallest Element in a BST",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Kth Smallest Element in a BST problem ask you to do?",
                "back": "Problem 230: Kth Smallest Element in a BST - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2302,
                "problemId": 230,
                "problemTitle": "Kth Smallest Element in a BST",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Kth Smallest Element in a BST?",
                "back": "Algorithm: function solve230():\n    // Algorithm approach for Kth Smallest Element in a BST\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2303,
                "problemId": 230,
                "problemTitle": "Kth Smallest Element in a BST",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Kth Smallest Element in a BST solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2304,
                "problemId": 230,
                "problemTitle": "Kth Smallest Element in a BST",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Kth Smallest Element in a BST solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2305,
                "problemId": 230,
                "problemTitle": "Kth Smallest Element in a BST",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Kth Smallest Element in a BST?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2306,
                "problemId": 230,
                "problemTitle": "Kth Smallest Element in a BST",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Kth Smallest Element in a BST in Python?",
                "back": "```python\ndef solve_230():\n    # Algorithm approach for Kth Smallest Element in a BST\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2307,
                "problemId": 230,
                "problemTitle": "Kth Smallest Element in a BST",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Kth Smallest Element in a BST?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2308,
                "problemId": 230,
                "problemTitle": "Kth Smallest Element in a BST",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Kth Smallest Element in a BST",
                "back": "Input: Input for Kth Smallest Element in a BST\nOutput: Expected output for Kth Smallest Element in a BST\nExplanation: Explanation of how to solve Kth Smallest Element in a BST",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2311,
                "problemId": 231,
                "problemTitle": "Power of Two",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Power of Two problem ask you to do?",
                "back": "Problem 231: Power of Two - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2312,
                "problemId": 231,
                "problemTitle": "Power of Two",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Power of Two?",
                "back": "Algorithm: function solve231():\n    // Algorithm approach for Power of Two\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initia...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2313,
                "problemId": 231,
                "problemTitle": "Power of Two",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Power of Two solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2314,
                "problemId": 231,
                "problemTitle": "Power of Two",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Power of Two solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2315,
                "problemId": 231,
                "problemTitle": "Power of Two",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Power of Two?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2316,
                "problemId": 231,
                "problemTitle": "Power of Two",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Power of Two in Python?",
                "back": "```python\ndef solve_231():\n    # Algorithm approach for Power of Two\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2317,
                "problemId": 231,
                "problemTitle": "Power of Two",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Power of Two?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2318,
                "problemId": 231,
                "problemTitle": "Power of Two",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Power of Two",
                "back": "Input: Input for Power of Two\nOutput: Expected output for Power of Two\nExplanation: Explanation of how to solve Power of Two",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2321,
                "problemId": 232,
                "problemTitle": "Implement Queue using Stacks",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Implement Queue using Stacks problem ask you to do?",
                "back": "Problem 232: Implement Queue using Stacks - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2322,
                "problemId": 232,
                "problemTitle": "Implement Queue using Stacks",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Implement Queue using Stacks?",
                "back": "Algorithm: function solve232():\n    // Algorithm approach for Implement Queue using Stacks\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    /...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2323,
                "problemId": 232,
                "problemTitle": "Implement Queue using Stacks",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Implement Queue using Stacks solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2324,
                "problemId": 232,
                "problemTitle": "Implement Queue using Stacks",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Implement Queue using Stacks solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2325,
                "problemId": 232,
                "problemTitle": "Implement Queue using Stacks",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Implement Queue using Stacks?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2326,
                "problemId": 232,
                "problemTitle": "Implement Queue using Stacks",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Implement Queue using Stacks in Python?",
                "back": "```python\ndef solve_232():\n    # Algorithm approach for Implement Queue using Stacks\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2327,
                "problemId": 232,
                "problemTitle": "Implement Queue using Stacks",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Implement Queue using Stacks?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2328,
                "problemId": 232,
                "problemTitle": "Implement Queue using Stacks",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Implement Queue using Stacks",
                "back": "Input: Input for Implement Queue using Stacks\nOutput: Expected output for Implement Queue using Stacks\nExplanation: Explanation of how to solve Implement Queue using Stacks",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2331,
                "problemId": 233,
                "problemTitle": "Number of Digit One",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Number of Digit One problem ask you to do?",
                "back": "Problem 233: Number of Digit One - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2332,
                "problemId": 233,
                "problemTitle": "Number of Digit One",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Number of Digit One?",
                "back": "Algorithm: function solve233():\n    // Algorithm approach for Number of Digit One\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2:...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2333,
                "problemId": 233,
                "problemTitle": "Number of Digit One",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Number of Digit One solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2334,
                "problemId": 233,
                "problemTitle": "Number of Digit One",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Number of Digit One solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2335,
                "problemId": 233,
                "problemTitle": "Number of Digit One",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Number of Digit One?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2336,
                "problemId": 233,
                "problemTitle": "Number of Digit One",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Number of Digit One in Python?",
                "back": "```python\ndef solve_233():\n    # Algorithm approach for Number of Digit One\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2337,
                "problemId": 233,
                "problemTitle": "Number of Digit One",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Number of Digit One?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2338,
                "problemId": 233,
                "problemTitle": "Number of Digit One",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Number of Digit One",
                "back": "Input: Input for Number of Digit One\nOutput: Expected output for Number of Digit One\nExplanation: Explanation of how to solve Number of Digit One",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2341,
                "problemId": 234,
                "problemTitle": "Palindrome Linked List",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Palindrome Linked List problem ask you to do?",
                "back": "Problem 234: Palindrome Linked List - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2342,
                "problemId": 234,
                "problemTitle": "Palindrome Linked List",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Palindrome Linked List?",
                "back": "Algorithm: function solve234():\n    // Linked list traversal approach\n    if head == null:\n        return null\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.ne...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2343,
                "problemId": 234,
                "problemTitle": "Palindrome Linked List",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Palindrome Linked List solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2344,
                "problemId": 234,
                "problemTitle": "Palindrome Linked List",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Palindrome Linked List solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2345,
                "problemId": 234,
                "problemTitle": "Palindrome Linked List",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Palindrome Linked List?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2346,
                "problemId": 234,
                "problemTitle": "Palindrome Linked List",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Palindrome Linked List in Python?",
                "back": "```python\ndef solve_234():\n    # Linked list traversal approach\n    if not head:\n        return None\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Your logic here\n        current = current.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2347,
                "problemId": 234,
                "problemTitle": "Palindrome Linked List",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Palindrome Linked List?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2348,
                "problemId": 234,
                "problemTitle": "Palindrome Linked List",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Palindrome Linked List",
                "back": "Input: Input for Palindrome Linked List\nOutput: Expected output for Palindrome Linked List\nExplanation: Explanation of how to solve Palindrome Linked List",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2351,
                "problemId": 235,
                "problemTitle": "Lowest Common Ancestor of a Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Lowest Common Ancestor of a Binary Search Tree problem ask you to do?",
                "back": "Problem 235: Lowest Common Ancestor of a Binary Search Tree - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2352,
                "problemId": 235,
                "problemTitle": "Lowest Common Ancestor of a Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Lowest Common Ancestor of a Binary Search Tree?",
                "back": "Algorithm: function solve235():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2353,
                "problemId": 235,
                "problemTitle": "Lowest Common Ancestor of a Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Lowest Common Ancestor of a Binary Search Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2354,
                "problemId": 235,
                "problemTitle": "Lowest Common Ancestor of a Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Lowest Common Ancestor of a Binary Search Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2355,
                "problemId": 235,
                "problemTitle": "Lowest Common Ancestor of a Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Lowest Common Ancestor of a Binary Search Tree?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2356,
                "problemId": 235,
                "problemTitle": "Lowest Common Ancestor of a Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Lowest Common Ancestor of a Binary Search Tree in Python?",
                "back": "```python\ndef solve_235():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2357,
                "problemId": 235,
                "problemTitle": "Lowest Common Ancestor of a Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Lowest Common Ancestor of a Binary Search Tree?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2358,
                "problemId": 235,
                "problemTitle": "Lowest Common Ancestor of a Binary Search Tree",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Lowest Common Ancestor of a Binary Search Tree",
                "back": "Input: Input for Lowest Common Ancestor of a Binary Search Tree\nOutput: Expected output for Lowest Common Ancestor of a Binary Search Tree\nExplanation: Explanation of how to solve Lowest Common Ancestor of a Binary Search Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2361,
                "problemId": 236,
                "problemTitle": "Lowest Common Ancestor of a Binary Tree",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Lowest Common Ancestor of a Binary Tree problem ask you to do?",
                "back": "Problem 236: Lowest Common Ancestor of a Binary Tree - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2362,
                "problemId": 236,
                "problemTitle": "Lowest Common Ancestor of a Binary Tree",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Lowest Common Ancestor of a Binary Tree?",
                "back": "Algorithm: function solve236():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2363,
                "problemId": 236,
                "problemTitle": "Lowest Common Ancestor of a Binary Tree",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Lowest Common Ancestor of a Binary Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2364,
                "problemId": 236,
                "problemTitle": "Lowest Common Ancestor of a Binary Tree",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Lowest Common Ancestor of a Binary Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2365,
                "problemId": 236,
                "problemTitle": "Lowest Common Ancestor of a Binary Tree",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Lowest Common Ancestor of a Binary Tree?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2366,
                "problemId": 236,
                "problemTitle": "Lowest Common Ancestor of a Binary Tree",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Lowest Common Ancestor of a Binary Tree in Python?",
                "back": "```python\ndef solve_236():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2367,
                "problemId": 236,
                "problemTitle": "Lowest Common Ancestor of a Binary Tree",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Lowest Common Ancestor of a Binary Tree?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2368,
                "problemId": 236,
                "problemTitle": "Lowest Common Ancestor of a Binary Tree",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Lowest Common Ancestor of a Binary Tree",
                "back": "Input: Input for Lowest Common Ancestor of a Binary Tree\nOutput: Expected output for Lowest Common Ancestor of a Binary Tree\nExplanation: Explanation of how to solve Lowest Common Ancestor of a Binary Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2371,
                "problemId": 237,
                "problemTitle": "Delete Node in a Linked List",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Delete Node in a Linked List problem ask you to do?",
                "back": "Problem 237: Delete Node in a Linked List - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2372,
                "problemId": 237,
                "problemTitle": "Delete Node in a Linked List",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Delete Node in a Linked List?",
                "back": "Algorithm: function solve237():\n    // Linked list traversal approach\n    if head == null:\n        return null\n    \n    dummy = new ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.ne...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2373,
                "problemId": 237,
                "problemTitle": "Delete Node in a Linked List",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Delete Node in a Linked List solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2374,
                "problemId": 237,
                "problemTitle": "Delete Node in a Linked List",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Delete Node in a Linked List solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2375,
                "problemId": 237,
                "problemTitle": "Delete Node in a Linked List",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Delete Node in a Linked List?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2376,
                "problemId": 237,
                "problemTitle": "Delete Node in a Linked List",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Delete Node in a Linked List in Python?",
                "back": "```python\ndef solve_237():\n    # Linked list traversal approach\n    if not head:\n        return None\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n    \n    while current.next:\n        # Your logic here\n        current = current.next\n    \n    return dummy.next\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2377,
                "problemId": 237,
                "problemTitle": "Delete Node in a Linked List",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Delete Node in a Linked List?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2378,
                "problemId": 237,
                "problemTitle": "Delete Node in a Linked List",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Delete Node in a Linked List",
                "back": "Input: Input for Delete Node in a Linked List\nOutput: Expected output for Delete Node in a Linked List\nExplanation: Explanation of how to solve Delete Node in a Linked List",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2381,
                "problemId": 238,
                "problemTitle": "Product of Array Except Self",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Product of Array Except Self problem ask you to do?",
                "back": "Problem 238: Product of Array Except Self - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2382,
                "problemId": 238,
                "problemTitle": "Product of Array Except Self",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Product of Array Except Self?",
                "back": "Algorithm: function solve238():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2383,
                "problemId": 238,
                "problemTitle": "Product of Array Except Self",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Product of Array Except Self solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2384,
                "problemId": 238,
                "problemTitle": "Product of Array Except Self",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Product of Array Except Self solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2385,
                "problemId": 238,
                "problemTitle": "Product of Array Except Self",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Product of Array Except Self?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2386,
                "problemId": 238,
                "problemTitle": "Product of Array Except Self",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Product of Array Except Self in Python?",
                "back": "```python\ndef solve_238():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2387,
                "problemId": 238,
                "problemTitle": "Product of Array Except Self",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Product of Array Except Self?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2388,
                "problemId": 238,
                "problemTitle": "Product of Array Except Self",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Product of Array Except Self",
                "back": "Input: Input for Product of Array Except Self\nOutput: Expected output for Product of Array Except Self\nExplanation: Explanation of how to solve Product of Array Except Self",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2391,
                "problemId": 239,
                "problemTitle": "Sliding Window Maximum",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Sliding Window Maximum problem ask you to do?",
                "back": "Problem 239: Sliding Window Maximum - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2392,
                "problemId": 239,
                "problemTitle": "Sliding Window Maximum",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Sliding Window Maximum?",
                "back": "Algorithm: function solve239():\n    // Algorithm approach for Sliding Window Maximum\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2393,
                "problemId": 239,
                "problemTitle": "Sliding Window Maximum",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Sliding Window Maximum solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2394,
                "problemId": 239,
                "problemTitle": "Sliding Window Maximum",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Sliding Window Maximum solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2395,
                "problemId": 239,
                "problemTitle": "Sliding Window Maximum",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Sliding Window Maximum?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2396,
                "problemId": 239,
                "problemTitle": "Sliding Window Maximum",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Sliding Window Maximum in Python?",
                "back": "```python\ndef solve_239():\n    # Algorithm approach for Sliding Window Maximum\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2397,
                "problemId": 239,
                "problemTitle": "Sliding Window Maximum",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Sliding Window Maximum?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2398,
                "problemId": 239,
                "problemTitle": "Sliding Window Maximum",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Sliding Window Maximum",
                "back": "Input: Input for Sliding Window Maximum\nOutput: Expected output for Sliding Window Maximum\nExplanation: Explanation of how to solve Sliding Window Maximum",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2401,
                "problemId": 240,
                "problemTitle": "Search a 2D Matrix II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Search a 2D Matrix II problem ask you to do?",
                "back": "Problem 240: Search a 2D Matrix II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2402,
                "problemId": 240,
                "problemTitle": "Search a 2D Matrix II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Search a 2D Matrix II?",
                "back": "Algorithm: function solve240():\n    // Matrix traversal approach\n    if matrix.length == 0:\n        return []\n    \n    m = matrix.length\n    n = matrix[0].length\n    result = []\n    \n    for i = 0 to m - 1:\n    ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2403,
                "problemId": 240,
                "problemTitle": "Search a 2D Matrix II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Search a 2D Matrix II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2404,
                "problemId": 240,
                "problemTitle": "Search a 2D Matrix II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Search a 2D Matrix II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2405,
                "problemId": 240,
                "problemTitle": "Search a 2D Matrix II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Search a 2D Matrix II?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2406,
                "problemId": 240,
                "problemTitle": "Search a 2D Matrix II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Search a 2D Matrix II in Python?",
                "back": "```python\ndef solve_240():\n    # Matrix traversal approach\n    if not matrix:\n        return []\n    \n    m, n = len(matrix), len(matrix[0])\n    result = []\n    \n    for i in range(m):\n        for j in range(n):\n            # Your logic here\n            pass\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2407,
                "problemId": 240,
                "problemTitle": "Search a 2D Matrix II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Search a 2D Matrix II?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2408,
                "problemId": 240,
                "problemTitle": "Search a 2D Matrix II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Search a 2D Matrix II",
                "back": "Input: Input for Search a 2D Matrix II\nOutput: Expected output for Search a 2D Matrix II\nExplanation: Explanation of how to solve Search a 2D Matrix II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2411,
                "problemId": 241,
                "problemTitle": "Different Ways to Add Parentheses",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Different Ways to Add Parentheses problem ask you to do?",
                "back": "Problem 241: Different Ways to Add Parentheses - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2412,
                "problemId": 241,
                "problemTitle": "Different Ways to Add Parentheses",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Different Ways to Add Parentheses?",
                "back": "Algorithm: function solve241():\n    // Algorithm approach for Different Ways to Add Parentheses\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2413,
                "problemId": 241,
                "problemTitle": "Different Ways to Add Parentheses",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Different Ways to Add Parentheses solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2414,
                "problemId": 241,
                "problemTitle": "Different Ways to Add Parentheses",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Different Ways to Add Parentheses solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2415,
                "problemId": 241,
                "problemTitle": "Different Ways to Add Parentheses",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Different Ways to Add Parentheses?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2416,
                "problemId": 241,
                "problemTitle": "Different Ways to Add Parentheses",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Different Ways to Add Parentheses in Python?",
                "back": "```python\ndef solve_241():\n    # Algorithm approach for Different Ways to Add Parentheses\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2417,
                "problemId": 241,
                "problemTitle": "Different Ways to Add Parentheses",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Different Ways to Add Parentheses?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2418,
                "problemId": 241,
                "problemTitle": "Different Ways to Add Parentheses",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Different Ways to Add Parentheses",
                "back": "Input: Input for Different Ways to Add Parentheses\nOutput: Expected output for Different Ways to Add Parentheses\nExplanation: Explanation of how to solve Different Ways to Add Parentheses",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2421,
                "problemId": 242,
                "problemTitle": "Valid Anagram",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Valid Anagram problem ask you to do?",
                "back": "Problem 242: Valid Anagram - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2422,
                "problemId": 242,
                "problemTitle": "Valid Anagram",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Valid Anagram?",
                "back": "Algorithm: function solve242():\n    // Algorithm approach for Valid Anagram\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initi...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2423,
                "problemId": 242,
                "problemTitle": "Valid Anagram",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Valid Anagram solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2424,
                "problemId": 242,
                "problemTitle": "Valid Anagram",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Valid Anagram solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2425,
                "problemId": 242,
                "problemTitle": "Valid Anagram",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Valid Anagram?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2426,
                "problemId": 242,
                "problemTitle": "Valid Anagram",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Valid Anagram in Python?",
                "back": "```python\ndef solve_242():\n    # Algorithm approach for Valid Anagram\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2427,
                "problemId": 242,
                "problemTitle": "Valid Anagram",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Valid Anagram?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2428,
                "problemId": 242,
                "problemTitle": "Valid Anagram",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Valid Anagram",
                "back": "Input: Input for Valid Anagram\nOutput: Expected output for Valid Anagram\nExplanation: Explanation of how to solve Valid Anagram",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2431,
                "problemId": 243,
                "problemTitle": "Shortest Word Distance",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Shortest Word Distance problem ask you to do?",
                "back": "Problem 243: Shortest Word Distance - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2432,
                "problemId": 243,
                "problemTitle": "Shortest Word Distance",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Shortest Word Distance?",
                "back": "Algorithm: function solve243():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2433,
                "problemId": 243,
                "problemTitle": "Shortest Word Distance",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Shortest Word Distance solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2434,
                "problemId": 243,
                "problemTitle": "Shortest Word Distance",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Shortest Word Distance solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2435,
                "problemId": 243,
                "problemTitle": "Shortest Word Distance",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Shortest Word Distance?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2436,
                "problemId": 243,
                "problemTitle": "Shortest Word Distance",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Shortest Word Distance in Python?",
                "back": "```python\ndef solve_243():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2437,
                "problemId": 243,
                "problemTitle": "Shortest Word Distance",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Shortest Word Distance?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2438,
                "problemId": 243,
                "problemTitle": "Shortest Word Distance",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Shortest Word Distance",
                "back": "Input: Input for Shortest Word Distance\nOutput: Expected output for Shortest Word Distance\nExplanation: Explanation of how to solve Shortest Word Distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2441,
                "problemId": 244,
                "problemTitle": "Shortest Word Distance II",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Shortest Word Distance II problem ask you to do?",
                "back": "Problem 244: Shortest Word Distance II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2442,
                "problemId": 244,
                "problemTitle": "Shortest Word Distance II",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Shortest Word Distance II?",
                "back": "Algorithm: function solve244():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2443,
                "problemId": 244,
                "problemTitle": "Shortest Word Distance II",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Shortest Word Distance II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2444,
                "problemId": 244,
                "problemTitle": "Shortest Word Distance II",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Shortest Word Distance II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2445,
                "problemId": 244,
                "problemTitle": "Shortest Word Distance II",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Shortest Word Distance II?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2446,
                "problemId": 244,
                "problemTitle": "Shortest Word Distance II",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Shortest Word Distance II in Python?",
                "back": "```python\ndef solve_244():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2447,
                "problemId": 244,
                "problemTitle": "Shortest Word Distance II",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Shortest Word Distance II?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2448,
                "problemId": 244,
                "problemTitle": "Shortest Word Distance II",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Shortest Word Distance II",
                "back": "Input: Input for Shortest Word Distance II\nOutput: Expected output for Shortest Word Distance II\nExplanation: Explanation of how to solve Shortest Word Distance II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2451,
                "problemId": 245,
                "problemTitle": "Shortest Word Distance III",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Shortest Word Distance III problem ask you to do?",
                "back": "Problem 245: Shortest Word Distance III - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2452,
                "problemId": 245,
                "problemTitle": "Shortest Word Distance III",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Shortest Word Distance III?",
                "back": "Algorithm: function solve245():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2453,
                "problemId": 245,
                "problemTitle": "Shortest Word Distance III",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Shortest Word Distance III solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2454,
                "problemId": 245,
                "problemTitle": "Shortest Word Distance III",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Shortest Word Distance III solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2455,
                "problemId": 245,
                "problemTitle": "Shortest Word Distance III",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Shortest Word Distance III?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2456,
                "problemId": 245,
                "problemTitle": "Shortest Word Distance III",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Shortest Word Distance III in Python?",
                "back": "```python\ndef solve_245():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2457,
                "problemId": 245,
                "problemTitle": "Shortest Word Distance III",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Shortest Word Distance III?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2458,
                "problemId": 245,
                "problemTitle": "Shortest Word Distance III",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Shortest Word Distance III",
                "back": "Input: Input for Shortest Word Distance III\nOutput: Expected output for Shortest Word Distance III\nExplanation: Explanation of how to solve Shortest Word Distance III",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2461,
                "problemId": 246,
                "problemTitle": "Strobogrammatic Number",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Strobogrammatic Number problem ask you to do?",
                "back": "Problem 246: Strobogrammatic Number - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2462,
                "problemId": 246,
                "problemTitle": "Strobogrammatic Number",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Strobogrammatic Number?",
                "back": "Algorithm: function solve246():\n    // Algorithm approach for Strobogrammatic Number\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2463,
                "problemId": 246,
                "problemTitle": "Strobogrammatic Number",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Strobogrammatic Number solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2464,
                "problemId": 246,
                "problemTitle": "Strobogrammatic Number",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Strobogrammatic Number solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2465,
                "problemId": 246,
                "problemTitle": "Strobogrammatic Number",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Strobogrammatic Number?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2466,
                "problemId": 246,
                "problemTitle": "Strobogrammatic Number",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Strobogrammatic Number in Python?",
                "back": "```python\ndef solve_246():\n    # Algorithm approach for Strobogrammatic Number\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2467,
                "problemId": 246,
                "problemTitle": "Strobogrammatic Number",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Strobogrammatic Number?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2468,
                "problemId": 246,
                "problemTitle": "Strobogrammatic Number",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Strobogrammatic Number",
                "back": "Input: Input for Strobogrammatic Number\nOutput: Expected output for Strobogrammatic Number\nExplanation: Explanation of how to solve Strobogrammatic Number",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2471,
                "problemId": 247,
                "problemTitle": "Strobogrammatic Number II",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Strobogrammatic Number II problem ask you to do?",
                "back": "Problem 247: Strobogrammatic Number II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2472,
                "problemId": 247,
                "problemTitle": "Strobogrammatic Number II",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Strobogrammatic Number II?",
                "back": "Algorithm: function solve247():\n    // Algorithm approach for Strobogrammatic Number II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // S...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2473,
                "problemId": 247,
                "problemTitle": "Strobogrammatic Number II",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Strobogrammatic Number II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2474,
                "problemId": 247,
                "problemTitle": "Strobogrammatic Number II",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Strobogrammatic Number II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2475,
                "problemId": 247,
                "problemTitle": "Strobogrammatic Number II",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Strobogrammatic Number II?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2476,
                "problemId": 247,
                "problemTitle": "Strobogrammatic Number II",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Strobogrammatic Number II in Python?",
                "back": "```python\ndef solve_247():\n    # Algorithm approach for Strobogrammatic Number II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2477,
                "problemId": 247,
                "problemTitle": "Strobogrammatic Number II",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Strobogrammatic Number II?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2478,
                "problemId": 247,
                "problemTitle": "Strobogrammatic Number II",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Strobogrammatic Number II",
                "back": "Input: Input for Strobogrammatic Number II\nOutput: Expected output for Strobogrammatic Number II\nExplanation: Explanation of how to solve Strobogrammatic Number II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2481,
                "problemId": 248,
                "problemTitle": "Strobogrammatic Number III",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Strobogrammatic Number III problem ask you to do?",
                "back": "Problem 248: Strobogrammatic Number III - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2482,
                "problemId": 248,
                "problemTitle": "Strobogrammatic Number III",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Strobogrammatic Number III?",
                "back": "Algorithm: function solve248():\n    // Algorithm approach for Strobogrammatic Number III\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2483,
                "problemId": 248,
                "problemTitle": "Strobogrammatic Number III",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Strobogrammatic Number III solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2484,
                "problemId": 248,
                "problemTitle": "Strobogrammatic Number III",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Strobogrammatic Number III solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2485,
                "problemId": 248,
                "problemTitle": "Strobogrammatic Number III",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Strobogrammatic Number III?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2486,
                "problemId": 248,
                "problemTitle": "Strobogrammatic Number III",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Strobogrammatic Number III in Python?",
                "back": "```python\ndef solve_248():\n    # Algorithm approach for Strobogrammatic Number III\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2487,
                "problemId": 248,
                "problemTitle": "Strobogrammatic Number III",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Strobogrammatic Number III?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2488,
                "problemId": 248,
                "problemTitle": "Strobogrammatic Number III",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Strobogrammatic Number III",
                "back": "Input: Input for Strobogrammatic Number III\nOutput: Expected output for Strobogrammatic Number III\nExplanation: Explanation of how to solve Strobogrammatic Number III",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2491,
                "problemId": 249,
                "problemTitle": "Group Shifted Strings",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Group Shifted Strings problem ask you to do?",
                "back": "Problem 249: Group Shifted Strings - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2492,
                "problemId": 249,
                "problemTitle": "Group Shifted Strings",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Group Shifted Strings?",
                "back": "Algorithm: function solve249():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2493,
                "problemId": 249,
                "problemTitle": "Group Shifted Strings",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Group Shifted Strings solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2494,
                "problemId": 249,
                "problemTitle": "Group Shifted Strings",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Group Shifted Strings solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2495,
                "problemId": 249,
                "problemTitle": "Group Shifted Strings",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Group Shifted Strings?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2496,
                "problemId": 249,
                "problemTitle": "Group Shifted Strings",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Group Shifted Strings in Python?",
                "back": "```python\ndef solve_249():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2497,
                "problemId": 249,
                "problemTitle": "Group Shifted Strings",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Group Shifted Strings?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2498,
                "problemId": 249,
                "problemTitle": "Group Shifted Strings",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Group Shifted Strings",
                "back": "Input: Input for Group Shifted Strings\nOutput: Expected output for Group Shifted Strings\nExplanation: Explanation of how to solve Group Shifted Strings",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2501,
                "problemId": 250,
                "problemTitle": "Count Univalue Subtrees",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Count Univalue Subtrees problem ask you to do?",
                "back": "Problem 250: Count Univalue Subtrees - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2502,
                "problemId": 250,
                "problemTitle": "Count Univalue Subtrees",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Count Univalue Subtrees?",
                "back": "Algorithm: function solve250():\n    // Algorithm approach for Count Univalue Subtrees\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Ste...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2503,
                "problemId": 250,
                "problemTitle": "Count Univalue Subtrees",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Count Univalue Subtrees solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2504,
                "problemId": 250,
                "problemTitle": "Count Univalue Subtrees",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Count Univalue Subtrees solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2505,
                "problemId": 250,
                "problemTitle": "Count Univalue Subtrees",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Count Univalue Subtrees?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2506,
                "problemId": 250,
                "problemTitle": "Count Univalue Subtrees",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Count Univalue Subtrees in Python?",
                "back": "```python\ndef solve_250():\n    # Algorithm approach for Count Univalue Subtrees\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2507,
                "problemId": 250,
                "problemTitle": "Count Univalue Subtrees",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Count Univalue Subtrees?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2508,
                "problemId": 250,
                "problemTitle": "Count Univalue Subtrees",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Count Univalue Subtrees",
                "back": "Input: Input for Count Univalue Subtrees\nOutput: Expected output for Count Univalue Subtrees\nExplanation: Explanation of how to solve Count Univalue Subtrees",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2511,
                "problemId": 251,
                "problemTitle": "Flatten 2D Vector",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Flatten 2D Vector problem ask you to do?",
                "back": "Problem 251: Flatten 2D Vector - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2512,
                "problemId": 251,
                "problemTitle": "Flatten 2D Vector",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Flatten 2D Vector?",
                "back": "Algorithm: function solve251():\n    // Algorithm approach for Flatten 2D Vector\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: I...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2513,
                "problemId": 251,
                "problemTitle": "Flatten 2D Vector",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Flatten 2D Vector solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2514,
                "problemId": 251,
                "problemTitle": "Flatten 2D Vector",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Flatten 2D Vector solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2515,
                "problemId": 251,
                "problemTitle": "Flatten 2D Vector",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Flatten 2D Vector?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2516,
                "problemId": 251,
                "problemTitle": "Flatten 2D Vector",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Flatten 2D Vector in Python?",
                "back": "```python\ndef solve_251():\n    # Algorithm approach for Flatten 2D Vector\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2517,
                "problemId": 251,
                "problemTitle": "Flatten 2D Vector",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Flatten 2D Vector?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2518,
                "problemId": 251,
                "problemTitle": "Flatten 2D Vector",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Flatten 2D Vector",
                "back": "Input: Input for Flatten 2D Vector\nOutput: Expected output for Flatten 2D Vector\nExplanation: Explanation of how to solve Flatten 2D Vector",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2521,
                "problemId": 252,
                "problemTitle": "Meeting Rooms",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Meeting Rooms problem ask you to do?",
                "back": "Problem 252: Meeting Rooms - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2522,
                "problemId": 252,
                "problemTitle": "Meeting Rooms",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Meeting Rooms?",
                "back": "Algorithm: function solve252():\n    // Algorithm approach for Meeting Rooms\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initi...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2523,
                "problemId": 252,
                "problemTitle": "Meeting Rooms",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Meeting Rooms solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2524,
                "problemId": 252,
                "problemTitle": "Meeting Rooms",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Meeting Rooms solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2525,
                "problemId": 252,
                "problemTitle": "Meeting Rooms",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Meeting Rooms?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2526,
                "problemId": 252,
                "problemTitle": "Meeting Rooms",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Meeting Rooms in Python?",
                "back": "```python\ndef solve_252():\n    # Algorithm approach for Meeting Rooms\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2527,
                "problemId": 252,
                "problemTitle": "Meeting Rooms",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Meeting Rooms?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2528,
                "problemId": 252,
                "problemTitle": "Meeting Rooms",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Meeting Rooms",
                "back": "Input: Input for Meeting Rooms\nOutput: Expected output for Meeting Rooms\nExplanation: Explanation of how to solve Meeting Rooms",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2531,
                "problemId": 253,
                "problemTitle": "Meeting Rooms II",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Meeting Rooms II problem ask you to do?",
                "back": "Problem 253: Meeting Rooms II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2532,
                "problemId": 253,
                "problemTitle": "Meeting Rooms II",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Meeting Rooms II?",
                "back": "Algorithm: function solve253():\n    // Algorithm approach for Meeting Rooms II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: In...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2533,
                "problemId": 253,
                "problemTitle": "Meeting Rooms II",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Meeting Rooms II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2534,
                "problemId": 253,
                "problemTitle": "Meeting Rooms II",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Meeting Rooms II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2535,
                "problemId": 253,
                "problemTitle": "Meeting Rooms II",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Meeting Rooms II?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2536,
                "problemId": 253,
                "problemTitle": "Meeting Rooms II",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Meeting Rooms II in Python?",
                "back": "```python\ndef solve_253():\n    # Algorithm approach for Meeting Rooms II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2537,
                "problemId": 253,
                "problemTitle": "Meeting Rooms II",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Meeting Rooms II?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2538,
                "problemId": 253,
                "problemTitle": "Meeting Rooms II",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Meeting Rooms II",
                "back": "Input: Input for Meeting Rooms II\nOutput: Expected output for Meeting Rooms II\nExplanation: Explanation of how to solve Meeting Rooms II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2541,
                "problemId": 254,
                "problemTitle": "Factor Combinations",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Factor Combinations problem ask you to do?",
                "back": "Problem 254: Factor Combinations - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2542,
                "problemId": 254,
                "problemTitle": "Factor Combinations",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Factor Combinations?",
                "back": "Algorithm: function solve254():\n    // Algorithm approach for Factor Combinations\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2:...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2543,
                "problemId": 254,
                "problemTitle": "Factor Combinations",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Factor Combinations solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2544,
                "problemId": 254,
                "problemTitle": "Factor Combinations",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Factor Combinations solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2545,
                "problemId": 254,
                "problemTitle": "Factor Combinations",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Factor Combinations?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2546,
                "problemId": 254,
                "problemTitle": "Factor Combinations",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Factor Combinations in Python?",
                "back": "```python\ndef solve_254():\n    # Algorithm approach for Factor Combinations\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2547,
                "problemId": 254,
                "problemTitle": "Factor Combinations",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Factor Combinations?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2548,
                "problemId": 254,
                "problemTitle": "Factor Combinations",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Factor Combinations",
                "back": "Input: Input for Factor Combinations\nOutput: Expected output for Factor Combinations\nExplanation: Explanation of how to solve Factor Combinations",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2551,
                "problemId": 255,
                "problemTitle": "Verify Preorder Sequence in Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Verify Preorder Sequence in Binary Search Tree problem ask you to do?",
                "back": "Problem 255: Verify Preorder Sequence in Binary Search Tree - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2552,
                "problemId": 255,
                "problemTitle": "Verify Preorder Sequence in Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Verify Preorder Sequence in Binary Search Tree?",
                "back": "Algorithm: function solve255():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2553,
                "problemId": 255,
                "problemTitle": "Verify Preorder Sequence in Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Verify Preorder Sequence in Binary Search Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2554,
                "problemId": 255,
                "problemTitle": "Verify Preorder Sequence in Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Verify Preorder Sequence in Binary Search Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2555,
                "problemId": 255,
                "problemTitle": "Verify Preorder Sequence in Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Verify Preorder Sequence in Binary Search Tree?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2556,
                "problemId": 255,
                "problemTitle": "Verify Preorder Sequence in Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Verify Preorder Sequence in Binary Search Tree in Python?",
                "back": "```python\ndef solve_255():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2557,
                "problemId": 255,
                "problemTitle": "Verify Preorder Sequence in Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Verify Preorder Sequence in Binary Search Tree?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2558,
                "problemId": 255,
                "problemTitle": "Verify Preorder Sequence in Binary Search Tree",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Verify Preorder Sequence in Binary Search Tree",
                "back": "Input: Input for Verify Preorder Sequence in Binary Search Tree\nOutput: Expected output for Verify Preorder Sequence in Binary Search Tree\nExplanation: Explanation of how to solve Verify Preorder Sequence in Binary Search Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2561,
                "problemId": 256,
                "problemTitle": "Paint House",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Paint House problem ask you to do?",
                "back": "Problem 256: Paint House - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2562,
                "problemId": 256,
                "problemTitle": "Paint House",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Paint House?",
                "back": "Algorithm: function solve256():\n    // Algorithm approach for Paint House\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initial...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2563,
                "problemId": 256,
                "problemTitle": "Paint House",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Paint House solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2564,
                "problemId": 256,
                "problemTitle": "Paint House",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Paint House solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2565,
                "problemId": 256,
                "problemTitle": "Paint House",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Paint House?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2566,
                "problemId": 256,
                "problemTitle": "Paint House",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Paint House in Python?",
                "back": "```python\ndef solve_256():\n    # Algorithm approach for Paint House\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2567,
                "problemId": 256,
                "problemTitle": "Paint House",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Paint House?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2568,
                "problemId": 256,
                "problemTitle": "Paint House",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Paint House",
                "back": "Input: Input for Paint House\nOutput: Expected output for Paint House\nExplanation: Explanation of how to solve Paint House",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2571,
                "problemId": 257,
                "problemTitle": "Binary Tree Paths",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Binary Tree Paths problem ask you to do?",
                "back": "Problem 257: Binary Tree Paths - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2572,
                "problemId": 257,
                "problemTitle": "Binary Tree Paths",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Tree Paths?",
                "back": "Algorithm: function solve257():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2573,
                "problemId": 257,
                "problemTitle": "Binary Tree Paths",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Tree Paths solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2574,
                "problemId": 257,
                "problemTitle": "Binary Tree Paths",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Tree Paths solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2575,
                "problemId": 257,
                "problemTitle": "Binary Tree Paths",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Tree Paths?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2576,
                "problemId": 257,
                "problemTitle": "Binary Tree Paths",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Binary Tree Paths in Python?",
                "back": "```python\ndef solve_257():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2577,
                "problemId": 257,
                "problemTitle": "Binary Tree Paths",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Tree Paths?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2578,
                "problemId": 257,
                "problemTitle": "Binary Tree Paths",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Tree Paths",
                "back": "Input: Input for Binary Tree Paths\nOutput: Expected output for Binary Tree Paths\nExplanation: Explanation of how to solve Binary Tree Paths",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2581,
                "problemId": 258,
                "problemTitle": "Add Digits",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Add Digits problem ask you to do?",
                "back": "Problem 258: Add Digits - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2582,
                "problemId": 258,
                "problemTitle": "Add Digits",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Add Digits?",
                "back": "Algorithm: function solve258():\n    // Algorithm approach for Add Digits\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initiali...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2583,
                "problemId": 258,
                "problemTitle": "Add Digits",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Add Digits solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2584,
                "problemId": 258,
                "problemTitle": "Add Digits",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Add Digits solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2585,
                "problemId": 258,
                "problemTitle": "Add Digits",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Add Digits?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2586,
                "problemId": 258,
                "problemTitle": "Add Digits",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Add Digits in Python?",
                "back": "```python\ndef solve_258():\n    # Algorithm approach for Add Digits\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2587,
                "problemId": 258,
                "problemTitle": "Add Digits",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Add Digits?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2588,
                "problemId": 258,
                "problemTitle": "Add Digits",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Add Digits",
                "back": "Input: Input for Add Digits\nOutput: Expected output for Add Digits\nExplanation: Explanation of how to solve Add Digits",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2591,
                "problemId": 259,
                "problemTitle": "3Sum Smaller",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the 3Sum Smaller problem ask you to do?",
                "back": "Problem 259: 3Sum Smaller - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2592,
                "problemId": 259,
                "problemTitle": "3Sum Smaller",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve 3Sum Smaller?",
                "back": "Algorithm: function solve259():\n    // Algorithm approach for 3Sum Smaller\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initia...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2593,
                "problemId": 259,
                "problemTitle": "3Sum Smaller",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal 3Sum Smaller solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2594,
                "problemId": 259,
                "problemTitle": "3Sum Smaller",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal 3Sum Smaller solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2595,
                "problemId": 259,
                "problemTitle": "3Sum Smaller",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving 3Sum Smaller?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2596,
                "problemId": 259,
                "problemTitle": "3Sum Smaller",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement 3Sum Smaller in Python?",
                "back": "```python\ndef solve_259():\n    # Algorithm approach for 3Sum Smaller\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2597,
                "problemId": 259,
                "problemTitle": "3Sum Smaller",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for 3Sum Smaller?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2598,
                "problemId": 259,
                "problemTitle": "3Sum Smaller",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for 3Sum Smaller",
                "back": "Input: Input for 3Sum Smaller\nOutput: Expected output for 3Sum Smaller\nExplanation: Explanation of how to solve 3Sum Smaller",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2601,
                "problemId": 260,
                "problemTitle": "Single Number III",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Single Number III problem ask you to do?",
                "back": "Problem 260: Single Number III - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2602,
                "problemId": 260,
                "problemTitle": "Single Number III",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Single Number III?",
                "back": "Algorithm: function solve260():\n    // Algorithm approach for Single Number III\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: I...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2603,
                "problemId": 260,
                "problemTitle": "Single Number III",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Single Number III solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2604,
                "problemId": 260,
                "problemTitle": "Single Number III",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Single Number III solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2605,
                "problemId": 260,
                "problemTitle": "Single Number III",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Single Number III?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2606,
                "problemId": 260,
                "problemTitle": "Single Number III",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Single Number III in Python?",
                "back": "```python\ndef solve_260():\n    # Algorithm approach for Single Number III\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2607,
                "problemId": 260,
                "problemTitle": "Single Number III",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Single Number III?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2608,
                "problemId": 260,
                "problemTitle": "Single Number III",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Single Number III",
                "back": "Input: Input for Single Number III\nOutput: Expected output for Single Number III\nExplanation: Explanation of how to solve Single Number III",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2611,
                "problemId": 261,
                "problemTitle": "Graph Valid Tree",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Graph Valid Tree problem ask you to do?",
                "back": "Problem 261: Graph Valid Tree - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2612,
                "problemId": 261,
                "problemTitle": "Graph Valid Tree",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Graph Valid Tree?",
                "back": "Algorithm: function solve261():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2613,
                "problemId": 261,
                "problemTitle": "Graph Valid Tree",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Graph Valid Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2614,
                "problemId": 261,
                "problemTitle": "Graph Valid Tree",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Graph Valid Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2615,
                "problemId": 261,
                "problemTitle": "Graph Valid Tree",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Graph Valid Tree?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2616,
                "problemId": 261,
                "problemTitle": "Graph Valid Tree",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Graph Valid Tree in Python?",
                "back": "```python\ndef solve_261():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2617,
                "problemId": 261,
                "problemTitle": "Graph Valid Tree",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Graph Valid Tree?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2618,
                "problemId": 261,
                "problemTitle": "Graph Valid Tree",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Graph Valid Tree",
                "back": "Input: Input for Graph Valid Tree\nOutput: Expected output for Graph Valid Tree\nExplanation: Explanation of how to solve Graph Valid Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2621,
                "problemId": 262,
                "problemTitle": "Trips and Users",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Trips and Users problem ask you to do?",
                "back": "Problem 262: Trips and Users - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2622,
                "problemId": 262,
                "problemTitle": "Trips and Users",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Trips and Users?",
                "back": "Algorithm: function solve262():\n    // Algorithm approach for Trips and Users\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Ini...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2623,
                "problemId": 262,
                "problemTitle": "Trips and Users",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Trips and Users solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2624,
                "problemId": 262,
                "problemTitle": "Trips and Users",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Trips and Users solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2625,
                "problemId": 262,
                "problemTitle": "Trips and Users",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Trips and Users?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2626,
                "problemId": 262,
                "problemTitle": "Trips and Users",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Trips and Users in Python?",
                "back": "```python\ndef solve_262():\n    # Algorithm approach for Trips and Users\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2627,
                "problemId": 262,
                "problemTitle": "Trips and Users",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Trips and Users?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2628,
                "problemId": 262,
                "problemTitle": "Trips and Users",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Trips and Users",
                "back": "Input: Input for Trips and Users\nOutput: Expected output for Trips and Users\nExplanation: Explanation of how to solve Trips and Users",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2631,
                "problemId": 263,
                "problemTitle": "Ugly Number",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Ugly Number problem ask you to do?",
                "back": "Problem 263: Ugly Number - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2632,
                "problemId": 263,
                "problemTitle": "Ugly Number",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Ugly Number?",
                "back": "Algorithm: function solve263():\n    // Algorithm approach for Ugly Number\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initial...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2633,
                "problemId": 263,
                "problemTitle": "Ugly Number",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Ugly Number solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2634,
                "problemId": 263,
                "problemTitle": "Ugly Number",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Ugly Number solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2635,
                "problemId": 263,
                "problemTitle": "Ugly Number",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Ugly Number?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2636,
                "problemId": 263,
                "problemTitle": "Ugly Number",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Ugly Number in Python?",
                "back": "```python\ndef solve_263():\n    # Algorithm approach for Ugly Number\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2637,
                "problemId": 263,
                "problemTitle": "Ugly Number",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Ugly Number?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2638,
                "problemId": 263,
                "problemTitle": "Ugly Number",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Ugly Number",
                "back": "Input: Input for Ugly Number\nOutput: Expected output for Ugly Number\nExplanation: Explanation of how to solve Ugly Number",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2641,
                "problemId": 264,
                "problemTitle": "Ugly Number II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Ugly Number II problem ask you to do?",
                "back": "Find nth ugly number using dynamic programming approach.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2642,
                "problemId": 264,
                "problemTitle": "Ugly Number II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Ugly Number II?",
                "back": "Three pointers approach\nMultiply by 2, 3, 5",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2643,
                "problemId": 264,
                "problemTitle": "Ugly Number II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Ugly Number II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2644,
                "problemId": 264,
                "problemTitle": "Ugly Number II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Ugly Number II solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2645,
                "problemId": 264,
                "problemTitle": "Ugly Number II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Ugly Number II?",
                "back": "Three pointers. Multiply factors. DP approach",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2646,
                "problemId": 264,
                "problemTitle": "Ugly Number II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Ugly Number II in Python?",
                "back": "```python\nThree pointers DP\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2647,
                "problemId": 264,
                "problemTitle": "Ugly Number II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Ugly Number II?",
                "back": "Tags: Hash Table, Math, Dynamic Programming. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2648,
                "problemId": 264,
                "problemTitle": "Ugly Number II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Ugly Number II",
                "back": "Input: n = 10\nOutput: 12\nExplanation: 10th ugly number is 12.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2651,
                "problemId": 265,
                "problemTitle": "Paint House II",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Paint House II problem ask you to do?",
                "back": "Problem 265: Paint House II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2652,
                "problemId": 265,
                "problemTitle": "Paint House II",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Paint House II?",
                "back": "Algorithm: function solve265():\n    // Algorithm approach for Paint House II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Init...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2653,
                "problemId": 265,
                "problemTitle": "Paint House II",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Paint House II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2654,
                "problemId": 265,
                "problemTitle": "Paint House II",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Paint House II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2655,
                "problemId": 265,
                "problemTitle": "Paint House II",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Paint House II?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2656,
                "problemId": 265,
                "problemTitle": "Paint House II",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Paint House II in Python?",
                "back": "```python\ndef solve_265():\n    # Algorithm approach for Paint House II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2657,
                "problemId": 265,
                "problemTitle": "Paint House II",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Paint House II?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2658,
                "problemId": 265,
                "problemTitle": "Paint House II",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Paint House II",
                "back": "Input: Input for Paint House II\nOutput: Expected output for Paint House II\nExplanation: Explanation of how to solve Paint House II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2661,
                "problemId": 266,
                "problemTitle": "Palindrome Permutation",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Palindrome Permutation problem ask you to do?",
                "back": "Problem 266: Palindrome Permutation - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2662,
                "problemId": 266,
                "problemTitle": "Palindrome Permutation",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Palindrome Permutation?",
                "back": "Algorithm: function solve266():\n    // Algorithm approach for Palindrome Permutation\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2663,
                "problemId": 266,
                "problemTitle": "Palindrome Permutation",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Palindrome Permutation solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2664,
                "problemId": 266,
                "problemTitle": "Palindrome Permutation",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Palindrome Permutation solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2665,
                "problemId": 266,
                "problemTitle": "Palindrome Permutation",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Palindrome Permutation?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2666,
                "problemId": 266,
                "problemTitle": "Palindrome Permutation",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Palindrome Permutation in Python?",
                "back": "```python\ndef solve_266():\n    # Algorithm approach for Palindrome Permutation\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2667,
                "problemId": 266,
                "problemTitle": "Palindrome Permutation",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Palindrome Permutation?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2668,
                "problemId": 266,
                "problemTitle": "Palindrome Permutation",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Palindrome Permutation",
                "back": "Input: Input for Palindrome Permutation\nOutput: Expected output for Palindrome Permutation\nExplanation: Explanation of how to solve Palindrome Permutation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2671,
                "problemId": 267,
                "problemTitle": "Palindrome Permutation II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Palindrome Permutation II problem ask you to do?",
                "back": "Problem 267: Palindrome Permutation II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2672,
                "problemId": 267,
                "problemTitle": "Palindrome Permutation II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Palindrome Permutation II?",
                "back": "Algorithm: function solve267():\n    // Algorithm approach for Palindrome Permutation II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // S...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2673,
                "problemId": 267,
                "problemTitle": "Palindrome Permutation II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Palindrome Permutation II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2674,
                "problemId": 267,
                "problemTitle": "Palindrome Permutation II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Palindrome Permutation II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2675,
                "problemId": 267,
                "problemTitle": "Palindrome Permutation II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Palindrome Permutation II?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2676,
                "problemId": 267,
                "problemTitle": "Palindrome Permutation II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Palindrome Permutation II in Python?",
                "back": "```python\ndef solve_267():\n    # Algorithm approach for Palindrome Permutation II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2677,
                "problemId": 267,
                "problemTitle": "Palindrome Permutation II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Palindrome Permutation II?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2678,
                "problemId": 267,
                "problemTitle": "Palindrome Permutation II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Palindrome Permutation II",
                "back": "Input: Input for Palindrome Permutation II\nOutput: Expected output for Palindrome Permutation II\nExplanation: Explanation of how to solve Palindrome Permutation II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2681,
                "problemId": 268,
                "problemTitle": "Missing Number",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Missing Number problem ask you to do?",
                "back": "Problem 268: Missing Number - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2682,
                "problemId": 268,
                "problemTitle": "Missing Number",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Missing Number?",
                "back": "Algorithm: function solve268():\n    // Algorithm approach for Missing Number\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Init...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2683,
                "problemId": 268,
                "problemTitle": "Missing Number",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Missing Number solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2684,
                "problemId": 268,
                "problemTitle": "Missing Number",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Missing Number solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2685,
                "problemId": 268,
                "problemTitle": "Missing Number",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Missing Number?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2686,
                "problemId": 268,
                "problemTitle": "Missing Number",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Missing Number in Python?",
                "back": "```python\ndef solve_268():\n    # Algorithm approach for Missing Number\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2687,
                "problemId": 268,
                "problemTitle": "Missing Number",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Missing Number?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2688,
                "problemId": 268,
                "problemTitle": "Missing Number",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Missing Number",
                "back": "Input: Input for Missing Number\nOutput: Expected output for Missing Number\nExplanation: Explanation of how to solve Missing Number",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2691,
                "problemId": 269,
                "problemTitle": "Alien Dictionary",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Alien Dictionary problem ask you to do?",
                "back": "Problem 269: Alien Dictionary - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2692,
                "problemId": 269,
                "problemTitle": "Alien Dictionary",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Alien Dictionary?",
                "back": "Algorithm: function solve269():\n    // Algorithm approach for Alien Dictionary\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: In...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2693,
                "problemId": 269,
                "problemTitle": "Alien Dictionary",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Alien Dictionary solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2694,
                "problemId": 269,
                "problemTitle": "Alien Dictionary",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Alien Dictionary solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2695,
                "problemId": 269,
                "problemTitle": "Alien Dictionary",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Alien Dictionary?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2696,
                "problemId": 269,
                "problemTitle": "Alien Dictionary",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Alien Dictionary in Python?",
                "back": "```python\ndef solve_269():\n    # Algorithm approach for Alien Dictionary\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2697,
                "problemId": 269,
                "problemTitle": "Alien Dictionary",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Alien Dictionary?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2698,
                "problemId": 269,
                "problemTitle": "Alien Dictionary",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Alien Dictionary",
                "back": "Input: Input for Alien Dictionary\nOutput: Expected output for Alien Dictionary\nExplanation: Explanation of how to solve Alien Dictionary",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2701,
                "problemId": 270,
                "problemTitle": "Closest Binary Search Tree Value",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Closest Binary Search Tree Value problem ask you to do?",
                "back": "Problem 270: Closest Binary Search Tree Value - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2702,
                "problemId": 270,
                "problemTitle": "Closest Binary Search Tree Value",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Closest Binary Search Tree Value?",
                "back": "Algorithm: function solve270():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2703,
                "problemId": 270,
                "problemTitle": "Closest Binary Search Tree Value",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Closest Binary Search Tree Value solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2704,
                "problemId": 270,
                "problemTitle": "Closest Binary Search Tree Value",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Closest Binary Search Tree Value solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2705,
                "problemId": 270,
                "problemTitle": "Closest Binary Search Tree Value",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Closest Binary Search Tree Value?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2706,
                "problemId": 270,
                "problemTitle": "Closest Binary Search Tree Value",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Closest Binary Search Tree Value in Python?",
                "back": "```python\ndef solve_270():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2707,
                "problemId": 270,
                "problemTitle": "Closest Binary Search Tree Value",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Closest Binary Search Tree Value?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2708,
                "problemId": 270,
                "problemTitle": "Closest Binary Search Tree Value",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Closest Binary Search Tree Value",
                "back": "Input: Input for Closest Binary Search Tree Value\nOutput: Expected output for Closest Binary Search Tree Value\nExplanation: Explanation of how to solve Closest Binary Search Tree Value",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2711,
                "problemId": 271,
                "problemTitle": "Encode and Decode Strings",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Encode and Decode Strings problem ask you to do?",
                "back": "Problem 271: Encode and Decode Strings - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2712,
                "problemId": 271,
                "problemTitle": "Encode and Decode Strings",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Encode and Decode Strings?",
                "back": "Algorithm: function solve271():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2713,
                "problemId": 271,
                "problemTitle": "Encode and Decode Strings",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Encode and Decode Strings solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2714,
                "problemId": 271,
                "problemTitle": "Encode and Decode Strings",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Encode and Decode Strings solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2715,
                "problemId": 271,
                "problemTitle": "Encode and Decode Strings",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Encode and Decode Strings?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2716,
                "problemId": 271,
                "problemTitle": "Encode and Decode Strings",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Encode and Decode Strings in Python?",
                "back": "```python\ndef solve_271():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2717,
                "problemId": 271,
                "problemTitle": "Encode and Decode Strings",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Encode and Decode Strings?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2718,
                "problemId": 271,
                "problemTitle": "Encode and Decode Strings",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Encode and Decode Strings",
                "back": "Input: Input for Encode and Decode Strings\nOutput: Expected output for Encode and Decode Strings\nExplanation: Explanation of how to solve Encode and Decode Strings",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2721,
                "problemId": 272,
                "problemTitle": "Closest Binary Search Tree Value II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Closest Binary Search Tree Value II problem ask you to do?",
                "back": "Problem 272: Closest Binary Search Tree Value II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2722,
                "problemId": 272,
                "problemTitle": "Closest Binary Search Tree Value II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Closest Binary Search Tree Value II?",
                "back": "Algorithm: function solve272():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2723,
                "problemId": 272,
                "problemTitle": "Closest Binary Search Tree Value II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Closest Binary Search Tree Value II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2724,
                "problemId": 272,
                "problemTitle": "Closest Binary Search Tree Value II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Closest Binary Search Tree Value II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2725,
                "problemId": 272,
                "problemTitle": "Closest Binary Search Tree Value II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Closest Binary Search Tree Value II?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2726,
                "problemId": 272,
                "problemTitle": "Closest Binary Search Tree Value II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Closest Binary Search Tree Value II in Python?",
                "back": "```python\ndef solve_272():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2727,
                "problemId": 272,
                "problemTitle": "Closest Binary Search Tree Value II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Closest Binary Search Tree Value II?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2728,
                "problemId": 272,
                "problemTitle": "Closest Binary Search Tree Value II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Closest Binary Search Tree Value II",
                "back": "Input: Input for Closest Binary Search Tree Value II\nOutput: Expected output for Closest Binary Search Tree Value II\nExplanation: Explanation of how to solve Closest Binary Search Tree Value II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2731,
                "problemId": 273,
                "problemTitle": "Integer to English Words",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Integer to English Words problem ask you to do?",
                "back": "Problem 273: Integer to English Words - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2732,
                "problemId": 273,
                "problemTitle": "Integer to English Words",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Integer to English Words?",
                "back": "Algorithm: function solve273():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2733,
                "problemId": 273,
                "problemTitle": "Integer to English Words",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Integer to English Words solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2734,
                "problemId": 273,
                "problemTitle": "Integer to English Words",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Integer to English Words solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2735,
                "problemId": 273,
                "problemTitle": "Integer to English Words",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Integer to English Words?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2736,
                "problemId": 273,
                "problemTitle": "Integer to English Words",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Integer to English Words in Python?",
                "back": "```python\ndef solve_273():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2737,
                "problemId": 273,
                "problemTitle": "Integer to English Words",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Integer to English Words?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2738,
                "problemId": 273,
                "problemTitle": "Integer to English Words",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Integer to English Words",
                "back": "Input: Input for Integer to English Words\nOutput: Expected output for Integer to English Words\nExplanation: Explanation of how to solve Integer to English Words",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2741,
                "problemId": 274,
                "problemTitle": "H-Index",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the H-Index problem ask you to do?",
                "back": "Problem 274: H-Index - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2742,
                "problemId": 274,
                "problemTitle": "H-Index",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve H-Index?",
                "back": "Algorithm: function solve274():\n    // Algorithm approach for H-Index\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initialize ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2743,
                "problemId": 274,
                "problemTitle": "H-Index",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal H-Index solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2744,
                "problemId": 274,
                "problemTitle": "H-Index",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal H-Index solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2745,
                "problemId": 274,
                "problemTitle": "H-Index",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving H-Index?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2746,
                "problemId": 274,
                "problemTitle": "H-Index",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement H-Index in Python?",
                "back": "```python\ndef solve_274():\n    # Algorithm approach for H-Index\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2747,
                "problemId": 274,
                "problemTitle": "H-Index",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for H-Index?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2748,
                "problemId": 274,
                "problemTitle": "H-Index",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for H-Index",
                "back": "Input: Input for H-Index\nOutput: Expected output for H-Index\nExplanation: Explanation of how to solve H-Index",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2751,
                "problemId": 275,
                "problemTitle": "H-Index II",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the H-Index II problem ask you to do?",
                "back": "Problem 275: H-Index II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2752,
                "problemId": 275,
                "problemTitle": "H-Index II",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve H-Index II?",
                "back": "Algorithm: function solve275():\n    // Algorithm approach for H-Index II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initiali...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2753,
                "problemId": 275,
                "problemTitle": "H-Index II",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal H-Index II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2754,
                "problemId": 275,
                "problemTitle": "H-Index II",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal H-Index II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2755,
                "problemId": 275,
                "problemTitle": "H-Index II",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving H-Index II?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2756,
                "problemId": 275,
                "problemTitle": "H-Index II",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement H-Index II in Python?",
                "back": "```python\ndef solve_275():\n    # Algorithm approach for H-Index II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2757,
                "problemId": 275,
                "problemTitle": "H-Index II",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for H-Index II?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2758,
                "problemId": 275,
                "problemTitle": "H-Index II",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for H-Index II",
                "back": "Input: Input for H-Index II\nOutput: Expected output for H-Index II\nExplanation: Explanation of how to solve H-Index II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2761,
                "problemId": 276,
                "problemTitle": "Paint Fence",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Paint Fence problem ask you to do?",
                "back": "Problem 276: Paint Fence - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2762,
                "problemId": 276,
                "problemTitle": "Paint Fence",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Paint Fence?",
                "back": "Algorithm: function solve276():\n    // Algorithm approach for Paint Fence\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initial...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2763,
                "problemId": 276,
                "problemTitle": "Paint Fence",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Paint Fence solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2764,
                "problemId": 276,
                "problemTitle": "Paint Fence",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Paint Fence solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2765,
                "problemId": 276,
                "problemTitle": "Paint Fence",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Paint Fence?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2766,
                "problemId": 276,
                "problemTitle": "Paint Fence",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Paint Fence in Python?",
                "back": "```python\ndef solve_276():\n    # Algorithm approach for Paint Fence\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2767,
                "problemId": 276,
                "problemTitle": "Paint Fence",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Paint Fence?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2768,
                "problemId": 276,
                "problemTitle": "Paint Fence",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Paint Fence",
                "back": "Input: Input for Paint Fence\nOutput: Expected output for Paint Fence\nExplanation: Explanation of how to solve Paint Fence",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2771,
                "problemId": 277,
                "problemTitle": "Find the Celebrity",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Find the Celebrity problem ask you to do?",
                "back": "Problem 277: Find the Celebrity - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2772,
                "problemId": 277,
                "problemTitle": "Find the Celebrity",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Find the Celebrity?",
                "back": "Algorithm: function solve277():\n    // Algorithm approach for Find the Celebrity\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2773,
                "problemId": 277,
                "problemTitle": "Find the Celebrity",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Find the Celebrity solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2774,
                "problemId": 277,
                "problemTitle": "Find the Celebrity",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Find the Celebrity solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2775,
                "problemId": 277,
                "problemTitle": "Find the Celebrity",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Find the Celebrity?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2776,
                "problemId": 277,
                "problemTitle": "Find the Celebrity",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Find the Celebrity in Python?",
                "back": "```python\ndef solve_277():\n    # Algorithm approach for Find the Celebrity\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2777,
                "problemId": 277,
                "problemTitle": "Find the Celebrity",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Find the Celebrity?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2778,
                "problemId": 277,
                "problemTitle": "Find the Celebrity",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Find the Celebrity",
                "back": "Input: Input for Find the Celebrity\nOutput: Expected output for Find the Celebrity\nExplanation: Explanation of how to solve Find the Celebrity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2781,
                "problemId": 278,
                "problemTitle": "First Bad Version",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the First Bad Version problem ask you to do?",
                "back": "Problem 278: First Bad Version - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2782,
                "problemId": 278,
                "problemTitle": "First Bad Version",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve First Bad Version?",
                "back": "Algorithm: function solve278():\n    // Algorithm approach for First Bad Version\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: I...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2783,
                "problemId": 278,
                "problemTitle": "First Bad Version",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal First Bad Version solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2784,
                "problemId": 278,
                "problemTitle": "First Bad Version",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal First Bad Version solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2785,
                "problemId": 278,
                "problemTitle": "First Bad Version",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving First Bad Version?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2786,
                "problemId": 278,
                "problemTitle": "First Bad Version",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement First Bad Version in Python?",
                "back": "```python\ndef solve_278():\n    # Algorithm approach for First Bad Version\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2787,
                "problemId": 278,
                "problemTitle": "First Bad Version",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for First Bad Version?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2788,
                "problemId": 278,
                "problemTitle": "First Bad Version",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for First Bad Version",
                "back": "Input: Input for First Bad Version\nOutput: Expected output for First Bad Version\nExplanation: Explanation of how to solve First Bad Version",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2791,
                "problemId": 279,
                "problemTitle": "Perfect Squares",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Perfect Squares problem ask you to do?",
                "back": "Find minimum number of perfect squares that sum to n using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2792,
                "problemId": 279,
                "problemTitle": "Perfect Squares",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Perfect Squares?",
                "back": "DP array for minimum squares\nCheck all perfect squares",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2793,
                "problemId": 279,
                "problemTitle": "Perfect Squares",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Perfect Squares solution?",
                "back": "O(n\u221an) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2794,
                "problemId": 279,
                "problemTitle": "Perfect Squares",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Perfect Squares solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2795,
                "problemId": 279,
                "problemTitle": "Perfect Squares",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Perfect Squares?",
                "back": "DP array. Perfect squares. Minimum count",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2796,
                "problemId": 279,
                "problemTitle": "Perfect Squares",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Perfect Squares in Python?",
                "back": "```python\nDP approach\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2797,
                "problemId": 279,
                "problemTitle": "Perfect Squares",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Perfect Squares?",
                "back": "Tags: Math, Dynamic Programming, Breadth-First Search. This problem focuses on Math algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2798,
                "problemId": 279,
                "problemTitle": "Perfect Squares",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Perfect Squares",
                "back": "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2801,
                "problemId": 280,
                "problemTitle": "Wiggle Sort",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Wiggle Sort problem ask you to do?",
                "back": "Problem 280: Wiggle Sort - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2802,
                "problemId": 280,
                "problemTitle": "Wiggle Sort",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Wiggle Sort?",
                "back": "Algorithm: function solve280():\n    // Array manipulation approach\n    if nums.length < 2:\n        return nums\n    \n    // Sort the array first\n    nums.sort()\n    \n    // Process the sorted array\n    for i = 0 ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2803,
                "problemId": 280,
                "problemTitle": "Wiggle Sort",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Wiggle Sort solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2804,
                "problemId": 280,
                "problemTitle": "Wiggle Sort",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Wiggle Sort solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2805,
                "problemId": 280,
                "problemTitle": "Wiggle Sort",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Wiggle Sort?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2806,
                "problemId": 280,
                "problemTitle": "Wiggle Sort",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Wiggle Sort in Python?",
                "back": "```python\ndef solve_280():\n    # Array manipulation approach\n    if len(nums) < 2:\n        return nums\n    \n    # Sort the array first\n    nums.sort()\n    \n    # Process the sorted array\n    for i in range(len(nums)):\n        # Your logic here\n        pass\n    \n    return nums\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2807,
                "problemId": 280,
                "problemTitle": "Wiggle Sort",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Wiggle Sort?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2808,
                "problemId": 280,
                "problemTitle": "Wiggle Sort",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Wiggle Sort",
                "back": "Input: Input for Wiggle Sort\nOutput: Expected output for Wiggle Sort\nExplanation: Explanation of how to solve Wiggle Sort",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2811,
                "problemId": 281,
                "problemTitle": "Zigzag Iterator",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Zigzag Iterator problem ask you to do?",
                "back": "Problem 281: Zigzag Iterator - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2812,
                "problemId": 281,
                "problemTitle": "Zigzag Iterator",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Zigzag Iterator?",
                "back": "Algorithm: function solve281():\n    // Algorithm approach for Zigzag Iterator\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Ini...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2813,
                "problemId": 281,
                "problemTitle": "Zigzag Iterator",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Zigzag Iterator solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2814,
                "problemId": 281,
                "problemTitle": "Zigzag Iterator",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Zigzag Iterator solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2815,
                "problemId": 281,
                "problemTitle": "Zigzag Iterator",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Zigzag Iterator?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2816,
                "problemId": 281,
                "problemTitle": "Zigzag Iterator",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Zigzag Iterator in Python?",
                "back": "```python\ndef solve_281():\n    # Algorithm approach for Zigzag Iterator\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2817,
                "problemId": 281,
                "problemTitle": "Zigzag Iterator",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Zigzag Iterator?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2818,
                "problemId": 281,
                "problemTitle": "Zigzag Iterator",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Zigzag Iterator",
                "back": "Input: Input for Zigzag Iterator\nOutput: Expected output for Zigzag Iterator\nExplanation: Explanation of how to solve Zigzag Iterator",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2821,
                "problemId": 282,
                "problemTitle": "Expression Add Operators",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Expression Add Operators problem ask you to do?",
                "back": "Problem 282: Expression Add Operators - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2822,
                "problemId": 282,
                "problemTitle": "Expression Add Operators",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Expression Add Operators?",
                "back": "Algorithm: function solve282():\n    // Algorithm approach for Expression Add Operators\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // St...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2823,
                "problemId": 282,
                "problemTitle": "Expression Add Operators",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Expression Add Operators solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2824,
                "problemId": 282,
                "problemTitle": "Expression Add Operators",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Expression Add Operators solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2825,
                "problemId": 282,
                "problemTitle": "Expression Add Operators",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Expression Add Operators?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2826,
                "problemId": 282,
                "problemTitle": "Expression Add Operators",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Expression Add Operators in Python?",
                "back": "```python\ndef solve_282():\n    # Algorithm approach for Expression Add Operators\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2827,
                "problemId": 282,
                "problemTitle": "Expression Add Operators",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Expression Add Operators?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2828,
                "problemId": 282,
                "problemTitle": "Expression Add Operators",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Expression Add Operators",
                "back": "Input: Input for Expression Add Operators\nOutput: Expected output for Expression Add Operators\nExplanation: Explanation of how to solve Expression Add Operators",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2831,
                "problemId": 283,
                "problemTitle": "Move Zeroes",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Move Zeroes problem ask you to do?",
                "back": "Problem 283: Move Zeroes - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2832,
                "problemId": 283,
                "problemTitle": "Move Zeroes",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Move Zeroes?",
                "back": "Algorithm: function solve283():\n    // Algorithm approach for Move Zeroes\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initial...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2833,
                "problemId": 283,
                "problemTitle": "Move Zeroes",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Move Zeroes solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2834,
                "problemId": 283,
                "problemTitle": "Move Zeroes",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Move Zeroes solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2835,
                "problemId": 283,
                "problemTitle": "Move Zeroes",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Move Zeroes?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2836,
                "problemId": 283,
                "problemTitle": "Move Zeroes",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Move Zeroes in Python?",
                "back": "```python\ndef solve_283():\n    # Algorithm approach for Move Zeroes\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2837,
                "problemId": 283,
                "problemTitle": "Move Zeroes",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Move Zeroes?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2838,
                "problemId": 283,
                "problemTitle": "Move Zeroes",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Move Zeroes",
                "back": "Input: Input for Move Zeroes\nOutput: Expected output for Move Zeroes\nExplanation: Explanation of how to solve Move Zeroes",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2841,
                "problemId": 284,
                "problemTitle": "Peeking Iterator",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Peeking Iterator problem ask you to do?",
                "back": "Problem 284: Peeking Iterator - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2842,
                "problemId": 284,
                "problemTitle": "Peeking Iterator",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Peeking Iterator?",
                "back": "Algorithm: function solve284():\n    // Algorithm approach for Peeking Iterator\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: In...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2843,
                "problemId": 284,
                "problemTitle": "Peeking Iterator",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Peeking Iterator solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2844,
                "problemId": 284,
                "problemTitle": "Peeking Iterator",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Peeking Iterator solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2845,
                "problemId": 284,
                "problemTitle": "Peeking Iterator",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Peeking Iterator?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2846,
                "problemId": 284,
                "problemTitle": "Peeking Iterator",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Peeking Iterator in Python?",
                "back": "```python\ndef solve_284():\n    # Algorithm approach for Peeking Iterator\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2847,
                "problemId": 284,
                "problemTitle": "Peeking Iterator",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Peeking Iterator?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2848,
                "problemId": 284,
                "problemTitle": "Peeking Iterator",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Peeking Iterator",
                "back": "Input: Input for Peeking Iterator\nOutput: Expected output for Peeking Iterator\nExplanation: Explanation of how to solve Peeking Iterator",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2851,
                "problemId": 285,
                "problemTitle": "Inorder Successor in BST",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Inorder Successor in BST problem ask you to do?",
                "back": "Problem 285: Inorder Successor in BST - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2852,
                "problemId": 285,
                "problemTitle": "Inorder Successor in BST",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Inorder Successor in BST?",
                "back": "Algorithm: function solve285():\n    // Algorithm approach for Inorder Successor in BST\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // St...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2853,
                "problemId": 285,
                "problemTitle": "Inorder Successor in BST",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Inorder Successor in BST solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2854,
                "problemId": 285,
                "problemTitle": "Inorder Successor in BST",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Inorder Successor in BST solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2855,
                "problemId": 285,
                "problemTitle": "Inorder Successor in BST",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Inorder Successor in BST?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2856,
                "problemId": 285,
                "problemTitle": "Inorder Successor in BST",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Inorder Successor in BST in Python?",
                "back": "```python\ndef solve_285():\n    # Algorithm approach for Inorder Successor in BST\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2857,
                "problemId": 285,
                "problemTitle": "Inorder Successor in BST",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Inorder Successor in BST?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2858,
                "problemId": 285,
                "problemTitle": "Inorder Successor in BST",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Inorder Successor in BST",
                "back": "Input: Input for Inorder Successor in BST\nOutput: Expected output for Inorder Successor in BST\nExplanation: Explanation of how to solve Inorder Successor in BST",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2861,
                "problemId": 286,
                "problemTitle": "Walls and Gates",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Walls and Gates problem ask you to do?",
                "back": "Problem 286: Walls and Gates - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2862,
                "problemId": 286,
                "problemTitle": "Walls and Gates",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Walls and Gates?",
                "back": "Algorithm: function solve286():\n    // Algorithm approach for Walls and Gates\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Ini...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2863,
                "problemId": 286,
                "problemTitle": "Walls and Gates",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Walls and Gates solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2864,
                "problemId": 286,
                "problemTitle": "Walls and Gates",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Walls and Gates solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2865,
                "problemId": 286,
                "problemTitle": "Walls and Gates",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Walls and Gates?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2866,
                "problemId": 286,
                "problemTitle": "Walls and Gates",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Walls and Gates in Python?",
                "back": "```python\ndef solve_286():\n    # Algorithm approach for Walls and Gates\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2867,
                "problemId": 286,
                "problemTitle": "Walls and Gates",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Walls and Gates?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2868,
                "problemId": 286,
                "problemTitle": "Walls and Gates",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Walls and Gates",
                "back": "Input: Input for Walls and Gates\nOutput: Expected output for Walls and Gates\nExplanation: Explanation of how to solve Walls and Gates",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2871,
                "problemId": 287,
                "problemTitle": "Find the Duplicate Number",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Find the Duplicate Number problem ask you to do?",
                "back": "Problem 287: Find the Duplicate Number - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2872,
                "problemId": 287,
                "problemTitle": "Find the Duplicate Number",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Find the Duplicate Number?",
                "back": "Algorithm: function solve287():\n    // Algorithm approach for Find the Duplicate Number\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // S...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2873,
                "problemId": 287,
                "problemTitle": "Find the Duplicate Number",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Find the Duplicate Number solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2874,
                "problemId": 287,
                "problemTitle": "Find the Duplicate Number",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Find the Duplicate Number solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2875,
                "problemId": 287,
                "problemTitle": "Find the Duplicate Number",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Find the Duplicate Number?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2876,
                "problemId": 287,
                "problemTitle": "Find the Duplicate Number",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Find the Duplicate Number in Python?",
                "back": "```python\ndef solve_287():\n    # Algorithm approach for Find the Duplicate Number\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2877,
                "problemId": 287,
                "problemTitle": "Find the Duplicate Number",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Find the Duplicate Number?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2878,
                "problemId": 287,
                "problemTitle": "Find the Duplicate Number",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Find the Duplicate Number",
                "back": "Input: Input for Find the Duplicate Number\nOutput: Expected output for Find the Duplicate Number\nExplanation: Explanation of how to solve Find the Duplicate Number",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2881,
                "problemId": 288,
                "problemTitle": "Unique Word Abbreviation",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Unique Word Abbreviation problem ask you to do?",
                "back": "Problem 288: Unique Word Abbreviation - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2882,
                "problemId": 288,
                "problemTitle": "Unique Word Abbreviation",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Unique Word Abbreviation?",
                "back": "Algorithm: function solve288():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2883,
                "problemId": 288,
                "problemTitle": "Unique Word Abbreviation",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Unique Word Abbreviation solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2884,
                "problemId": 288,
                "problemTitle": "Unique Word Abbreviation",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Unique Word Abbreviation solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2885,
                "problemId": 288,
                "problemTitle": "Unique Word Abbreviation",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Unique Word Abbreviation?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2886,
                "problemId": 288,
                "problemTitle": "Unique Word Abbreviation",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Unique Word Abbreviation in Python?",
                "back": "```python\ndef solve_288():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2887,
                "problemId": 288,
                "problemTitle": "Unique Word Abbreviation",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Unique Word Abbreviation?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2888,
                "problemId": 288,
                "problemTitle": "Unique Word Abbreviation",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Unique Word Abbreviation",
                "back": "Input: Input for Unique Word Abbreviation\nOutput: Expected output for Unique Word Abbreviation\nExplanation: Explanation of how to solve Unique Word Abbreviation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2891,
                "problemId": 289,
                "problemTitle": "Game of Life",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Game of Life problem ask you to do?",
                "back": "Problem 289: Game of Life - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2892,
                "problemId": 289,
                "problemTitle": "Game of Life",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Game of Life?",
                "back": "Algorithm: function solve289():\n    // Algorithm approach for Game of Life\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initia...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2893,
                "problemId": 289,
                "problemTitle": "Game of Life",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Game of Life solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2894,
                "problemId": 289,
                "problemTitle": "Game of Life",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Game of Life solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2895,
                "problemId": 289,
                "problemTitle": "Game of Life",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Game of Life?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Focus on implementing a clean, readable solution",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2896,
                "problemId": 289,
                "problemTitle": "Game of Life",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Game of Life in Python?",
                "back": "```python\ndef solve_289():\n    # Algorithm approach for Game of Life\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2897,
                "problemId": 289,
                "problemTitle": "Game of Life",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Game of Life?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2898,
                "problemId": 289,
                "problemTitle": "Game of Life",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Game of Life",
                "back": "Input: Input for Game of Life\nOutput: Expected output for Game of Life\nExplanation: Explanation of how to solve Game of Life",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2901,
                "problemId": 290,
                "problemTitle": "Word Pattern",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Word Pattern problem ask you to do?",
                "back": "Problem 290: Word Pattern - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2902,
                "problemId": 290,
                "problemTitle": "Word Pattern",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Word Pattern?",
                "back": "Algorithm: function solve290():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2903,
                "problemId": 290,
                "problemTitle": "Word Pattern",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Word Pattern solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2904,
                "problemId": 290,
                "problemTitle": "Word Pattern",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Word Pattern solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2905,
                "problemId": 290,
                "problemTitle": "Word Pattern",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Word Pattern?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2906,
                "problemId": 290,
                "problemTitle": "Word Pattern",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Word Pattern in Python?",
                "back": "```python\ndef solve_290():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2907,
                "problemId": 290,
                "problemTitle": "Word Pattern",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Word Pattern?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2908,
                "problemId": 290,
                "problemTitle": "Word Pattern",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Word Pattern",
                "back": "Input: Input for Word Pattern\nOutput: Expected output for Word Pattern\nExplanation: Explanation of how to solve Word Pattern",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2911,
                "problemId": 291,
                "problemTitle": "Word Pattern II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Word Pattern II problem ask you to do?",
                "back": "Problem 291: Word Pattern II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2912,
                "problemId": 291,
                "problemTitle": "Word Pattern II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Word Pattern II?",
                "back": "Algorithm: function solve291():\n    // String processing approach\n    if s.length == 0:\n        return \"\"\n    \n    // Convert to array for easier manipulation\n    chars = s.split(\"\")\n    \n    // Process the stri...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2913,
                "problemId": 291,
                "problemTitle": "Word Pattern II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Word Pattern II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2914,
                "problemId": 291,
                "problemTitle": "Word Pattern II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Word Pattern II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2915,
                "problemId": 291,
                "problemTitle": "Word Pattern II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Word Pattern II?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2916,
                "problemId": 291,
                "problemTitle": "Word Pattern II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Word Pattern II in Python?",
                "back": "```python\ndef solve_291():\n    # String processing approach\n    if len(s) == 0:\n        return \"\"\n    \n    # Convert to list for easier manipulation\n    chars = list(s)\n    \n    # Process the string\n    for i in range(len(chars)):\n        # Your logic here\n        pass\n    \n    return ''.join(chars)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2917,
                "problemId": 291,
                "problemTitle": "Word Pattern II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Word Pattern II?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2918,
                "problemId": 291,
                "problemTitle": "Word Pattern II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Word Pattern II",
                "back": "Input: Input for Word Pattern II\nOutput: Expected output for Word Pattern II\nExplanation: Explanation of how to solve Word Pattern II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2921,
                "problemId": 292,
                "problemTitle": "Nim Game",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Nim Game problem ask you to do?",
                "back": "Problem 292: Nim Game - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2922,
                "problemId": 292,
                "problemTitle": "Nim Game",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Nim Game?",
                "back": "Algorithm: function solve292():\n    // Algorithm approach for Nim Game\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initialize...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2923,
                "problemId": 292,
                "problemTitle": "Nim Game",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Nim Game solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2924,
                "problemId": 292,
                "problemTitle": "Nim Game",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Nim Game solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2925,
                "problemId": 292,
                "problemTitle": "Nim Game",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Nim Game?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2926,
                "problemId": 292,
                "problemTitle": "Nim Game",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Nim Game in Python?",
                "back": "```python\ndef solve_292():\n    # Algorithm approach for Nim Game\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2927,
                "problemId": 292,
                "problemTitle": "Nim Game",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Nim Game?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2928,
                "problemId": 292,
                "problemTitle": "Nim Game",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Nim Game",
                "back": "Input: Input for Nim Game\nOutput: Expected output for Nim Game\nExplanation: Explanation of how to solve Nim Game",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2931,
                "problemId": 293,
                "problemTitle": "Flip Game",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Flip Game problem ask you to do?",
                "back": "Problem 293: Flip Game - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2932,
                "problemId": 293,
                "problemTitle": "Flip Game",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Flip Game?",
                "back": "Algorithm: function solve293():\n    // Algorithm approach for Flip Game\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initializ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2933,
                "problemId": 293,
                "problemTitle": "Flip Game",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Flip Game solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2934,
                "problemId": 293,
                "problemTitle": "Flip Game",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Flip Game solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2935,
                "problemId": 293,
                "problemTitle": "Flip Game",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Flip Game?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Break down the problem into smaller, manageable subproblems",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2936,
                "problemId": 293,
                "problemTitle": "Flip Game",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Flip Game in Python?",
                "back": "```python\ndef solve_293():\n    # Algorithm approach for Flip Game\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2937,
                "problemId": 293,
                "problemTitle": "Flip Game",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Flip Game?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2938,
                "problemId": 293,
                "problemTitle": "Flip Game",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Flip Game",
                "back": "Input: Input for Flip Game\nOutput: Expected output for Flip Game\nExplanation: Explanation of how to solve Flip Game",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2941,
                "problemId": 294,
                "problemTitle": "Flip Game II",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Flip Game II problem ask you to do?",
                "back": "Problem 294: Flip Game II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2942,
                "problemId": 294,
                "problemTitle": "Flip Game II",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Flip Game II?",
                "back": "Algorithm: function solve294():\n    // Algorithm approach for Flip Game II\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Initia...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2943,
                "problemId": 294,
                "problemTitle": "Flip Game II",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Flip Game II solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2944,
                "problemId": 294,
                "problemTitle": "Flip Game II",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Flip Game II solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2945,
                "problemId": 294,
                "problemTitle": "Flip Game II",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Flip Game II?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2946,
                "problemId": 294,
                "problemTitle": "Flip Game II",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Flip Game II in Python?",
                "back": "```python\ndef solve_294():\n    # Algorithm approach for Flip Game II\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2947,
                "problemId": 294,
                "problemTitle": "Flip Game II",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Flip Game II?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2948,
                "problemId": 294,
                "problemTitle": "Flip Game II",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Flip Game II",
                "back": "Input: Input for Flip Game II\nOutput: Expected output for Flip Game II\nExplanation: Explanation of how to solve Flip Game II",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2951,
                "problemId": 295,
                "problemTitle": "Find Median from Data Stream",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Find Median from Data Stream problem ask you to do?",
                "back": "Problem 295: Find Median from Data Stream - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2952,
                "problemId": 295,
                "problemTitle": "Find Median from Data Stream",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Find Median from Data Stream?",
                "back": "Algorithm: function solve295():\n    // Algorithm approach for Find Median from Data Stream\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    /...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2953,
                "problemId": 295,
                "problemTitle": "Find Median from Data Stream",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Find Median from Data Stream solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2954,
                "problemId": 295,
                "problemTitle": "Find Median from Data Stream",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Find Median from Data Stream solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2955,
                "problemId": 295,
                "problemTitle": "Find Median from Data Stream",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Find Median from Data Stream?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2956,
                "problemId": 295,
                "problemTitle": "Find Median from Data Stream",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Find Median from Data Stream in Python?",
                "back": "```python\ndef solve_295():\n    # Algorithm approach for Find Median from Data Stream\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2957,
                "problemId": 295,
                "problemTitle": "Find Median from Data Stream",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Find Median from Data Stream?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2958,
                "problemId": 295,
                "problemTitle": "Find Median from Data Stream",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Find Median from Data Stream",
                "back": "Input: Input for Find Median from Data Stream\nOutput: Expected output for Find Median from Data Stream\nExplanation: Explanation of how to solve Find Median from Data Stream",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2961,
                "problemId": 296,
                "problemTitle": "Best Meeting Point",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Best Meeting Point problem ask you to do?",
                "back": "Problem 296: Best Meeting Point - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2962,
                "problemId": 296,
                "problemTitle": "Best Meeting Point",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Best Meeting Point?",
                "back": "Algorithm: function solve296():\n    // Algorithm approach for Best Meeting Point\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: ...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2963,
                "problemId": 296,
                "problemTitle": "Best Meeting Point",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Best Meeting Point solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2964,
                "problemId": 296,
                "problemTitle": "Best Meeting Point",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Best Meeting Point solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2965,
                "problemId": 296,
                "problemTitle": "Best Meeting Point",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Best Meeting Point?",
                "back": "Consider using two pointers or sliding window for array problems. Think about whether the array needs to be sorted first. Watch out for edge cases like empty arrays or single elements. Consider converting string to character array for easier manipulation",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2966,
                "problemId": 296,
                "problemTitle": "Best Meeting Point",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Best Meeting Point in Python?",
                "back": "```python\ndef solve_296():\n    # Algorithm approach for Best Meeting Point\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2967,
                "problemId": 296,
                "problemTitle": "Best Meeting Point",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Best Meeting Point?",
                "back": "Tags: Array, String. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2968,
                "problemId": 296,
                "problemTitle": "Best Meeting Point",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Best Meeting Point",
                "back": "Input: Input for Best Meeting Point\nOutput: Expected output for Best Meeting Point\nExplanation: Explanation of how to solve Best Meeting Point",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2971,
                "problemId": 297,
                "problemTitle": "Serialize and Deserialize Binary Tree",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Serialize and Deserialize Binary Tree problem ask you to do?",
                "back": "Problem 297: Serialize and Deserialize Binary Tree - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2972,
                "problemId": 297,
                "problemTitle": "Serialize and Deserialize Binary Tree",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Serialize and Deserialize Binary Tree?",
                "back": "Algorithm: function solve297():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2973,
                "problemId": 297,
                "problemTitle": "Serialize and Deserialize Binary Tree",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Serialize and Deserialize Binary Tree solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2974,
                "problemId": 297,
                "problemTitle": "Serialize and Deserialize Binary Tree",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Serialize and Deserialize Binary Tree solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2975,
                "problemId": 297,
                "problemTitle": "Serialize and Deserialize Binary Tree",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Serialize and Deserialize Binary Tree?",
                "back": "Identify overlapping subproblems and optimal substructure. Consider bottom-up vs top-down approaches. Think about space optimization - can you use O(1) space?. Look for optimization opportunities to improve time/space complexity",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2976,
                "problemId": 297,
                "problemTitle": "Serialize and Deserialize Binary Tree",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Serialize and Deserialize Binary Tree in Python?",
                "back": "```python\ndef solve_297():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2977,
                "problemId": 297,
                "problemTitle": "Serialize and Deserialize Binary Tree",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Serialize and Deserialize Binary Tree?",
                "back": "Tags: Dynamic Programming. This problem focuses on Dynamic Programming algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2978,
                "problemId": 297,
                "problemTitle": "Serialize and Deserialize Binary Tree",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Serialize and Deserialize Binary Tree",
                "back": "Input: Input for Serialize and Deserialize Binary Tree\nOutput: Expected output for Serialize and Deserialize Binary Tree\nExplanation: Explanation of how to solve Serialize and Deserialize Binary Tree",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2981,
                "problemId": 298,
                "problemTitle": "Binary Tree Longest Consecutive Sequence",
                "difficulty": "Easy",
                "cardType": "Problem Statement",
                "front": "What does the Binary Tree Longest Consecutive Sequence problem ask you to do?",
                "back": "Problem 298: Binary Tree Longest Consecutive Sequence - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2982,
                "problemId": 298,
                "problemTitle": "Binary Tree Longest Consecutive Sequence",
                "difficulty": "Easy",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Binary Tree Longest Consecutive Sequence?",
                "back": "Algorithm: function solve298():\n    // Tree traversal approach\n    if root == null:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack.length > 0:\n        node = stack.pop()\n        i...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2983,
                "problemId": 298,
                "problemTitle": "Binary Tree Longest Consecutive Sequence",
                "difficulty": "Easy",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Binary Tree Longest Consecutive Sequence solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2984,
                "problemId": 298,
                "problemTitle": "Binary Tree Longest Consecutive Sequence",
                "difficulty": "Easy",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Binary Tree Longest Consecutive Sequence solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2985,
                "problemId": 298,
                "problemTitle": "Binary Tree Longest Consecutive Sequence",
                "difficulty": "Easy",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Binary Tree Longest Consecutive Sequence?",
                "back": "Consider different traversal methods: preorder, inorder, postorder. Think recursively: what do you do at each node?. Handle null nodes gracefully to avoid runtime errors. Choose appropriate traversal: DFS for paths, BFS for shortest distance",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2986,
                "problemId": 298,
                "problemTitle": "Binary Tree Longest Consecutive Sequence",
                "difficulty": "Easy",
                "cardType": "Python Code",
                "front": "How do you implement Binary Tree Longest Consecutive Sequence in Python?",
                "back": "```python\ndef solve_298():\n    # Tree traversal approach\n    if not root:\n        return []\n    \n    result = []\n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node:\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n    \n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2987,
                "problemId": 298,
                "problemTitle": "Binary Tree Longest Consecutive Sequence",
                "difficulty": "Easy",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Binary Tree Longest Consecutive Sequence?",
                "back": "Tags: Tree, Graph. This problem focuses on Tree algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2988,
                "problemId": 298,
                "problemTitle": "Binary Tree Longest Consecutive Sequence",
                "difficulty": "Easy",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Binary Tree Longest Consecutive Sequence",
                "back": "Input: Input for Binary Tree Longest Consecutive Sequence\nOutput: Expected output for Binary Tree Longest Consecutive Sequence\nExplanation: Explanation of how to solve Binary Tree Longest Consecutive Sequence",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2991,
                "problemId": 299,
                "problemTitle": "Bulls and Cows",
                "difficulty": "Hard",
                "cardType": "Problem Statement",
                "front": "What does the Bulls and Cows problem ask you to do?",
                "back": "Problem 299: Bulls and Cows - A computational problem that tests your algorithmic thinking and problem-solving skills.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2992,
                "problemId": 299,
                "problemTitle": "Bulls and Cows",
                "difficulty": "Hard",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Bulls and Cows?",
                "back": "Algorithm: function solve299():\n    // Algorithm approach for Bulls and Cows\n    \n    // Step 1: Handle edge cases\n    if input == null or input.length == 0:\n        return default_value\n    \n    // Step 2: Init...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2993,
                "problemId": 299,
                "problemTitle": "Bulls and Cows",
                "difficulty": "Hard",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Bulls and Cows solution?",
                "back": "O(n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2994,
                "problemId": 299,
                "problemTitle": "Bulls and Cows",
                "difficulty": "Hard",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Bulls and Cows solution?",
                "back": "O(1) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2995,
                "problemId": 299,
                "problemTitle": "Bulls and Cows",
                "difficulty": "Hard",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Bulls and Cows?",
                "back": "Hash tables provide O(1) lookup time for fast access patterns. Consider using hash maps to store frequency counts or seen elements. Remember to handle hash collisions and null key cases. Two pointers work well for sorted arrays or when looking for pairs",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2996,
                "problemId": 299,
                "problemTitle": "Bulls and Cows",
                "difficulty": "Hard",
                "cardType": "Python Code",
                "front": "How do you implement Bulls and Cows in Python?",
                "back": "```python\ndef solve_299():\n    # Algorithm approach for Bulls and Cows\n    \n    # Step 1: Handle edge cases\n    if not input or len(input) == 0:\n        return default_value\n    \n    # Step 2: Initialize variables\n    result = initial_value\n    # Additional variables as needed\n    \n    # Step 3: Main algorithm logic\n    for i in range(len(input)):\n        # Your core logic here\n        pass\n    \n    # Step 4: Return result\n    return result\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2997,
                "problemId": 299,
                "problemTitle": "Bulls and Cows",
                "difficulty": "Hard",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Bulls and Cows?",
                "back": "Tags: Hash Table, Two Pointers. This problem focuses on Hash Table algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 2998,
                "problemId": 299,
                "problemTitle": "Bulls and Cows",
                "difficulty": "Hard",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Bulls and Cows",
                "back": "Input: Input for Bulls and Cows\nOutput: Expected output for Bulls and Cows\nExplanation: Explanation of how to solve Bulls and Cows",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 3001,
                "problemId": 300,
                "problemTitle": "Longest Increasing Subsequence",
                "difficulty": "Medium",
                "cardType": "Problem Statement",
                "front": "What does the Longest Increasing Subsequence problem ask you to do?",
                "back": "Find length of longest increasing subsequence using dynamic programming.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 3002,
                "problemId": 300,
                "problemTitle": "Longest Increasing Subsequence",
                "difficulty": "Medium",
                "cardType": "Solution Approach",
                "front": "What is the optimal approach to solve Longest Increasing Subsequence?",
                "back": "Algorithm: function lengthOfLIS(nums):\n    if nums.length == 0:\n        return 0\n    \n    dp = new Array(nums.length).fill(1)\n    \n    for i = 1 to nums.length - 1:\n        for j = 0 to i - 1:\n            if num...",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 3003,
                "problemId": 300,
                "problemTitle": "Longest Increasing Subsequence",
                "difficulty": "Medium",
                "cardType": "Time Complexity",
                "front": "What is the time complexity of the optimal Longest Increasing Subsequence solution?",
                "back": "O(n log n) - This represents the algorithm's efficiency in terms of time.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 3004,
                "problemId": 300,
                "problemTitle": "Longest Increasing Subsequence",
                "difficulty": "Medium",
                "cardType": "Space Complexity",
                "front": "What is the space complexity of the optimal Longest Increasing Subsequence solution?",
                "back": "O(n) - This represents the algorithm's memory usage.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 3005,
                "problemId": 300,
                "problemTitle": "Longest Increasing Subsequence",
                "difficulty": "Medium",
                "cardType": "Key Insights",
                "front": "What are the key insights for solving Longest Increasing Subsequence?",
                "back": "DP array. Binary search. LIS tracking",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 3006,
                "problemId": 300,
                "problemTitle": "Longest Increasing Subsequence",
                "difficulty": "Medium",
                "cardType": "Python Code",
                "front": "How do you implement Longest Increasing Subsequence in Python?",
                "back": "```python\ndef lengthOfLIS(nums):\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n```",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 3007,
                "problemId": 300,
                "problemTitle": "Longest Increasing Subsequence",
                "difficulty": "Medium",
                "cardType": "Tags & Categories",
                "front": "What are the main topics/tags for Longest Increasing Subsequence?",
                "back": "Tags: Array, Binary Search, Dynamic Programming. This problem focuses on Array algorithms.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        },
        {
                "id": 3008,
                "problemId": 300,
                "problemTitle": "Longest Increasing Subsequence",
                "difficulty": "Medium",
                "cardType": "Example Test Case",
                "front": "Give an example input/output for Longest Increasing Subsequence",
                "back": "Input: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: LIS is [2,5,7,101] with length 4.",
                "status": "New",
                "lastReviewed": null,
                "nextReview": null,
                "interval": 1,
                "easeFactor": 2.5
        }
];

        let currentPage = 1;
        const cardsPerPage = 12;
        let filteredCards = [];
        let currentStudyCard = 0;
        let studyCards = [];

        document.addEventListener('DOMContentLoaded', function() {
            // Check for problem filter from URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const problemFilter = urlParams.get('problem');
            
            updateStats();
            populateFilters();
            
            // Apply problem filter if specified in URL
            if (problemFilter) {
                document.getElementById('problem-filter').value = problemFilter;
                document.title = `ðŸ“š Anki Cards - ${problemFilter} - LeetCode Problems`;
                
                // Show a filter indicator
                showProblemFilterIndicator(problemFilter);
            }
            
            applyFilters();
            renderPagination();
        });

        function updateStats() {
            const total = sampleCards.length;
            const newCards = sampleCards.filter(card => card.status === 'New').length;
            const learning = sampleCards.filter(card => card.status === 'Learning').length;
            const review = sampleCards.filter(card => card.status === 'Review').length;

            document.getElementById('total-cards').textContent = total;
            document.getElementById('new-cards').textContent = newCards;
            document.getElementById('learning-cards').textContent = learning;
            document.getElementById('review-cards').textContent = review;
        }

        // Populate filter dropdowns
        function populateFilters() {
            const problemFilter = document.getElementById('problem-filter');
            const problems = [...new Set(sampleCards.map(card => card.problemTitle))].sort();
            
            // Clear existing options except the first one
            problemFilter.innerHTML = '<option value="">All Problems</option>';
            
            problems.forEach(problem => {
                const option = document.createElement('option');
                option.value = problem;
                option.textContent = problem;
                problemFilter.appendChild(option);
            });
        }

        // Show problem filter indicator
        function showProblemFilterIndicator(problemTitle) {
            const filterSection = document.querySelector('.filter-section');
            const indicator = document.createElement('div');
            indicator.className = 'alert alert-info mt-3';
            indicator.innerHTML = `
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <i class="fas fa-filter me-2"></i>
                        <strong>Filtered by Problem:</strong> ${problemTitle}
                    </div>
                    <button class="btn btn-outline-info btn-sm" onclick="clearProblemFilter()">
                        <i class="fas fa-times me-1"></i>Clear Filter
                    </button>
                </div>
            `;
            filterSection.appendChild(indicator);
        }

        // Clear problem filter
        function clearProblemFilter() {
            document.getElementById('problem-filter').value = '';
            // Remove the filter indicator
            const indicator = document.querySelector('.alert-info');
            if (indicator) {
                indicator.remove();
            }
            // Update URL to remove problem parameter
            const url = new URL(window.location);
            url.searchParams.delete('problem');
            window.history.replaceState({}, '', url);
            // Reset title
            document.title = 'ðŸ“š Anki Study Cards - LeetCode Problems';
            // Reapply filters
            applyFilters();
        }

        function applyFilters() {
            const difficulty = document.getElementById('difficulty-filter').value;
            const cardType = document.getElementById('card-type-filter').value;
            const problem = document.getElementById('problem-filter').value;
            const search = document.getElementById('search-filter').value.toLowerCase();

            filteredCards = sampleCards.filter(card => {
                if (difficulty && card.difficulty !== difficulty) return false;
                if (cardType && card.cardType !== cardType) return false;
                if (problem && card.problemTitle !== problem) return false;
                if (search && !card.front.toLowerCase().includes(search) && !card.back.toLowerCase().includes(search)) return false;
                return true;
            });

            currentPage = 1;
            renderCards();
            renderPagination();
        }

        function renderCards() {
            const container = document.getElementById('cards-container');
            const start = (currentPage - 1) * cardsPerPage;
            const end = start + cardsPerPage;
            const pageCards = filteredCards.slice(start, end);

            container.innerHTML = '';

            pageCards.forEach(card => {
                const col = document.createElement('div');
                col.className = 'col-lg-4 col-md-6 mb-4';

                let difficultyClass = 'btn-secondary';
                if (card.difficulty === 'Easy') difficultyClass = 'btn-easy';
                else if (card.difficulty === 'Medium') difficultyClass = 'btn-medium';
                else if (card.difficulty === 'Hard') difficultyClass = 'btn-hard';

                col.innerHTML = `
                    <div class="card h-100">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-start mb-2">
                                <span class="badge ${difficultyClass} px-3 py-2">${card.difficulty}</span>
                                <span class="badge bg-secondary px-3 py-2">${card.cardType}</span>
                            </div>
                            <h6 class="card-title text-primary">${card.problemTitle}</h6>
                            <p class="card-text">${card.front}</p>
                            <button class="btn btn-primary btn-sm" onclick="studyCard(${card.id})">Study</button>
                        </div>
                    </div>
                `;

                container.appendChild(col);
            });
        }

        function renderPagination() {
            const totalPages = Math.ceil(filteredCards.length / cardsPerPage);
            const pagination = document.getElementById('pagination');
            
            pagination.innerHTML = '';

            if (totalPages <= 1) return;

            const prevLi = document.createElement('li');
            prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
            prevLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage - 1})">Previous</a>`;
            pagination.appendChild(prevLi);

            for (let i = 1; i <= totalPages; i++) {
                if (i === 1 || i === totalPages || (i >= currentPage - 2 && i <= currentPage + 2)) {
                    const li = document.createElement('li');
                    li.className = `page-item ${i === currentPage ? 'active' : ''}`;
                    li.innerHTML = `<a class="page-link" href="#" onclick="changePage(${i})">${i}</a>`;
                    pagination.appendChild(li);
                }
            }

            const nextLi = document.createElement('li');
            nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
            nextLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage + 1})">Next</a>`;
            pagination.appendChild(nextLi);
        }

        function changePage(page) {
            if (page < 1 || page > Math.ceil(filteredCards.length / cardsPerPage)) return;
            currentPage = page;
            renderCards();
            renderPagination();
        }

        function startStudySession() {
            studyCards = [...filteredCards];
            if (studyCards.length === 0) {
                alert('No cards available for study. Please adjust your filters.');
                return;
            }
            
            currentStudyCard = 0;
            showStudyCard();
            new bootstrap.Modal(document.getElementById('studyModal')).show();
        }

        function showStudyCard() {
            if (currentStudyCard >= studyCards.length) {
                document.getElementById('study-card').innerHTML = `
                    <div class="text-center">
                        <h3>ðŸŽ‰ Study Session Complete!</h3>
                        <p>You've reviewed all available cards.</p>
                        <button class="btn btn-primary" onclick="closeStudyModal()">Close</button>
                    </div>
                `;
                return;
            }

            const card = studyCards[currentStudyCard];
            document.getElementById('card-front').textContent = card.front;
            document.getElementById('card-back').innerHTML = card.back.replace(/\n/g, '<br>');
            document.getElementById('card-back').style.display = 'none';
            document.getElementById('study-controls').style.display = 'block';
            document.getElementById('answer-controls').style.display = 'none';
        }

        function showAnswer() {
            document.getElementById('card-back').style.display = 'block';
            document.getElementById('study-controls').style.display = 'none';
            document.getElementById('answer-controls').style.display = 'block';
        }

        function rateCard(rating) {
            const card = studyCards[currentStudyCard];
            
            if (rating === 1) {
                card.status = 'Learning';
                card.interval = 1;
            } else if (rating === 2) {
                card.status = 'Learning';
                card.interval = Math.max(1, Math.floor(card.interval * 0.8));
            } else if (rating === 3) {
                card.status = 'Review';
                card.interval = Math.floor(card.interval * 1.5);
            } else {
                card.status = 'Review';
                card.interval = Math.floor(card.interval * 2);
            }

            card.lastReviewed = new Date().toISOString();
            card.nextReview = new Date(Date.now() + card.interval * 24 * 60 * 60 * 1000).toISOString();

            currentStudyCard++;
            showStudyCard();
        }

        function studyCard(cardId) {
            const card = sampleCards.find(c => c.id === cardId);
            if (card) {
                studyCards = [card];
                currentStudyCard = 0;
                showStudyCard();
                new bootstrap.Modal(document.getElementById('studyModal')).show();
            }
        }

        function closeStudyModal() {
            bootstrap.Modal.getInstance(document.getElementById('studyModal')).hide();
            updateStats();
        }

        document.getElementById('difficulty-filter').addEventListener('change', applyFilters);
        document.getElementById('card-type-filter').addEventListener('change', applyFilters);
        document.getElementById('problem-filter').addEventListener('change', applyFilters);
        document.getElementById('search-filter').addEventListener('input', applyFilters);
    </script>
</body>
</html>