// Top 300 LeetCode Problems Data with Comprehensive DP Problems
const topLeetCodeProblems = [
  {
    "id": 1,
    "title": "Two Sum",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "Hash Table"
    ],
    "acceptance": "52.3%",
    "fullDescription": "Problem 1: Two Sum - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Two Sum",
        "output": "Expected output for Two Sum",
        "explanation": "Explanation of how to solve Two Sum"
      }
    ],
    "pseudocode": "Algorithm for Two Sum:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Two Sum\ndef solve_1():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Two Sum",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 2,
    "title": "Add Two Numbers",
    "difficulty": "Medium",
    "tags": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "acceptance": "38.9%",
    "fullDescription": "Problem 2: Add Two Numbers - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Add Two Numbers",
        "output": "Expected output for Add Two Numbers",
        "explanation": "Explanation of how to solve Add Two Numbers"
      }
    ],
    "pseudocode": "Algorithm for Add Two Numbers:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Add Two Numbers\ndef solve_2():\n    # Implementation here\n    pass",
    "timeComplexity": "O(max(m,n))",
    "spaceComplexity": "O(max(m,n))",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Add Two Numbers",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 3,
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "43%",
    "fullDescription": "Problem 3: Longest Substring Without Repeating Characters - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Longest Substring Without Repeating Characters",
        "output": "Expected output for Longest Substring Without Repeating Characters",
        "explanation": "Explanation of how to solve Longest Substring Without Repeating Characters"
      }
    ],
    "pseudocode": "Algorithm for Longest Substring Without Repeating Characters:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Longest Substring Without Repeating Characters\ndef solve_3():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Longest Substring Without Repeating Characters",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 4,
    "title": "Median of Two Sorted Arrays",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "44%",
    "fullDescription": "Problem 4: Median of Two Sorted Arrays - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Median of Two Sorted Arrays",
        "output": "Expected output for Median of Two Sorted Arrays",
        "explanation": "Explanation of how to solve Median of Two Sorted Arrays"
      }
    ],
    "pseudocode": "Algorithm for Median of Two Sorted Arrays:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Median of Two Sorted Arrays\ndef solve_4():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Median of Two Sorted Arrays",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 5,
    "title": "Longest Palindromic Substring",
    "difficulty": "Medium",
    "tags": [
      "String",
      "Dynamic Programming"
    ],
    "acceptance": "32.1%",
    "fullDescription": "Find the longest palindromic substring in a string using dynamic programming approach.",
    "testCases": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "Longest palindromic substring is 'bab'."
      }
    ],
    "pseudocode": "Use DP table to track palindrome lengths\nFill table diagonally for all substrings",
    "pythonCode": "DP approach with O(n\u00b2) time complexity",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(n\u00b2)",
    "keyInsights": [
      "DP table approach",
      "Fill diagonally",
      "Check palindrome conditions"
    ]
  },
  {
    "id": 6,
    "title": "Zigzag Conversion",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "46%",
    "fullDescription": "Problem 6: Zigzag Conversion - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Zigzag Conversion",
        "output": "Expected output for Zigzag Conversion",
        "explanation": "Explanation of how to solve Zigzag Conversion"
      }
    ],
    "pseudocode": "Algorithm for Zigzag Conversion:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Zigzag Conversion\ndef solve_6():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Zigzag Conversion",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 7,
    "title": "Reverse Integer",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "47%",
    "fullDescription": "Problem 7: Reverse Integer - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Reverse Integer",
        "output": "Expected output for Reverse Integer",
        "explanation": "Explanation of how to solve Reverse Integer"
      }
    ],
    "pseudocode": "Algorithm for Reverse Integer:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Reverse Integer\ndef solve_7():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Reverse Integer",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 8,
    "title": "String to Integer (atoi)",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "48%",
    "fullDescription": "Problem 8: String to Integer (atoi) - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for String to Integer (atoi)",
        "output": "Expected output for String to Integer (atoi)",
        "explanation": "Explanation of how to solve String to Integer (atoi)"
      }
    ],
    "pseudocode": "Algorithm for String to Integer (atoi):\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for String to Integer (atoi)\ndef solve_8():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for String to Integer (atoi)",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 9,
    "title": "Palindrome Number",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "49%",
    "fullDescription": "Problem 9: Palindrome Number - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Palindrome Number",
        "output": "Expected output for Palindrome Number",
        "explanation": "Explanation of how to solve Palindrome Number"
      }
    ],
    "pseudocode": "Algorithm for Palindrome Number:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Palindrome Number\ndef solve_9():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Palindrome Number",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 10,
    "title": "Regular Expression Matching",
    "difficulty": "Hard",
    "tags": [
      "String",
      "Dynamic Programming",
      "Recursion"
    ],
    "acceptance": "28.1%",
    "fullDescription": "Implement regular expression matching with support for '.' and '*' using dynamic programming.",
    "testCases": [
      {
        "input": "s = \"aa\", p = \"a*\"",
        "output": "true",
        "explanation": "Pattern matches the string."
      }
    ],
    "pseudocode": "DP table for pattern matching\nHandle * and . operators",
    "pythonCode": "DP approach for regex matching",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)",
    "keyInsights": [
      "Handle * and . operators",
      "Use DP table",
      "Pattern matching"
    ]
  },
  {
    "id": 11,
    "title": "Container With Most Water",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "51%",
    "fullDescription": "Problem 11: Container With Most Water - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Container With Most Water",
        "output": "Expected output for Container With Most Water",
        "explanation": "Explanation of how to solve Container With Most Water"
      }
    ],
    "pseudocode": "Algorithm for Container With Most Water:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Container With Most Water\ndef solve_11():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Container With Most Water",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 12,
    "title": "Integer to Roman",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "52%",
    "fullDescription": "Problem 12: Integer to Roman - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Integer to Roman",
        "output": "Expected output for Integer to Roman",
        "explanation": "Explanation of how to solve Integer to Roman"
      }
    ],
    "pseudocode": "Algorithm for Integer to Roman:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Integer to Roman\ndef solve_12():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Integer to Roman",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 13,
    "title": "Roman to Integer",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "53%",
    "fullDescription": "Problem 13: Roman to Integer - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Roman to Integer",
        "output": "Expected output for Roman to Integer",
        "explanation": "Explanation of how to solve Roman to Integer"
      }
    ],
    "pseudocode": "Algorithm for Roman to Integer:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Roman to Integer\ndef solve_13():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Roman to Integer",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 14,
    "title": "Longest Common Prefix",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "54%",
    "fullDescription": "Problem 14: Longest Common Prefix - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Longest Common Prefix",
        "output": "Expected output for Longest Common Prefix",
        "explanation": "Explanation of how to solve Longest Common Prefix"
      }
    ],
    "pseudocode": "Algorithm for Longest Common Prefix:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Longest Common Prefix\ndef solve_14():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Longest Common Prefix",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 15,
    "title": "3Sum",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "55%",
    "fullDescription": "Problem 15: 3Sum - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for 3Sum",
        "output": "Expected output for 3Sum",
        "explanation": "Explanation of how to solve 3Sum"
      }
    ],
    "pseudocode": "Algorithm for 3Sum:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for 3Sum\ndef solve_15():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for 3Sum",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 16,
    "title": "3Sum Closest",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "56%",
    "fullDescription": "Problem 16: 3Sum Closest - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for 3Sum Closest",
        "output": "Expected output for 3Sum Closest",
        "explanation": "Explanation of how to solve 3Sum Closest"
      }
    ],
    "pseudocode": "Algorithm for 3Sum Closest:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for 3Sum Closest\ndef solve_16():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for 3Sum Closest",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 17,
    "title": "Letter Combinations of a Phone Number",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "57%",
    "fullDescription": "Problem 17: Letter Combinations of a Phone Number - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Letter Combinations of a Phone Number",
        "output": "Expected output for Letter Combinations of a Phone Number",
        "explanation": "Explanation of how to solve Letter Combinations of a Phone Number"
      }
    ],
    "pseudocode": "Algorithm for Letter Combinations of a Phone Number:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Letter Combinations of a Phone Number\ndef solve_17():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Letter Combinations of a Phone Number",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 18,
    "title": "4Sum",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "58%",
    "fullDescription": "Problem 18: 4Sum - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for 4Sum",
        "output": "Expected output for 4Sum",
        "explanation": "Explanation of how to solve 4Sum"
      }
    ],
    "pseudocode": "Algorithm for 4Sum:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for 4Sum\ndef solve_18():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for 4Sum",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 19,
    "title": "Remove Nth Node From End of List",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "59%",
    "fullDescription": "Problem 19: Remove Nth Node From End of List - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Remove Nth Node From End of List",
        "output": "Expected output for Remove Nth Node From End of List",
        "explanation": "Explanation of how to solve Remove Nth Node From End of List"
      }
    ],
    "pseudocode": "Algorithm for Remove Nth Node From End of List:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Remove Nth Node From End of List\ndef solve_19():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Remove Nth Node From End of List",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 20,
    "title": "Valid Parentheses",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "60%",
    "fullDescription": "Problem 20: Valid Parentheses - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Valid Parentheses",
        "output": "Expected output for Valid Parentheses",
        "explanation": "Explanation of how to solve Valid Parentheses"
      }
    ],
    "pseudocode": "Algorithm for Valid Parentheses:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Valid Parentheses\ndef solve_20():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Valid Parentheses",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 21,
    "title": "Merge Two Sorted Lists",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "61%",
    "fullDescription": "Problem 21: Merge Two Sorted Lists - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Merge Two Sorted Lists",
        "output": "Expected output for Merge Two Sorted Lists",
        "explanation": "Explanation of how to solve Merge Two Sorted Lists"
      }
    ],
    "pseudocode": "Algorithm for Merge Two Sorted Lists:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Merge Two Sorted Lists\ndef solve_21():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Merge Two Sorted Lists",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 22,
    "title": "Generate Parentheses",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "62%",
    "fullDescription": "Problem 22: Generate Parentheses - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Generate Parentheses",
        "output": "Expected output for Generate Parentheses",
        "explanation": "Explanation of how to solve Generate Parentheses"
      }
    ],
    "pseudocode": "Algorithm for Generate Parentheses:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Generate Parentheses\ndef solve_22():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Generate Parentheses",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 23,
    "title": "Merge k Sorted Lists",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "63%",
    "fullDescription": "Problem 23: Merge k Sorted Lists - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Merge k Sorted Lists",
        "output": "Expected output for Merge k Sorted Lists",
        "explanation": "Explanation of how to solve Merge k Sorted Lists"
      }
    ],
    "pseudocode": "Algorithm for Merge k Sorted Lists:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Merge k Sorted Lists\ndef solve_23():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Merge k Sorted Lists",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 24,
    "title": "Swap Nodes in Pairs",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "64%",
    "fullDescription": "Problem 24: Swap Nodes in Pairs - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Swap Nodes in Pairs",
        "output": "Expected output for Swap Nodes in Pairs",
        "explanation": "Explanation of how to solve Swap Nodes in Pairs"
      }
    ],
    "pseudocode": "Algorithm for Swap Nodes in Pairs:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Swap Nodes in Pairs\ndef solve_24():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Swap Nodes in Pairs",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 25,
    "title": "Reverse Nodes in k-Group",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "65%",
    "fullDescription": "Problem 25: Reverse Nodes in k-Group - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Reverse Nodes in k-Group",
        "output": "Expected output for Reverse Nodes in k-Group",
        "explanation": "Explanation of how to solve Reverse Nodes in k-Group"
      }
    ],
    "pseudocode": "Algorithm for Reverse Nodes in k-Group:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Reverse Nodes in k-Group\ndef solve_25():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Reverse Nodes in k-Group",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 26,
    "title": "Remove Duplicates from Sorted Array",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "66%",
    "fullDescription": "Problem 26: Remove Duplicates from Sorted Array - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Remove Duplicates from Sorted Array",
        "output": "Expected output for Remove Duplicates from Sorted Array",
        "explanation": "Explanation of how to solve Remove Duplicates from Sorted Array"
      }
    ],
    "pseudocode": "Algorithm for Remove Duplicates from Sorted Array:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Remove Duplicates from Sorted Array\ndef solve_26():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Remove Duplicates from Sorted Array",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 27,
    "title": "Remove Element",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "67%",
    "fullDescription": "Problem 27: Remove Element - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Remove Element",
        "output": "Expected output for Remove Element",
        "explanation": "Explanation of how to solve Remove Element"
      }
    ],
    "pseudocode": "Algorithm for Remove Element:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Remove Element\ndef solve_27():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Remove Element",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 28,
    "title": "Find the Index of the First Occurrence in a String",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "68%",
    "fullDescription": "Problem 28: Find the Index of the First Occurrence in a String - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Find the Index of the First Occurrence in a String",
        "output": "Expected output for Find the Index of the First Occurrence in a String",
        "explanation": "Explanation of how to solve Find the Index of the First Occurrence in a String"
      }
    ],
    "pseudocode": "Algorithm for Find the Index of the First Occurrence in a String:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Find the Index of the First Occurrence in a String\ndef solve_28():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Find the Index of the First Occurrence in a String",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 29,
    "title": "Divide Two Integers",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "69%",
    "fullDescription": "Problem 29: Divide Two Integers - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Divide Two Integers",
        "output": "Expected output for Divide Two Integers",
        "explanation": "Explanation of how to solve Divide Two Integers"
      }
    ],
    "pseudocode": "Algorithm for Divide Two Integers:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Divide Two Integers\ndef solve_29():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Divide Two Integers",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 30,
    "title": "Substring with Concatenation of All Words",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "40%",
    "fullDescription": "Problem 30: Substring with Concatenation of All Words - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Substring with Concatenation of All Words",
        "output": "Expected output for Substring with Concatenation of All Words",
        "explanation": "Explanation of how to solve Substring with Concatenation of All Words"
      }
    ],
    "pseudocode": "Algorithm for Substring with Concatenation of All Words:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Substring with Concatenation of All Words\ndef solve_30():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Substring with Concatenation of All Words",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 31,
    "title": "Next Permutation",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "41%",
    "fullDescription": "Problem 31: Next Permutation - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Next Permutation",
        "output": "Expected output for Next Permutation",
        "explanation": "Explanation of how to solve Next Permutation"
      }
    ],
    "pseudocode": "Algorithm for Next Permutation:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Next Permutation\ndef solve_31():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Next Permutation",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 32,
    "title": "Longest Valid Parentheses",
    "difficulty": "Hard",
    "tags": [
      "String",
      "Dynamic Programming",
      "Stack"
    ],
    "acceptance": "32.1%",
    "fullDescription": "Find the length of the longest valid parentheses substring using dynamic programming.",
    "testCases": [
      {
        "input": "s = \"(()\"",
        "output": "2",
        "explanation": "Longest valid substring is '()'."
      }
    ],
    "pseudocode": "DP array to track valid lengths\nHandle opening and closing parentheses",
    "pythonCode": "DP with stack approach",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "DP array",
      "Stack combination",
      "Track valid lengths"
    ]
  },
  {
    "id": 33,
    "title": "Search in Rotated Sorted Array",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "43%",
    "fullDescription": "Problem 33: Search in Rotated Sorted Array - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Search in Rotated Sorted Array",
        "output": "Expected output for Search in Rotated Sorted Array",
        "explanation": "Explanation of how to solve Search in Rotated Sorted Array"
      }
    ],
    "pseudocode": "Algorithm for Search in Rotated Sorted Array:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Search in Rotated Sorted Array\ndef solve_33():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Search in Rotated Sorted Array",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 34,
    "title": "Find First and Last Position of Element in Sorted Array",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "44%",
    "fullDescription": "Problem 34: Find First and Last Position of Element in Sorted Array - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Find First and Last Position of Element in Sorted Array",
        "output": "Expected output for Find First and Last Position of Element in Sorted Array",
        "explanation": "Explanation of how to solve Find First and Last Position of Element in Sorted Array"
      }
    ],
    "pseudocode": "Algorithm for Find First and Last Position of Element in Sorted Array:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Find First and Last Position of Element in Sorted Array\ndef solve_34():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Find First and Last Position of Element in Sorted Array",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 35,
    "title": "Search Insert Position",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "45%",
    "fullDescription": "Problem 35: Search Insert Position - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Search Insert Position",
        "output": "Expected output for Search Insert Position",
        "explanation": "Explanation of how to solve Search Insert Position"
      }
    ],
    "pseudocode": "Algorithm for Search Insert Position:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Search Insert Position\ndef solve_35():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Search Insert Position",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 36,
    "title": "Valid Sudoku",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "46%",
    "fullDescription": "Problem 36: Valid Sudoku - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Valid Sudoku",
        "output": "Expected output for Valid Sudoku",
        "explanation": "Explanation of how to solve Valid Sudoku"
      }
    ],
    "pseudocode": "Algorithm for Valid Sudoku:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Valid Sudoku\ndef solve_36():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Valid Sudoku",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 37,
    "title": "Sudoku Solver",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "47%",
    "fullDescription": "Problem 37: Sudoku Solver - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Sudoku Solver",
        "output": "Expected output for Sudoku Solver",
        "explanation": "Explanation of how to solve Sudoku Solver"
      }
    ],
    "pseudocode": "Algorithm for Sudoku Solver:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Sudoku Solver\ndef solve_37():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Sudoku Solver",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 38,
    "title": "Count and Say",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "48%",
    "fullDescription": "Problem 38: Count and Say - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Count and Say",
        "output": "Expected output for Count and Say",
        "explanation": "Explanation of how to solve Count and Say"
      }
    ],
    "pseudocode": "Algorithm for Count and Say:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Count and Say\ndef solve_38():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Count and Say",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 39,
    "title": "Combination Sum",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "49%",
    "fullDescription": "Problem 39: Combination Sum - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Combination Sum",
        "output": "Expected output for Combination Sum",
        "explanation": "Explanation of how to solve Combination Sum"
      }
    ],
    "pseudocode": "Algorithm for Combination Sum:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Combination Sum\ndef solve_39():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Combination Sum",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 40,
    "title": "Combination Sum II",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "50%",
    "fullDescription": "Problem 40: Combination Sum II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Combination Sum II",
        "output": "Expected output for Combination Sum II",
        "explanation": "Explanation of how to solve Combination Sum II"
      }
    ],
    "pseudocode": "Algorithm for Combination Sum II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Combination Sum II\ndef solve_40():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Combination Sum II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 41,
    "title": "First Missing Positive",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "51%",
    "fullDescription": "Problem 41: First Missing Positive - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for First Missing Positive",
        "output": "Expected output for First Missing Positive",
        "explanation": "Explanation of how to solve First Missing Positive"
      }
    ],
    "pseudocode": "Algorithm for First Missing Positive:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for First Missing Positive\ndef solve_41():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for First Missing Positive",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 42,
    "title": "Trapping Rain Water",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming",
      "Stack"
    ],
    "acceptance": "60.1%",
    "fullDescription": "Compute how much water can be trapped after raining using dynamic programming approach.",
    "testCases": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "Total trapped water is 6 units."
      }
    ],
    "pseudocode": "Precompute left and right max heights\nCalculate trapped water for each position",
    "pythonCode": "DP with precomputed arrays",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "Precompute max heights",
      "Calculate trapped water",
      "DP optimization"
    ]
  },
  {
    "id": 43,
    "title": "Multiply Strings",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "53%",
    "fullDescription": "Problem 43: Multiply Strings - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Multiply Strings",
        "output": "Expected output for Multiply Strings",
        "explanation": "Explanation of how to solve Multiply Strings"
      }
    ],
    "pseudocode": "Algorithm for Multiply Strings:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Multiply Strings\ndef solve_43():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Multiply Strings",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 44,
    "title": "Wildcard Matching",
    "difficulty": "Hard",
    "tags": [
      "String",
      "Dynamic Programming",
      "Greedy",
      "Recursion"
    ],
    "acceptance": "27.1%",
    "fullDescription": "Implement wildcard pattern matching with support for '?' and '*' using dynamic programming.",
    "testCases": [
      {
        "input": "s = \"aa\", p = \"*\"",
        "output": "true",
        "explanation": "'*' matches any sequence."
      }
    ],
    "pseudocode": "DP approach for wildcard matching\nHandle ? and * operators",
    "pythonCode": "DP table for wildcard matching",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)",
    "keyInsights": [
      "Handle ? and * operators",
      "DP approach",
      "Pattern matching"
    ]
  },
  {
    "id": 45,
    "title": "Jump Game II",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "acceptance": "37.1%",
    "fullDescription": "Find minimum number of jumps to reach the last index using dynamic programming.",
    "testCases": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "2",
        "explanation": "Jump from index 0 to 1, then to last."
      }
    ],
    "pseudocode": "Greedy approach with jumps\nTrack reachable range",
    "pythonCode": "Greedy jump selection",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Greedy approach",
      "Track reachable range",
      "Jump optimization"
    ]
  },
  {
    "id": 46,
    "title": "Permutations",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "56%",
    "fullDescription": "Problem 46: Permutations - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Permutations",
        "output": "Expected output for Permutations",
        "explanation": "Explanation of how to solve Permutations"
      }
    ],
    "pseudocode": "Algorithm for Permutations:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Permutations\ndef solve_46():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Permutations",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 47,
    "title": "Permutations II",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "57%",
    "fullDescription": "Problem 47: Permutations II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Permutations II",
        "output": "Expected output for Permutations II",
        "explanation": "Explanation of how to solve Permutations II"
      }
    ],
    "pseudocode": "Algorithm for Permutations II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Permutations II\ndef solve_47():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Permutations II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 48,
    "title": "Rotate Image",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "58%",
    "fullDescription": "Problem 48: Rotate Image - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Rotate Image",
        "output": "Expected output for Rotate Image",
        "explanation": "Explanation of how to solve Rotate Image"
      }
    ],
    "pseudocode": "Algorithm for Rotate Image:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Rotate Image\ndef solve_48():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Rotate Image",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 49,
    "title": "Group Anagrams",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "59%",
    "fullDescription": "Problem 49: Group Anagrams - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Group Anagrams",
        "output": "Expected output for Group Anagrams",
        "explanation": "Explanation of how to solve Group Anagrams"
      }
    ],
    "pseudocode": "Algorithm for Group Anagrams:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Group Anagrams\ndef solve_49():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Group Anagrams",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 50,
    "title": "Pow(x, n)",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "60%",
    "fullDescription": "Problem 50: Pow(x, n) - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Pow(x, n)",
        "output": "Expected output for Pow(x, n)",
        "explanation": "Explanation of how to solve Pow(x, n)"
      }
    ],
    "pseudocode": "Algorithm for Pow(x, n):\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Pow(x, n)\ndef solve_50():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Pow(x, n)",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 51,
    "title": "N-Queens",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "61%",
    "fullDescription": "Problem 51: N-Queens - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for N-Queens",
        "output": "Expected output for N-Queens",
        "explanation": "Explanation of how to solve N-Queens"
      }
    ],
    "pseudocode": "Algorithm for N-Queens:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for N-Queens\ndef solve_51():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for N-Queens",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 52,
    "title": "N-Queens II",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "62%",
    "fullDescription": "Problem 52: N-Queens II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for N-Queens II",
        "output": "Expected output for N-Queens II",
        "explanation": "Explanation of how to solve N-Queens II"
      }
    ],
    "pseudocode": "Algorithm for N-Queens II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for N-Queens II\ndef solve_52():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for N-Queens II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 53,
    "title": "Maximum Subarray",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "63%",
    "fullDescription": "Problem 53: Maximum Subarray - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Maximum Subarray",
        "output": "Expected output for Maximum Subarray",
        "explanation": "Explanation of how to solve Maximum Subarray"
      }
    ],
    "pseudocode": "Algorithm for Maximum Subarray:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Maximum Subarray\ndef solve_53():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Maximum Subarray",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 54,
    "title": "Spiral Matrix",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "64%",
    "fullDescription": "Problem 54: Spiral Matrix - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Spiral Matrix",
        "output": "Expected output for Spiral Matrix",
        "explanation": "Explanation of how to solve Spiral Matrix"
      }
    ],
    "pseudocode": "Algorithm for Spiral Matrix:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Spiral Matrix\ndef solve_54():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Spiral Matrix",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 55,
    "title": "Jump Game",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "acceptance": "37.1%",
    "fullDescription": "Determine if you can reach the last index using dynamic programming approach.",
    "testCases": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "true",
        "explanation": "Can jump to the last index."
      }
    ],
    "pseudocode": "Track maximum reachable position\nGreedy approach",
    "pythonCode": "Greedy approach",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Track reachable position",
      "Greedy approach",
      "DP optimization"
    ]
  },
  {
    "id": 56,
    "title": "Merge Intervals",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "66%",
    "fullDescription": "Problem 56: Merge Intervals - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Merge Intervals",
        "output": "Expected output for Merge Intervals",
        "explanation": "Explanation of how to solve Merge Intervals"
      }
    ],
    "pseudocode": "Algorithm for Merge Intervals:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Merge Intervals\ndef solve_56():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Merge Intervals",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 57,
    "title": "Insert Interval",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "67%",
    "fullDescription": "Problem 57: Insert Interval - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Insert Interval",
        "output": "Expected output for Insert Interval",
        "explanation": "Explanation of how to solve Insert Interval"
      }
    ],
    "pseudocode": "Algorithm for Insert Interval:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Insert Interval\ndef solve_57():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Insert Interval",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 58,
    "title": "Length of Last Word",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "68%",
    "fullDescription": "Problem 58: Length of Last Word - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Length of Last Word",
        "output": "Expected output for Length of Last Word",
        "explanation": "Explanation of how to solve Length of Last Word"
      }
    ],
    "pseudocode": "Algorithm for Length of Last Word:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Length of Last Word\ndef solve_58():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Length of Last Word",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 59,
    "title": "Spiral Matrix II",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "69%",
    "fullDescription": "Problem 59: Spiral Matrix II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Spiral Matrix II",
        "output": "Expected output for Spiral Matrix II",
        "explanation": "Explanation of how to solve Spiral Matrix II"
      }
    ],
    "pseudocode": "Algorithm for Spiral Matrix II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Spiral Matrix II\ndef solve_59():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Spiral Matrix II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 60,
    "title": "Permutation Sequence",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "40%",
    "fullDescription": "Problem 60: Permutation Sequence - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Permutation Sequence",
        "output": "Expected output for Permutation Sequence",
        "explanation": "Explanation of how to solve Permutation Sequence"
      }
    ],
    "pseudocode": "Algorithm for Permutation Sequence:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Permutation Sequence\ndef solve_60():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Permutation Sequence",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 61,
    "title": "Rotate List",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "41%",
    "fullDescription": "Problem 61: Rotate List - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Rotate List",
        "output": "Expected output for Rotate List",
        "explanation": "Explanation of how to solve Rotate List"
      }
    ],
    "pseudocode": "Algorithm for Rotate List:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Rotate List\ndef solve_61():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Rotate List",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 62,
    "title": "Unique Paths",
    "difficulty": "Medium",
    "tags": [
      "Math",
      "Dynamic Programming",
      "Combinatorics"
    ],
    "acceptance": "62.1%",
    "fullDescription": "Find number of unique paths from top-left to bottom-right using dynamic programming.",
    "testCases": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "28 unique paths exist."
      }
    ],
    "pseudocode": "DP grid with path counting\nFill from top-left to bottom-right",
    "pythonCode": "DP grid filling approach",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)",
    "keyInsights": [
      "DP grid",
      "Path counting",
      "Fill systematically"
    ]
  },
  {
    "id": 63,
    "title": "Unique Paths II",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "acceptance": "37.1%",
    "fullDescription": "Find unique paths with obstacles using dynamic programming.",
    "testCases": [
      {
        "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "Two paths avoiding obstacle."
      }
    ],
    "pseudocode": "DP with obstacle checking\nSkip blocked cells",
    "pythonCode": "DP with obstacle handling",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)",
    "keyInsights": [
      "Check obstacles",
      "DP approach",
      "Handle blocked cells"
    ]
  },
  {
    "id": 64,
    "title": "Minimum Path Sum",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "acceptance": "62.1%",
    "fullDescription": "Find minimum path sum from top-left to bottom-right using dynamic programming.",
    "testCases": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "Path 1\u21923\u21921\u21921\u21921 minimizes sum to 7."
      }
    ],
    "pseudocode": "DP grid with path cost\nChoose minimum path at each step",
    "pythonCode": "DP grid filling with cost",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)",
    "keyInsights": [
      "DP approach",
      "Choose minimum path",
      "Cost optimization"
    ]
  },
  {
    "id": 65,
    "title": "Valid Number",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "45%",
    "fullDescription": "Problem 65: Valid Number - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Valid Number",
        "output": "Expected output for Valid Number",
        "explanation": "Explanation of how to solve Valid Number"
      }
    ],
    "pseudocode": "Algorithm for Valid Number:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Valid Number\ndef solve_65():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Valid Number",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 66,
    "title": "Plus One",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "46%",
    "fullDescription": "Problem 66: Plus One - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Plus One",
        "output": "Expected output for Plus One",
        "explanation": "Explanation of how to solve Plus One"
      }
    ],
    "pseudocode": "Algorithm for Plus One:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Plus One\ndef solve_66():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Plus One",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 67,
    "title": "Add Binary",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "47%",
    "fullDescription": "Problem 67: Add Binary - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Add Binary",
        "output": "Expected output for Add Binary",
        "explanation": "Explanation of how to solve Add Binary"
      }
    ],
    "pseudocode": "Algorithm for Add Binary:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Add Binary\ndef solve_67():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Add Binary",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 68,
    "title": "Text Justification",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "48%",
    "fullDescription": "Problem 68: Text Justification - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Text Justification",
        "output": "Expected output for Text Justification",
        "explanation": "Explanation of how to solve Text Justification"
      }
    ],
    "pseudocode": "Algorithm for Text Justification:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Text Justification\ndef solve_68():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Text Justification",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 69,
    "title": "Sqrt(x)",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "49%",
    "fullDescription": "Problem 69: Sqrt(x) - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Sqrt(x)",
        "output": "Expected output for Sqrt(x)",
        "explanation": "Explanation of how to solve Sqrt(x)"
      }
    ],
    "pseudocode": "Algorithm for Sqrt(x):\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Sqrt(x)\ndef solve_69():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Sqrt(x)",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 70,
    "title": "Climbing Stairs",
    "difficulty": "Easy",
    "tags": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "acceptance": "52.1%",
    "fullDescription": "Find number of distinct ways to climb to the top using dynamic programming.",
    "testCases": [
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "Three ways: 1+1+1, 1+2, 2+1."
      }
    ],
    "pseudocode": "Fibonacci sequence\nDP with previous two values",
    "pythonCode": "DP with Fibonacci pattern",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Fibonacci pattern",
      "DP approach",
      "Previous two values"
    ]
  },
  {
    "id": 71,
    "title": "Simplify Path",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "51%",
    "fullDescription": "Problem 71: Simplify Path - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Simplify Path",
        "output": "Expected output for Simplify Path",
        "explanation": "Explanation of how to solve Simplify Path"
      }
    ],
    "pseudocode": "Algorithm for Simplify Path:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Simplify Path\ndef solve_71():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Simplify Path",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 72,
    "title": "Edit Distance",
    "difficulty": "Hard",
    "tags": [
      "String",
      "Dynamic Programming"
    ],
    "acceptance": "52.1%",
    "fullDescription": "Find minimum operations to convert word1 to word2 using dynamic programming.",
    "testCases": [
      {
        "input": "word1 = \"horse\", word2 = \"ros\"",
        "output": "3",
        "explanation": "horse \u2192 rorse \u2192 rose \u2192 ros"
      }
    ],
    "pseudocode": "DP matrix for edit operations\nHandle insert, delete, replace",
    "pythonCode": "DP table approach",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)",
    "keyInsights": [
      "DP matrix",
      "Three operations",
      "Minimum cost path"
    ]
  },
  {
    "id": 73,
    "title": "Set Matrix Zeroes",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "53%",
    "fullDescription": "Problem 73: Set Matrix Zeroes - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Set Matrix Zeroes",
        "output": "Expected output for Set Matrix Zeroes",
        "explanation": "Explanation of how to solve Set Matrix Zeroes"
      }
    ],
    "pseudocode": "Algorithm for Set Matrix Zeroes:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Set Matrix Zeroes\ndef solve_73():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Set Matrix Zeroes",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 74,
    "title": "Search a 2D Matrix",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "54%",
    "fullDescription": "Problem 74: Search a 2D Matrix - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Search a 2D Matrix",
        "output": "Expected output for Search a 2D Matrix",
        "explanation": "Explanation of how to solve Search a 2D Matrix"
      }
    ],
    "pseudocode": "Algorithm for Search a 2D Matrix:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Search a 2D Matrix\ndef solve_74():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Search a 2D Matrix",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 75,
    "title": "Sort Colors",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "55%",
    "fullDescription": "Problem 75: Sort Colors - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Sort Colors",
        "output": "Expected output for Sort Colors",
        "explanation": "Explanation of how to solve Sort Colors"
      }
    ],
    "pseudocode": "Algorithm for Sort Colors:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Sort Colors\ndef solve_75():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Sort Colors",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 76,
    "title": "Minimum Window Substring",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "56%",
    "fullDescription": "Problem 76: Minimum Window Substring - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Minimum Window Substring",
        "output": "Expected output for Minimum Window Substring",
        "explanation": "Explanation of how to solve Minimum Window Substring"
      }
    ],
    "pseudocode": "Algorithm for Minimum Window Substring:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Minimum Window Substring\ndef solve_76():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Minimum Window Substring",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 77,
    "title": "Combinations",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "57%",
    "fullDescription": "Problem 77: Combinations - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Combinations",
        "output": "Expected output for Combinations",
        "explanation": "Explanation of how to solve Combinations"
      }
    ],
    "pseudocode": "Algorithm for Combinations:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Combinations\ndef solve_77():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Combinations",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 78,
    "title": "Subsets",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "58%",
    "fullDescription": "Problem 78: Subsets - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Subsets",
        "output": "Expected output for Subsets",
        "explanation": "Explanation of how to solve Subsets"
      }
    ],
    "pseudocode": "Algorithm for Subsets:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Subsets\ndef solve_78():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Subsets",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 79,
    "title": "Word Search",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "59%",
    "fullDescription": "Problem 79: Word Search - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Word Search",
        "output": "Expected output for Word Search",
        "explanation": "Explanation of how to solve Word Search"
      }
    ],
    "pseudocode": "Algorithm for Word Search:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Word Search\ndef solve_79():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Word Search",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 80,
    "title": "Remove Duplicates from Sorted Array II",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "60%",
    "fullDescription": "Problem 80: Remove Duplicates from Sorted Array II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Remove Duplicates from Sorted Array II",
        "output": "Expected output for Remove Duplicates from Sorted Array II",
        "explanation": "Explanation of how to solve Remove Duplicates from Sorted Array II"
      }
    ],
    "pseudocode": "Algorithm for Remove Duplicates from Sorted Array II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Remove Duplicates from Sorted Array II\ndef solve_80():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Remove Duplicates from Sorted Array II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 81,
    "title": "Search in Rotated Sorted Array II",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "61%",
    "fullDescription": "Problem 81: Search in Rotated Sorted Array II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Search in Rotated Sorted Array II",
        "output": "Expected output for Search in Rotated Sorted Array II",
        "explanation": "Explanation of how to solve Search in Rotated Sorted Array II"
      }
    ],
    "pseudocode": "Algorithm for Search in Rotated Sorted Array II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Search in Rotated Sorted Array II\ndef solve_81():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Search in Rotated Sorted Array II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 82,
    "title": "Remove Duplicates from Sorted List II",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "62%",
    "fullDescription": "Problem 82: Remove Duplicates from Sorted List II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Remove Duplicates from Sorted List II",
        "output": "Expected output for Remove Duplicates from Sorted List II",
        "explanation": "Explanation of how to solve Remove Duplicates from Sorted List II"
      }
    ],
    "pseudocode": "Algorithm for Remove Duplicates from Sorted List II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Remove Duplicates from Sorted List II\ndef solve_82():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Remove Duplicates from Sorted List II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 83,
    "title": "Remove Duplicates from Sorted List",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "63%",
    "fullDescription": "Problem 83: Remove Duplicates from Sorted List - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Remove Duplicates from Sorted List",
        "output": "Expected output for Remove Duplicates from Sorted List",
        "explanation": "Explanation of how to solve Remove Duplicates from Sorted List"
      }
    ],
    "pseudocode": "Algorithm for Remove Duplicates from Sorted List:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Remove Duplicates from Sorted List\ndef solve_83():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Remove Duplicates from Sorted List",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 84,
    "title": "Largest Rectangle in Histogram",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "acceptance": "47.1%",
    "fullDescription": "Find largest rectangle area in histogram using dynamic programming approach.",
    "testCases": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "Largest rectangle has area 10."
      }
    ],
    "pseudocode": "Monotonic stack approach\nCalculate area for each bar",
    "pythonCode": "Stack-based solution",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "Monotonic stack",
      "Calculate area",
      "DP optimization"
    ]
  },
  {
    "id": 85,
    "title": "Maximal Rectangle",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Stack",
      "Matrix"
    ],
    "acceptance": "47.1%",
    "fullDescription": "Find maximal rectangle containing only 1's using dynamic programming.",
    "testCases": [
      {
        "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
        "output": "6",
        "explanation": "Maximal rectangle has area 6."
      }
    ],
    "pseudocode": "Convert to histogram for each row\nUse largest rectangle approach",
    "pythonCode": "Histogram method for each row",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "Convert to histogram",
      "Use largest rectangle",
      "DP approach"
    ]
  },
  {
    "id": 86,
    "title": "Partition List",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "66%",
    "fullDescription": "Problem 86: Partition List - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Partition List",
        "output": "Expected output for Partition List",
        "explanation": "Explanation of how to solve Partition List"
      }
    ],
    "pseudocode": "Algorithm for Partition List:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Partition List\ndef solve_86():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Partition List",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 87,
    "title": "Scramble String",
    "difficulty": "Hard",
    "tags": [
      "String",
      "Dynamic Programming"
    ],
    "acceptance": "37.1%",
    "fullDescription": "Determine if s2 is a scrambled string of s1 using dynamic programming.",
    "testCases": [
      {
        "input": "s1 = \"great\", s2 = \"rgeat\"",
        "output": "true",
        "explanation": "s2 is a scrambled string of s1."
      }
    ],
    "pseudocode": "DP with substring checking\nCheck all possible splits",
    "pythonCode": "DP approach",
    "timeComplexity": "O(n\u2074)",
    "spaceComplexity": "O(n\u00b3)",
    "keyInsights": [
      "DP approach",
      "Check all splits",
      "Substring validation"
    ]
  },
  {
    "id": 88,
    "title": "Merge Sorted Array",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "68%",
    "fullDescription": "Problem 88: Merge Sorted Array - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Merge Sorted Array",
        "output": "Expected output for Merge Sorted Array",
        "explanation": "Explanation of how to solve Merge Sorted Array"
      }
    ],
    "pseudocode": "Algorithm for Merge Sorted Array:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Merge Sorted Array\ndef solve_88():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Merge Sorted Array",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 89,
    "title": "Gray Code",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "69%",
    "fullDescription": "Problem 89: Gray Code - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Gray Code",
        "output": "Expected output for Gray Code",
        "explanation": "Explanation of how to solve Gray Code"
      }
    ],
    "pseudocode": "Algorithm for Gray Code:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Gray Code\ndef solve_89():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Gray Code",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 90,
    "title": "Subsets II",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "40%",
    "fullDescription": "Problem 90: Subsets II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Subsets II",
        "output": "Expected output for Subsets II",
        "explanation": "Explanation of how to solve Subsets II"
      }
    ],
    "pseudocode": "Algorithm for Subsets II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Subsets II\ndef solve_90():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Subsets II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 91,
    "title": "Decode Ways",
    "difficulty": "Medium",
    "tags": [
      "String",
      "Dynamic Programming"
    ],
    "acceptance": "32.1%",
    "fullDescription": "Find number of ways to decode a string using dynamic programming.",
    "testCases": [
      {
        "input": "s = \"12\"",
        "output": "2",
        "explanation": "Could be decoded as 'AB' (1 2) or 'L' (12)."
      }
    ],
    "pseudocode": "DP with decoding rules\nCheck valid 1-digit and 2-digit codes",
    "pythonCode": "DP approach",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "DP approach",
      "Valid codes",
      "1-digit and 2-digit"
    ]
  },
  {
    "id": 92,
    "title": "Reverse Linked List II",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "42%",
    "fullDescription": "Problem 92: Reverse Linked List II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Reverse Linked List II",
        "output": "Expected output for Reverse Linked List II",
        "explanation": "Explanation of how to solve Reverse Linked List II"
      }
    ],
    "pseudocode": "Algorithm for Reverse Linked List II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Reverse Linked List II\ndef solve_92():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Reverse Linked List II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 93,
    "title": "Restore IP Addresses",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "43%",
    "fullDescription": "Problem 93: Restore IP Addresses - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Restore IP Addresses",
        "output": "Expected output for Restore IP Addresses",
        "explanation": "Explanation of how to solve Restore IP Addresses"
      }
    ],
    "pseudocode": "Algorithm for Restore IP Addresses:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Restore IP Addresses\ndef solve_93():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Restore IP Addresses",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 94,
    "title": "Binary Tree Inorder Traversal",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "44%",
    "fullDescription": "Problem 94: Binary Tree Inorder Traversal - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Binary Tree Inorder Traversal",
        "output": "Expected output for Binary Tree Inorder Traversal",
        "explanation": "Explanation of how to solve Binary Tree Inorder Traversal"
      }
    ],
    "pseudocode": "Algorithm for Binary Tree Inorder Traversal:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Binary Tree Inorder Traversal\ndef solve_94():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Binary Tree Inorder Traversal",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 95,
    "title": "Unique Binary Search Trees II",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming",
      "Tree",
      "Binary Search Tree",
      "Backtracking"
    ],
    "acceptance": "52.1%",
    "fullDescription": "Generate all structurally unique BST's using dynamic programming.",
    "testCases": [
      {
        "input": "n = 3",
        "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
        "explanation": "All unique BSTs."
      }
    ],
    "pseudocode": "Recursive tree building\nUse Catalan numbers",
    "pythonCode": "Recursive approach",
    "timeComplexity": "O(4^n/\u221an)",
    "spaceComplexity": "O(4^n/\u221an)",
    "keyInsights": [
      "Recursive building",
      "Catalan numbers",
      "DP optimization"
    ]
  },
  {
    "id": 96,
    "title": "Unique Binary Search Trees",
    "difficulty": "Medium",
    "tags": [
      "Math",
      "Dynamic Programming",
      "Tree",
      "Binary Search Tree"
    ],
    "acceptance": "62.1%",
    "fullDescription": "Count structurally unique BST's using dynamic programming.",
    "testCases": [
      {
        "input": "n = 3",
        "output": "5",
        "explanation": "5 unique BSTs exist."
      }
    ],
    "pseudocode": "Catalan numbers\nDP with formula",
    "pythonCode": "DP with Catalan numbers",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "Catalan numbers",
      "DP approach",
      "Formula application"
    ]
  },
  {
    "id": 97,
    "title": "Interleaving String",
    "difficulty": "Medium",
    "tags": [
      "String",
      "Dynamic Programming"
    ],
    "acceptance": "37.1%",
    "fullDescription": "Check if s3 is formed by interleaving s1 and s2 using dynamic programming.",
    "testCases": [
      {
        "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
        "output": "true",
        "explanation": "s3 is interleaved from s1 and s2."
      }
    ],
    "pseudocode": "DP matrix for interleaving\nCheck all possibilities",
    "pythonCode": "DP table approach",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)",
    "keyInsights": [
      "DP matrix",
      "Check interleaving",
      "All possibilities"
    ]
  },
  {
    "id": 98,
    "title": "Validate Binary Search Tree",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "48%",
    "fullDescription": "Problem 98: Validate Binary Search Tree - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Validate Binary Search Tree",
        "output": "Expected output for Validate Binary Search Tree",
        "explanation": "Explanation of how to solve Validate Binary Search Tree"
      }
    ],
    "pseudocode": "Algorithm for Validate Binary Search Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Validate Binary Search Tree\ndef solve_98():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Validate Binary Search Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 99,
    "title": "Recover Binary Search Tree",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "49%",
    "fullDescription": "Problem 99: Recover Binary Search Tree - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Recover Binary Search Tree",
        "output": "Expected output for Recover Binary Search Tree",
        "explanation": "Explanation of how to solve Recover Binary Search Tree"
      }
    ],
    "pseudocode": "Algorithm for Recover Binary Search Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Recover Binary Search Tree\ndef solve_99():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Recover Binary Search Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 100,
    "title": "Same Tree",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "50%",
    "fullDescription": "Problem 100: Same Tree - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Same Tree",
        "output": "Expected output for Same Tree",
        "explanation": "Explanation of how to solve Same Tree"
      }
    ],
    "pseudocode": "Algorithm for Same Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Same Tree\ndef solve_100():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Same Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 101,
    "title": "Symmetric Tree",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "51%",
    "fullDescription": "Problem 101: Symmetric Tree - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Symmetric Tree",
        "output": "Expected output for Symmetric Tree",
        "explanation": "Explanation of how to solve Symmetric Tree"
      }
    ],
    "pseudocode": "Algorithm for Symmetric Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Symmetric Tree\ndef solve_101():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Symmetric Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 102,
    "title": "Binary Tree Level Order Traversal",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "52%",
    "fullDescription": "Problem 102: Binary Tree Level Order Traversal - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Binary Tree Level Order Traversal",
        "output": "Expected output for Binary Tree Level Order Traversal",
        "explanation": "Explanation of how to solve Binary Tree Level Order Traversal"
      }
    ],
    "pseudocode": "Algorithm for Binary Tree Level Order Traversal:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Binary Tree Level Order Traversal\ndef solve_102():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Binary Tree Level Order Traversal",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 103,
    "title": "Binary Tree Zigzag Level Order Traversal",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "53%",
    "fullDescription": "Problem 103: Binary Tree Zigzag Level Order Traversal - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Binary Tree Zigzag Level Order Traversal",
        "output": "Expected output for Binary Tree Zigzag Level Order Traversal",
        "explanation": "Explanation of how to solve Binary Tree Zigzag Level Order Traversal"
      }
    ],
    "pseudocode": "Algorithm for Binary Tree Zigzag Level Order Traversal:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Binary Tree Zigzag Level Order Traversal\ndef solve_103():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Binary Tree Zigzag Level Order Traversal",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 104,
    "title": "Maximum Depth of Binary Tree",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "54%",
    "fullDescription": "Problem 104: Maximum Depth of Binary Tree - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Maximum Depth of Binary Tree",
        "output": "Expected output for Maximum Depth of Binary Tree",
        "explanation": "Explanation of how to solve Maximum Depth of Binary Tree"
      }
    ],
    "pseudocode": "Algorithm for Maximum Depth of Binary Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Maximum Depth of Binary Tree\ndef solve_104():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Maximum Depth of Binary Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 105,
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "55%",
    "fullDescription": "Problem 105: Construct Binary Tree from Preorder and Inorder Traversal - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Construct Binary Tree from Preorder and Inorder Traversal",
        "output": "Expected output for Construct Binary Tree from Preorder and Inorder Traversal",
        "explanation": "Explanation of how to solve Construct Binary Tree from Preorder and Inorder Traversal"
      }
    ],
    "pseudocode": "Algorithm for Construct Binary Tree from Preorder and Inorder Traversal:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Construct Binary Tree from Preorder and Inorder Traversal\ndef solve_105():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Construct Binary Tree from Preorder and Inorder Traversal",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 106,
    "title": "Construct Binary Tree from Inorder and Postorder Traversal",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "56%",
    "fullDescription": "Problem 106: Construct Binary Tree from Inorder and Postorder Traversal - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Construct Binary Tree from Inorder and Postorder Traversal",
        "output": "Expected output for Construct Binary Tree from Inorder and Postorder Traversal",
        "explanation": "Explanation of how to solve Construct Binary Tree from Inorder and Postorder Traversal"
      }
    ],
    "pseudocode": "Algorithm for Construct Binary Tree from Inorder and Postorder Traversal:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Construct Binary Tree from Inorder and Postorder Traversal\ndef solve_106():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Construct Binary Tree from Inorder and Postorder Traversal",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 107,
    "title": "Binary Tree Level Order Traversal II",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "57%",
    "fullDescription": "Problem 107: Binary Tree Level Order Traversal II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Binary Tree Level Order Traversal II",
        "output": "Expected output for Binary Tree Level Order Traversal II",
        "explanation": "Explanation of how to solve Binary Tree Level Order Traversal II"
      }
    ],
    "pseudocode": "Algorithm for Binary Tree Level Order Traversal II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Binary Tree Level Order Traversal II\ndef solve_107():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Binary Tree Level Order Traversal II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 108,
    "title": "Convert Sorted Array to Binary Search Tree",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "58%",
    "fullDescription": "Problem 108: Convert Sorted Array to Binary Search Tree - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Convert Sorted Array to Binary Search Tree",
        "output": "Expected output for Convert Sorted Array to Binary Search Tree",
        "explanation": "Explanation of how to solve Convert Sorted Array to Binary Search Tree"
      }
    ],
    "pseudocode": "Algorithm for Convert Sorted Array to Binary Search Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Convert Sorted Array to Binary Search Tree\ndef solve_108():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Convert Sorted Array to Binary Search Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 109,
    "title": "Convert Sorted List to Binary Search Tree",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "59%",
    "fullDescription": "Problem 109: Convert Sorted List to Binary Search Tree - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Convert Sorted List to Binary Search Tree",
        "output": "Expected output for Convert Sorted List to Binary Search Tree",
        "explanation": "Explanation of how to solve Convert Sorted List to Binary Search Tree"
      }
    ],
    "pseudocode": "Algorithm for Convert Sorted List to Binary Search Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Convert Sorted List to Binary Search Tree\ndef solve_109():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Convert Sorted List to Binary Search Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 110,
    "title": "Balanced Binary Tree",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "60%",
    "fullDescription": "Problem 110: Balanced Binary Tree - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Balanced Binary Tree",
        "output": "Expected output for Balanced Binary Tree",
        "explanation": "Explanation of how to solve Balanced Binary Tree"
      }
    ],
    "pseudocode": "Algorithm for Balanced Binary Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Balanced Binary Tree\ndef solve_110():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Balanced Binary Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 111,
    "title": "Minimum Depth of Binary Tree",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "61%",
    "fullDescription": "Problem 111: Minimum Depth of Binary Tree - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Minimum Depth of Binary Tree",
        "output": "Expected output for Minimum Depth of Binary Tree",
        "explanation": "Explanation of how to solve Minimum Depth of Binary Tree"
      }
    ],
    "pseudocode": "Algorithm for Minimum Depth of Binary Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Minimum Depth of Binary Tree\ndef solve_111():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Minimum Depth of Binary Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 112,
    "title": "Path Sum",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "62%",
    "fullDescription": "Problem 112: Path Sum - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Path Sum",
        "output": "Expected output for Path Sum",
        "explanation": "Explanation of how to solve Path Sum"
      }
    ],
    "pseudocode": "Algorithm for Path Sum:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Path Sum\ndef solve_112():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Path Sum",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 113,
    "title": "Path Sum II",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "63%",
    "fullDescription": "Problem 113: Path Sum II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Path Sum II",
        "output": "Expected output for Path Sum II",
        "explanation": "Explanation of how to solve Path Sum II"
      }
    ],
    "pseudocode": "Algorithm for Path Sum II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Path Sum II\ndef solve_113():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Path Sum II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 114,
    "title": "Flatten Binary Tree to Linked List",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "64%",
    "fullDescription": "Problem 114: Flatten Binary Tree to Linked List - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Flatten Binary Tree to Linked List",
        "output": "Expected output for Flatten Binary Tree to Linked List",
        "explanation": "Explanation of how to solve Flatten Binary Tree to Linked List"
      }
    ],
    "pseudocode": "Algorithm for Flatten Binary Tree to Linked List:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Flatten Binary Tree to Linked List\ndef solve_114():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Flatten Binary Tree to Linked List",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 115,
    "title": "Distinct Subsequences",
    "difficulty": "Hard",
    "tags": [
      "String",
      "Dynamic Programming"
    ],
    "acceptance": "42.1%",
    "fullDescription": "Count distinct subsequences of s that equal t using dynamic programming.",
    "testCases": [
      {
        "input": "s = \"rabbbit\", t = \"rabbit\"",
        "output": "3",
        "explanation": "3 distinct subsequences."
      }
    ],
    "pseudocode": "DP matrix for subsequence counting\nMatch characters",
    "pythonCode": "DP approach",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)",
    "keyInsights": [
      "DP matrix",
      "Subsequence counting",
      "Character matching"
    ]
  },
  {
    "id": 116,
    "title": "Populating Next Right Pointers in Each Node",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "66%",
    "fullDescription": "Problem 116: Populating Next Right Pointers in Each Node - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Populating Next Right Pointers in Each Node",
        "output": "Expected output for Populating Next Right Pointers in Each Node",
        "explanation": "Explanation of how to solve Populating Next Right Pointers in Each Node"
      }
    ],
    "pseudocode": "Algorithm for Populating Next Right Pointers in Each Node:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Populating Next Right Pointers in Each Node\ndef solve_116():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Populating Next Right Pointers in Each Node",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 117,
    "title": "Populating Next Right Pointers in Each Node II",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "67%",
    "fullDescription": "Problem 117: Populating Next Right Pointers in Each Node II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Populating Next Right Pointers in Each Node II",
        "output": "Expected output for Populating Next Right Pointers in Each Node II",
        "explanation": "Explanation of how to solve Populating Next Right Pointers in Each Node II"
      }
    ],
    "pseudocode": "Algorithm for Populating Next Right Pointers in Each Node II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Populating Next Right Pointers in Each Node II\ndef solve_117():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Populating Next Right Pointers in Each Node II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 118,
    "title": "Pascal's Triangle",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "68%",
    "fullDescription": "Problem 118: Pascal's Triangle - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Pascal's Triangle",
        "output": "Expected output for Pascal's Triangle",
        "explanation": "Explanation of how to solve Pascal's Triangle"
      }
    ],
    "pseudocode": "Algorithm for Pascal's Triangle:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Pascal's Triangle\ndef solve_118():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Pascal's Triangle",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 119,
    "title": "Pascal's Triangle II",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "69%",
    "fullDescription": "Problem 119: Pascal's Triangle II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Pascal's Triangle II",
        "output": "Expected output for Pascal's Triangle II",
        "explanation": "Explanation of how to solve Pascal's Triangle II"
      }
    ],
    "pseudocode": "Algorithm for Pascal's Triangle II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Pascal's Triangle II\ndef solve_119():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Pascal's Triangle II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 120,
    "title": "Triangle",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "Dynamic Programming"
    ],
    "acceptance": "52.1%",
    "fullDescription": "Find minimum path sum from top to bottom of triangle using dynamic programming.",
    "testCases": [
      {
        "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
        "output": "11",
        "explanation": "Path 2\u21923\u21925\u21921 minimizes sum to 11."
      }
    ],
    "pseudocode": "Bottom-up DP\nChoose minimum of adjacent elements",
    "pythonCode": "Bottom-up DP approach",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(n\u00b2)",
    "keyInsights": [
      "Bottom-up DP",
      "Choose minimum",
      "Adjacent elements"
    ]
  },
  {
    "id": 121,
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "Dynamic Programming"
    ],
    "acceptance": "52.1%",
    "fullDescription": "Find maximum profit from one transaction using dynamic programming.",
    "testCases": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy at 1, sell at 6 for profit 5."
      }
    ],
    "pseudocode": "Track minimum price\nCalculate max profit",
    "pythonCode": "DP with min tracking",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Track minimum",
      "Calculate profit",
      "DP optimization"
    ]
  },
  {
    "id": 122,
    "title": "Best Time to Buy and Sell Stock II",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "acceptance": "62.1%",
    "fullDescription": "Find maximum profit from multiple transactions using dynamic programming.",
    "testCases": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "7",
        "explanation": "Buy at 1, sell at 5; buy at 3, sell at 6."
      }
    ],
    "pseudocode": "Greedy approach\nBuy low, sell high",
    "pythonCode": "Greedy with DP",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Greedy approach",
      "Buy low sell high",
      "DP optimization"
    ]
  },
  {
    "id": 123,
    "title": "Best Time to Buy and Sell Stock III",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "Dynamic Programming"
    ],
    "acceptance": "47.1%",
    "fullDescription": "Find maximum profit from at most two transactions using dynamic programming.",
    "testCases": [
      {
        "input": "prices = [3,3,5,0,0,3,1,4]",
        "output": "6",
        "explanation": "Buy at 3, sell at 5; buy at 0, sell at 4."
      }
    ],
    "pseudocode": "DP with state machine\nTrack buy/sell states",
    "pythonCode": "DP state machine",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "State machine",
      "Buy/sell states",
      "DP approach"
    ]
  },
  {
    "id": 124,
    "title": "Binary Tree Maximum Path Sum",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Depth-First Search",
      "Dynamic Programming"
    ],
    "acceptance": "37.1%",
    "fullDescription": "Find maximum path sum in binary tree using dynamic programming.",
    "testCases": [
      {
        "input": "root = [1,2,3]",
        "output": "6",
        "explanation": "Path 2\u21921\u21923 has maximum sum 6."
      }
    ],
    "pseudocode": "DFS with path tracking\nUpdate global maximum",
    "pythonCode": "DFS with DP",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "DFS approach",
      "Path tracking",
      "Global maximum"
    ]
  },
  {
    "id": 125,
    "title": "Valid Palindrome",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "45%",
    "fullDescription": "Problem 125: Valid Palindrome - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Valid Palindrome",
        "output": "Expected output for Valid Palindrome",
        "explanation": "Explanation of how to solve Valid Palindrome"
      }
    ],
    "pseudocode": "Algorithm for Valid Palindrome:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Valid Palindrome\ndef solve_125():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Valid Palindrome",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 126,
    "title": "Word Ladder II",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "46%",
    "fullDescription": "Problem 126: Word Ladder II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Word Ladder II",
        "output": "Expected output for Word Ladder II",
        "explanation": "Explanation of how to solve Word Ladder II"
      }
    ],
    "pseudocode": "Algorithm for Word Ladder II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Word Ladder II\ndef solve_126():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Word Ladder II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 127,
    "title": "Word Ladder",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "47%",
    "fullDescription": "Problem 127: Word Ladder - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Word Ladder",
        "output": "Expected output for Word Ladder",
        "explanation": "Explanation of how to solve Word Ladder"
      }
    ],
    "pseudocode": "Algorithm for Word Ladder:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Word Ladder\ndef solve_127():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Word Ladder",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 128,
    "title": "Longest Consecutive Sequence",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "48%",
    "fullDescription": "Problem 128: Longest Consecutive Sequence - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Longest Consecutive Sequence",
        "output": "Expected output for Longest Consecutive Sequence",
        "explanation": "Explanation of how to solve Longest Consecutive Sequence"
      }
    ],
    "pseudocode": "Algorithm for Longest Consecutive Sequence:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Longest Consecutive Sequence\ndef solve_128():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Longest Consecutive Sequence",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 129,
    "title": "Sum Root to Leaf Numbers",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "49%",
    "fullDescription": "Problem 129: Sum Root to Leaf Numbers - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Sum Root to Leaf Numbers",
        "output": "Expected output for Sum Root to Leaf Numbers",
        "explanation": "Explanation of how to solve Sum Root to Leaf Numbers"
      }
    ],
    "pseudocode": "Algorithm for Sum Root to Leaf Numbers:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Sum Root to Leaf Numbers\ndef solve_129():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Sum Root to Leaf Numbers",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 130,
    "title": "Surrounded Regions",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "50%",
    "fullDescription": "Problem 130: Surrounded Regions - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Surrounded Regions",
        "output": "Expected output for Surrounded Regions",
        "explanation": "Explanation of how to solve Surrounded Regions"
      }
    ],
    "pseudocode": "Algorithm for Surrounded Regions:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Surrounded Regions\ndef solve_130():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Surrounded Regions",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 131,
    "title": "Palindrome Partitioning",
    "difficulty": "Medium",
    "tags": [
      "String",
      "Dynamic Programming",
      "Backtracking"
    ],
    "acceptance": "62.1%",
    "fullDescription": "Partition string into palindromic substrings using dynamic programming.",
    "testCases": [
      {
        "input": "s = \"aab\"",
        "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
        "explanation": "All palindromic partitions."
      }
    ],
    "pseudocode": "Backtracking with palindrome check\nUse DP for optimization",
    "pythonCode": "Backtracking with DP",
    "timeComplexity": "O(n \u00d7 2^n)",
    "spaceComplexity": "O(n\u00b2)",
    "keyInsights": [
      "Backtracking",
      "Palindrome check",
      "DP optimization"
    ]
  },
  {
    "id": 132,
    "title": "Palindrome Partitioning II",
    "difficulty": "Hard",
    "tags": [
      "String",
      "Dynamic Programming"
    ],
    "acceptance": "37.1%",
    "fullDescription": "Find minimum cuts for palindrome partitioning using dynamic programming.",
    "testCases": [
      {
        "input": "s = \"aab\"",
        "output": "1",
        "explanation": "Cut after 'aa' to get palindromes."
      }
    ],
    "pseudocode": "DP for palindrome check\nDP for minimum cuts",
    "pythonCode": "Double DP approach",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(n\u00b2)",
    "keyInsights": [
      "Palindrome DP",
      "Minimum cuts",
      "Double DP"
    ]
  },
  {
    "id": 133,
    "title": "Clone Graph",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "53%",
    "fullDescription": "Problem 133: Clone Graph - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Clone Graph",
        "output": "Expected output for Clone Graph",
        "explanation": "Explanation of how to solve Clone Graph"
      }
    ],
    "pseudocode": "Algorithm for Clone Graph:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Clone Graph\ndef solve_133():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Clone Graph",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 134,
    "title": "Gas Station",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "54%",
    "fullDescription": "Problem 134: Gas Station - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Gas Station",
        "output": "Expected output for Gas Station",
        "explanation": "Explanation of how to solve Gas Station"
      }
    ],
    "pseudocode": "Algorithm for Gas Station:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Gas Station\ndef solve_134():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Gas Station",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 135,
    "title": "Candy",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "55%",
    "fullDescription": "Problem 135: Candy - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Candy",
        "output": "Expected output for Candy",
        "explanation": "Explanation of how to solve Candy"
      }
    ],
    "pseudocode": "Algorithm for Candy:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Candy\ndef solve_135():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Candy",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 136,
    "title": "Single Number",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "56%",
    "fullDescription": "Problem 136: Single Number - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Single Number",
        "output": "Expected output for Single Number",
        "explanation": "Explanation of how to solve Single Number"
      }
    ],
    "pseudocode": "Algorithm for Single Number:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Single Number\ndef solve_136():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Single Number",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 137,
    "title": "Single Number II",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "57%",
    "fullDescription": "Problem 137: Single Number II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Single Number II",
        "output": "Expected output for Single Number II",
        "explanation": "Explanation of how to solve Single Number II"
      }
    ],
    "pseudocode": "Algorithm for Single Number II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Single Number II\ndef solve_137():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Single Number II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 138,
    "title": "Copy List with Random Pointer",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "58%",
    "fullDescription": "Problem 138: Copy List with Random Pointer - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Copy List with Random Pointer",
        "output": "Expected output for Copy List with Random Pointer",
        "explanation": "Explanation of how to solve Copy List with Random Pointer"
      }
    ],
    "pseudocode": "Algorithm for Copy List with Random Pointer:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Copy List with Random Pointer\ndef solve_138():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Copy List with Random Pointer",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 139,
    "title": "Word Break",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "String",
      "Dynamic Programming"
    ],
    "acceptance": "47.1%",
    "fullDescription": "Check if string can be segmented using dictionary words via dynamic programming.",
    "testCases": [
      {
        "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
        "output": "true",
        "explanation": "String can be segmented."
      }
    ],
    "pseudocode": "DP array for segmentation\nCheck all possible splits",
    "pythonCode": "DP approach",
    "timeComplexity": "O(n\u00b3)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "DP array",
      "Check splits",
      "Word matching"
    ]
  },
  {
    "id": 140,
    "title": "Word Break II",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "String",
      "Dynamic Programming",
      "Backtracking"
    ],
    "acceptance": "42.1%",
    "fullDescription": "Return all possible word break combinations using dynamic programming.",
    "testCases": [
      {
        "input": "s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]",
        "output": "[\"cats and dog\",\"cat sand dog\"]",
        "explanation": "All possible combinations."
      }
    ],
    "pseudocode": "DP with backtracking\nStore all valid combinations",
    "pythonCode": "DP with backtracking",
    "timeComplexity": "O(n\u00b3)",
    "spaceComplexity": "O(n\u00b3)",
    "keyInsights": [
      "DP approach",
      "Backtracking",
      "Store combinations"
    ]
  },
  {
    "id": 141,
    "title": "Linked List Cycle",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "61%",
    "fullDescription": "Problem 141: Linked List Cycle - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Linked List Cycle",
        "output": "Expected output for Linked List Cycle",
        "explanation": "Explanation of how to solve Linked List Cycle"
      }
    ],
    "pseudocode": "Algorithm for Linked List Cycle:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Linked List Cycle\ndef solve_141():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Linked List Cycle",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 142,
    "title": "Linked List Cycle II",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "62%",
    "fullDescription": "Problem 142: Linked List Cycle II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Linked List Cycle II",
        "output": "Expected output for Linked List Cycle II",
        "explanation": "Explanation of how to solve Linked List Cycle II"
      }
    ],
    "pseudocode": "Algorithm for Linked List Cycle II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Linked List Cycle II\ndef solve_142():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Linked List Cycle II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 143,
    "title": "Reorder List",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "63%",
    "fullDescription": "Problem 143: Reorder List - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Reorder List",
        "output": "Expected output for Reorder List",
        "explanation": "Explanation of how to solve Reorder List"
      }
    ],
    "pseudocode": "Algorithm for Reorder List:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Reorder List\ndef solve_143():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Reorder List",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 144,
    "title": "Binary Tree Preorder Traversal",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "64%",
    "fullDescription": "Problem 144: Binary Tree Preorder Traversal - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Binary Tree Preorder Traversal",
        "output": "Expected output for Binary Tree Preorder Traversal",
        "explanation": "Explanation of how to solve Binary Tree Preorder Traversal"
      }
    ],
    "pseudocode": "Algorithm for Binary Tree Preorder Traversal:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Binary Tree Preorder Traversal\ndef solve_144():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Binary Tree Preorder Traversal",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 145,
    "title": "Binary Tree Postorder Traversal",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "65%",
    "fullDescription": "Problem 145: Binary Tree Postorder Traversal - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Binary Tree Postorder Traversal",
        "output": "Expected output for Binary Tree Postorder Traversal",
        "explanation": "Explanation of how to solve Binary Tree Postorder Traversal"
      }
    ],
    "pseudocode": "Algorithm for Binary Tree Postorder Traversal:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Binary Tree Postorder Traversal\ndef solve_145():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Binary Tree Postorder Traversal",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 146,
    "title": "LRU Cache",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "66%",
    "fullDescription": "Problem 146: LRU Cache - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for LRU Cache",
        "output": "Expected output for LRU Cache",
        "explanation": "Explanation of how to solve LRU Cache"
      }
    ],
    "pseudocode": "Algorithm for LRU Cache:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for LRU Cache\ndef solve_146():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for LRU Cache",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 147,
    "title": "Insertion Sort List",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "67%",
    "fullDescription": "Problem 147: Insertion Sort List - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Insertion Sort List",
        "output": "Expected output for Insertion Sort List",
        "explanation": "Explanation of how to solve Insertion Sort List"
      }
    ],
    "pseudocode": "Algorithm for Insertion Sort List:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Insertion Sort List\ndef solve_147():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Insertion Sort List",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 148,
    "title": "Sort List",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "68%",
    "fullDescription": "Problem 148: Sort List - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Sort List",
        "output": "Expected output for Sort List",
        "explanation": "Explanation of how to solve Sort List"
      }
    ],
    "pseudocode": "Algorithm for Sort List:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Sort List\ndef solve_148():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Sort List",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 149,
    "title": "Max Points on a Line",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "69%",
    "fullDescription": "Problem 149: Max Points on a Line - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Max Points on a Line",
        "output": "Expected output for Max Points on a Line",
        "explanation": "Explanation of how to solve Max Points on a Line"
      }
    ],
    "pseudocode": "Algorithm for Max Points on a Line:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Max Points on a Line\ndef solve_149():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Max Points on a Line",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 150,
    "title": "Evaluate Reverse Polish Notation",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "40%",
    "fullDescription": "Problem 150: Evaluate Reverse Polish Notation - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Evaluate Reverse Polish Notation",
        "output": "Expected output for Evaluate Reverse Polish Notation",
        "explanation": "Explanation of how to solve Evaluate Reverse Polish Notation"
      }
    ],
    "pseudocode": "Algorithm for Evaluate Reverse Polish Notation:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Evaluate Reverse Polish Notation\ndef solve_150():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Evaluate Reverse Polish Notation",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 151,
    "title": "Reverse Words in a String",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "41%",
    "fullDescription": "Problem 151: Reverse Words in a String - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Reverse Words in a String",
        "output": "Expected output for Reverse Words in a String",
        "explanation": "Explanation of how to solve Reverse Words in a String"
      }
    ],
    "pseudocode": "Algorithm for Reverse Words in a String:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Reverse Words in a String\ndef solve_151():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Reverse Words in a String",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 152,
    "title": "Maximum Product Subarray",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "Dynamic Programming"
    ],
    "acceptance": "37.1%",
    "fullDescription": "Find maximum product subarray using dynamic programming.",
    "testCases": [
      {
        "input": "nums = [2,3,-2,4]",
        "output": "6",
        "explanation": "Subarray [2,3] has maximum product 6."
      }
    ],
    "pseudocode": "Track min and max products\nHandle negative numbers",
    "pythonCode": "DP with min/max tracking",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Track min/max",
      "Handle negatives",
      "DP approach"
    ]
  },
  {
    "id": 153,
    "title": "Find Minimum in Rotated Sorted Array",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "43%",
    "fullDescription": "Problem 153: Find Minimum in Rotated Sorted Array - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Find Minimum in Rotated Sorted Array",
        "output": "Expected output for Find Minimum in Rotated Sorted Array",
        "explanation": "Explanation of how to solve Find Minimum in Rotated Sorted Array"
      }
    ],
    "pseudocode": "Algorithm for Find Minimum in Rotated Sorted Array:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Find Minimum in Rotated Sorted Array\ndef solve_153():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Find Minimum in Rotated Sorted Array",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 154,
    "title": "Find Minimum in Rotated Sorted Array II",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "44%",
    "fullDescription": "Problem 154: Find Minimum in Rotated Sorted Array II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Find Minimum in Rotated Sorted Array II",
        "output": "Expected output for Find Minimum in Rotated Sorted Array II",
        "explanation": "Explanation of how to solve Find Minimum in Rotated Sorted Array II"
      }
    ],
    "pseudocode": "Algorithm for Find Minimum in Rotated Sorted Array II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Find Minimum in Rotated Sorted Array II\ndef solve_154():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Find Minimum in Rotated Sorted Array II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 155,
    "title": "Min Stack",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "45%",
    "fullDescription": "Problem 155: Min Stack - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Min Stack",
        "output": "Expected output for Min Stack",
        "explanation": "Explanation of how to solve Min Stack"
      }
    ],
    "pseudocode": "Algorithm for Min Stack:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Min Stack\ndef solve_155():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Min Stack",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 156,
    "title": "Binary Tree Upside Down",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "46%",
    "fullDescription": "Problem 156: Binary Tree Upside Down - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Binary Tree Upside Down",
        "output": "Expected output for Binary Tree Upside Down",
        "explanation": "Explanation of how to solve Binary Tree Upside Down"
      }
    ],
    "pseudocode": "Algorithm for Binary Tree Upside Down:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Binary Tree Upside Down\ndef solve_156():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Binary Tree Upside Down",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 157,
    "title": "Read N Characters Given Read4",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "47%",
    "fullDescription": "Problem 157: Read N Characters Given Read4 - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Read N Characters Given Read4",
        "output": "Expected output for Read N Characters Given Read4",
        "explanation": "Explanation of how to solve Read N Characters Given Read4"
      }
    ],
    "pseudocode": "Algorithm for Read N Characters Given Read4:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Read N Characters Given Read4\ndef solve_157():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Read N Characters Given Read4",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 158,
    "title": "Read N Characters Given Read4 II - Call multiple times",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "48%",
    "fullDescription": "Problem 158: Read N Characters Given Read4 II - Call multiple times - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Read N Characters Given Read4 II - Call multiple times",
        "output": "Expected output for Read N Characters Given Read4 II - Call multiple times",
        "explanation": "Explanation of how to solve Read N Characters Given Read4 II - Call multiple times"
      }
    ],
    "pseudocode": "Algorithm for Read N Characters Given Read4 II - Call multiple times:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Read N Characters Given Read4 II - Call multiple times\ndef solve_158():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Read N Characters Given Read4 II - Call multiple times",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 159,
    "title": "Longest Substring with At Most Two Distinct Characters",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "49%",
    "fullDescription": "Problem 159: Longest Substring with At Most Two Distinct Characters - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Longest Substring with At Most Two Distinct Characters",
        "output": "Expected output for Longest Substring with At Most Two Distinct Characters",
        "explanation": "Explanation of how to solve Longest Substring with At Most Two Distinct Characters"
      }
    ],
    "pseudocode": "Algorithm for Longest Substring with At Most Two Distinct Characters:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Longest Substring with At Most Two Distinct Characters\ndef solve_159():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Longest Substring with At Most Two Distinct Characters",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 160,
    "title": "Intersection of Two Linked Lists",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "50%",
    "fullDescription": "Problem 160: Intersection of Two Linked Lists - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Intersection of Two Linked Lists",
        "output": "Expected output for Intersection of Two Linked Lists",
        "explanation": "Explanation of how to solve Intersection of Two Linked Lists"
      }
    ],
    "pseudocode": "Algorithm for Intersection of Two Linked Lists:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Intersection of Two Linked Lists\ndef solve_160():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Intersection of Two Linked Lists",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 161,
    "title": "One Edit Distance",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "51%",
    "fullDescription": "Problem 161: One Edit Distance - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for One Edit Distance",
        "output": "Expected output for One Edit Distance",
        "explanation": "Explanation of how to solve One Edit Distance"
      }
    ],
    "pseudocode": "Algorithm for One Edit Distance:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for One Edit Distance\ndef solve_161():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for One Edit Distance",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 162,
    "title": "Find Peak Element",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "52%",
    "fullDescription": "Problem 162: Find Peak Element - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Find Peak Element",
        "output": "Expected output for Find Peak Element",
        "explanation": "Explanation of how to solve Find Peak Element"
      }
    ],
    "pseudocode": "Algorithm for Find Peak Element:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Find Peak Element\ndef solve_162():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Find Peak Element",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 163,
    "title": "Missing Ranges",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "53%",
    "fullDescription": "Problem 163: Missing Ranges - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Missing Ranges",
        "output": "Expected output for Missing Ranges",
        "explanation": "Explanation of how to solve Missing Ranges"
      }
    ],
    "pseudocode": "Algorithm for Missing Ranges:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Missing Ranges\ndef solve_163():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Missing Ranges",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 164,
    "title": "Maximum Gap",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "54%",
    "fullDescription": "Problem 164: Maximum Gap - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Maximum Gap",
        "output": "Expected output for Maximum Gap",
        "explanation": "Explanation of how to solve Maximum Gap"
      }
    ],
    "pseudocode": "Algorithm for Maximum Gap:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Maximum Gap\ndef solve_164():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Maximum Gap",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 165,
    "title": "Compare Version Numbers",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "55%",
    "fullDescription": "Problem 165: Compare Version Numbers - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Compare Version Numbers",
        "output": "Expected output for Compare Version Numbers",
        "explanation": "Explanation of how to solve Compare Version Numbers"
      }
    ],
    "pseudocode": "Algorithm for Compare Version Numbers:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Compare Version Numbers\ndef solve_165():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Compare Version Numbers",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 166,
    "title": "Fraction to Recurring Decimal",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "56%",
    "fullDescription": "Problem 166: Fraction to Recurring Decimal - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Fraction to Recurring Decimal",
        "output": "Expected output for Fraction to Recurring Decimal",
        "explanation": "Explanation of how to solve Fraction to Recurring Decimal"
      }
    ],
    "pseudocode": "Algorithm for Fraction to Recurring Decimal:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Fraction to Recurring Decimal\ndef solve_166():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Fraction to Recurring Decimal",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 167,
    "title": "Two Sum II - Input Array Is Sorted",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "57%",
    "fullDescription": "Problem 167: Two Sum II - Input Array Is Sorted - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Two Sum II - Input Array Is Sorted",
        "output": "Expected output for Two Sum II - Input Array Is Sorted",
        "explanation": "Explanation of how to solve Two Sum II - Input Array Is Sorted"
      }
    ],
    "pseudocode": "Algorithm for Two Sum II - Input Array Is Sorted:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Two Sum II - Input Array Is Sorted\ndef solve_167():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Two Sum II - Input Array Is Sorted",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 168,
    "title": "Excel Sheet Column Title",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "58%",
    "fullDescription": "Problem 168: Excel Sheet Column Title - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Excel Sheet Column Title",
        "output": "Expected output for Excel Sheet Column Title",
        "explanation": "Explanation of how to solve Excel Sheet Column Title"
      }
    ],
    "pseudocode": "Algorithm for Excel Sheet Column Title:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Excel Sheet Column Title\ndef solve_168():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Excel Sheet Column Title",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 169,
    "title": "Majority Element",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "59%",
    "fullDescription": "Problem 169: Majority Element - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Majority Element",
        "output": "Expected output for Majority Element",
        "explanation": "Explanation of how to solve Majority Element"
      }
    ],
    "pseudocode": "Algorithm for Majority Element:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Majority Element\ndef solve_169():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Majority Element",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 170,
    "title": "Two Sum III - Data structure design",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "60%",
    "fullDescription": "Problem 170: Two Sum III - Data structure design - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Two Sum III - Data structure design",
        "output": "Expected output for Two Sum III - Data structure design",
        "explanation": "Explanation of how to solve Two Sum III - Data structure design"
      }
    ],
    "pseudocode": "Algorithm for Two Sum III - Data structure design:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Two Sum III - Data structure design\ndef solve_170():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Two Sum III - Data structure design",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 171,
    "title": "Excel Sheet Column Number",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "61%",
    "fullDescription": "Problem 171: Excel Sheet Column Number - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Excel Sheet Column Number",
        "output": "Expected output for Excel Sheet Column Number",
        "explanation": "Explanation of how to solve Excel Sheet Column Number"
      }
    ],
    "pseudocode": "Algorithm for Excel Sheet Column Number:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Excel Sheet Column Number\ndef solve_171():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Excel Sheet Column Number",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 172,
    "title": "Factorial Trailing Zeroes",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "62%",
    "fullDescription": "Problem 172: Factorial Trailing Zeroes - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Factorial Trailing Zeroes",
        "output": "Expected output for Factorial Trailing Zeroes",
        "explanation": "Explanation of how to solve Factorial Trailing Zeroes"
      }
    ],
    "pseudocode": "Algorithm for Factorial Trailing Zeroes:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Factorial Trailing Zeroes\ndef solve_172():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Factorial Trailing Zeroes",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 173,
    "title": "Binary Search Tree Iterator",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "63%",
    "fullDescription": "Problem 173: Binary Search Tree Iterator - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Binary Search Tree Iterator",
        "output": "Expected output for Binary Search Tree Iterator",
        "explanation": "Explanation of how to solve Binary Search Tree Iterator"
      }
    ],
    "pseudocode": "Algorithm for Binary Search Tree Iterator:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Binary Search Tree Iterator\ndef solve_173():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Binary Search Tree Iterator",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 174,
    "title": "Dungeon Game",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "acceptance": "37.1%",
    "fullDescription": "Find minimum initial health for dungeon game using dynamic programming.",
    "testCases": [
      {
        "input": "dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]",
        "output": "7",
        "explanation": "Minimum initial health is 7."
      }
    ],
    "pseudocode": "Bottom-up DP from end\nCalculate minimum health needed",
    "pythonCode": "Bottom-up DP approach",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)",
    "keyInsights": [
      "Bottom-up DP",
      "Minimum health",
      "End to start"
    ]
  },
  {
    "id": 175,
    "title": "Combine Two Tables",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "65%",
    "fullDescription": "Problem 175: Combine Two Tables - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Combine Two Tables",
        "output": "Expected output for Combine Two Tables",
        "explanation": "Explanation of how to solve Combine Two Tables"
      }
    ],
    "pseudocode": "Algorithm for Combine Two Tables:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Combine Two Tables\ndef solve_175():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Combine Two Tables",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 176,
    "title": "Second Highest Salary",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "66%",
    "fullDescription": "Problem 176: Second Highest Salary - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Second Highest Salary",
        "output": "Expected output for Second Highest Salary",
        "explanation": "Explanation of how to solve Second Highest Salary"
      }
    ],
    "pseudocode": "Algorithm for Second Highest Salary:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Second Highest Salary\ndef solve_176():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Second Highest Salary",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 177,
    "title": "Nth Highest Salary",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "67%",
    "fullDescription": "Problem 177: Nth Highest Salary - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Nth Highest Salary",
        "output": "Expected output for Nth Highest Salary",
        "explanation": "Explanation of how to solve Nth Highest Salary"
      }
    ],
    "pseudocode": "Algorithm for Nth Highest Salary:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Nth Highest Salary\ndef solve_177():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Nth Highest Salary",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 178,
    "title": "Rank Scores",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "68%",
    "fullDescription": "Problem 178: Rank Scores - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Rank Scores",
        "output": "Expected output for Rank Scores",
        "explanation": "Explanation of how to solve Rank Scores"
      }
    ],
    "pseudocode": "Algorithm for Rank Scores:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Rank Scores\ndef solve_178():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Rank Scores",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 179,
    "title": "Largest Number",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "69%",
    "fullDescription": "Problem 179: Largest Number - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Largest Number",
        "output": "Expected output for Largest Number",
        "explanation": "Explanation of how to solve Largest Number"
      }
    ],
    "pseudocode": "Algorithm for Largest Number:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Largest Number\ndef solve_179():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Largest Number",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 180,
    "title": "Consecutive Numbers",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "40%",
    "fullDescription": "Problem 180: Consecutive Numbers - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Consecutive Numbers",
        "output": "Expected output for Consecutive Numbers",
        "explanation": "Explanation of how to solve Consecutive Numbers"
      }
    ],
    "pseudocode": "Algorithm for Consecutive Numbers:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Consecutive Numbers\ndef solve_180():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Consecutive Numbers",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 181,
    "title": "Employees Earning More Than Their Managers",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "41%",
    "fullDescription": "Problem 181: Employees Earning More Than Their Managers - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Employees Earning More Than Their Managers",
        "output": "Expected output for Employees Earning More Than Their Managers",
        "explanation": "Explanation of how to solve Employees Earning More Than Their Managers"
      }
    ],
    "pseudocode": "Algorithm for Employees Earning More Than Their Managers:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Employees Earning More Than Their Managers\ndef solve_181():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Employees Earning More Than Their Managers",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 182,
    "title": "Duplicate Emails",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "42%",
    "fullDescription": "Problem 182: Duplicate Emails - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Duplicate Emails",
        "output": "Expected output for Duplicate Emails",
        "explanation": "Explanation of how to solve Duplicate Emails"
      }
    ],
    "pseudocode": "Algorithm for Duplicate Emails:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Duplicate Emails\ndef solve_182():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Duplicate Emails",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 183,
    "title": "Customers Who Never Order",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "43%",
    "fullDescription": "Problem 183: Customers Who Never Order - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Customers Who Never Order",
        "output": "Expected output for Customers Who Never Order",
        "explanation": "Explanation of how to solve Customers Who Never Order"
      }
    ],
    "pseudocode": "Algorithm for Customers Who Never Order:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Customers Who Never Order\ndef solve_183():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Customers Who Never Order",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 184,
    "title": "Department Highest Salary",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "44%",
    "fullDescription": "Problem 184: Department Highest Salary - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Department Highest Salary",
        "output": "Expected output for Department Highest Salary",
        "explanation": "Explanation of how to solve Department Highest Salary"
      }
    ],
    "pseudocode": "Algorithm for Department Highest Salary:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Department Highest Salary\ndef solve_184():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Department Highest Salary",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 185,
    "title": "Department Top Three Salaries",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "45%",
    "fullDescription": "Problem 185: Department Top Three Salaries - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Department Top Three Salaries",
        "output": "Expected output for Department Top Three Salaries",
        "explanation": "Explanation of how to solve Department Top Three Salaries"
      }
    ],
    "pseudocode": "Algorithm for Department Top Three Salaries:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Department Top Three Salaries\ndef solve_185():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Department Top Three Salaries",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 186,
    "title": "Reverse Words in a String II",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "46%",
    "fullDescription": "Problem 186: Reverse Words in a String II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Reverse Words in a String II",
        "output": "Expected output for Reverse Words in a String II",
        "explanation": "Explanation of how to solve Reverse Words in a String II"
      }
    ],
    "pseudocode": "Algorithm for Reverse Words in a String II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Reverse Words in a String II\ndef solve_186():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Reverse Words in a String II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 187,
    "title": "Repeated DNA Sequences",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "47%",
    "fullDescription": "Problem 187: Repeated DNA Sequences - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Repeated DNA Sequences",
        "output": "Expected output for Repeated DNA Sequences",
        "explanation": "Explanation of how to solve Repeated DNA Sequences"
      }
    ],
    "pseudocode": "Algorithm for Repeated DNA Sequences:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Repeated DNA Sequences\ndef solve_187():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Repeated DNA Sequences",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 188,
    "title": "Best Time to Buy and Sell Stock IV",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "Dynamic Programming"
    ],
    "acceptance": "37.1%",
    "fullDescription": "Find maximum profit from at most k transactions using dynamic programming.",
    "testCases": [
      {
        "input": "k = 2, prices = [2,4,1]",
        "output": "2",
        "explanation": "Buy at 2, sell at 4 for profit 2."
      }
    ],
    "pseudocode": "DP with k transactions\nTrack buy/sell states",
    "pythonCode": "DP with k states",
    "timeComplexity": "O(kn)",
    "spaceComplexity": "O(kn)",
    "keyInsights": [
      "K transactions",
      "State tracking",
      "DP approach"
    ]
  },
  {
    "id": 189,
    "title": "Rotate Array",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "49%",
    "fullDescription": "Problem 189: Rotate Array - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Rotate Array",
        "output": "Expected output for Rotate Array",
        "explanation": "Explanation of how to solve Rotate Array"
      }
    ],
    "pseudocode": "Algorithm for Rotate Array:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Rotate Array\ndef solve_189():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Rotate Array",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 190,
    "title": "Reverse Bits",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "50%",
    "fullDescription": "Problem 190: Reverse Bits - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Reverse Bits",
        "output": "Expected output for Reverse Bits",
        "explanation": "Explanation of how to solve Reverse Bits"
      }
    ],
    "pseudocode": "Algorithm for Reverse Bits:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Reverse Bits\ndef solve_190():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Reverse Bits",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 191,
    "title": "Number of 1 Bits",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "51%",
    "fullDescription": "Problem 191: Number of 1 Bits - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Number of 1 Bits",
        "output": "Expected output for Number of 1 Bits",
        "explanation": "Explanation of how to solve Number of 1 Bits"
      }
    ],
    "pseudocode": "Algorithm for Number of 1 Bits:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Number of 1 Bits\ndef solve_191():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Number of 1 Bits",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 192,
    "title": "Word Frequency",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "52%",
    "fullDescription": "Problem 192: Word Frequency - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Word Frequency",
        "output": "Expected output for Word Frequency",
        "explanation": "Explanation of how to solve Word Frequency"
      }
    ],
    "pseudocode": "Algorithm for Word Frequency:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Word Frequency\ndef solve_192():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Word Frequency",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 193,
    "title": "Valid Phone Numbers",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "53%",
    "fullDescription": "Problem 193: Valid Phone Numbers - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Valid Phone Numbers",
        "output": "Expected output for Valid Phone Numbers",
        "explanation": "Explanation of how to solve Valid Phone Numbers"
      }
    ],
    "pseudocode": "Algorithm for Valid Phone Numbers:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Valid Phone Numbers\ndef solve_193():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Valid Phone Numbers",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 194,
    "title": "Transpose File",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "54%",
    "fullDescription": "Problem 194: Transpose File - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Transpose File",
        "output": "Expected output for Transpose File",
        "explanation": "Explanation of how to solve Transpose File"
      }
    ],
    "pseudocode": "Algorithm for Transpose File:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Transpose File\ndef solve_194():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Transpose File",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 195,
    "title": "Tenth Line",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "55%",
    "fullDescription": "Problem 195: Tenth Line - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Tenth Line",
        "output": "Expected output for Tenth Line",
        "explanation": "Explanation of how to solve Tenth Line"
      }
    ],
    "pseudocode": "Algorithm for Tenth Line:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Tenth Line\ndef solve_195():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Tenth Line",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 196,
    "title": "Delete Duplicate Emails",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "56%",
    "fullDescription": "Problem 196: Delete Duplicate Emails - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Delete Duplicate Emails",
        "output": "Expected output for Delete Duplicate Emails",
        "explanation": "Explanation of how to solve Delete Duplicate Emails"
      }
    ],
    "pseudocode": "Algorithm for Delete Duplicate Emails:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Delete Duplicate Emails\ndef solve_196():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Delete Duplicate Emails",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 197,
    "title": "Rising Temperature",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "57%",
    "fullDescription": "Problem 197: Rising Temperature - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Rising Temperature",
        "output": "Expected output for Rising Temperature",
        "explanation": "Explanation of how to solve Rising Temperature"
      }
    ],
    "pseudocode": "Algorithm for Rising Temperature:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Rising Temperature\ndef solve_197():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Rising Temperature",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 198,
    "title": "House Robber",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "Dynamic Programming"
    ],
    "acceptance": "47.1%",
    "fullDescription": "Find maximum money that can be robbed without alerting police using dynamic programming.",
    "testCases": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "4",
        "explanation": "Rob house 1 and 3 for maximum 4."
      }
    ],
    "pseudocode": "DP with skip/rob decision\nChoose maximum of skip or rob",
    "pythonCode": "DP approach",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Skip/rob decision",
      "Choose maximum",
      "DP optimization"
    ]
  },
  {
    "id": 199,
    "title": "Binary Tree Right Side View",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "59%",
    "fullDescription": "Problem 199: Binary Tree Right Side View - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Binary Tree Right Side View",
        "output": "Expected output for Binary Tree Right Side View",
        "explanation": "Explanation of how to solve Binary Tree Right Side View"
      }
    ],
    "pseudocode": "Algorithm for Binary Tree Right Side View:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Binary Tree Right Side View\ndef solve_199():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Binary Tree Right Side View",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 200,
    "title": "Number of Islands",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "60%",
    "fullDescription": "Problem 200: Number of Islands - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Number of Islands",
        "output": "Expected output for Number of Islands",
        "explanation": "Explanation of how to solve Number of Islands"
      }
    ],
    "pseudocode": "Algorithm for Number of Islands:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Number of Islands\ndef solve_200():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Number of Islands",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 201,
    "title": "Bitwise AND of Numbers Range",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "61%",
    "fullDescription": "Problem 201: Bitwise AND of Numbers Range - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Bitwise AND of Numbers Range",
        "output": "Expected output for Bitwise AND of Numbers Range",
        "explanation": "Explanation of how to solve Bitwise AND of Numbers Range"
      }
    ],
    "pseudocode": "Algorithm for Bitwise AND of Numbers Range:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Bitwise AND of Numbers Range\ndef solve_201():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Bitwise AND of Numbers Range",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 202,
    "title": "Happy Number",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "62%",
    "fullDescription": "Problem 202: Happy Number - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Happy Number",
        "output": "Expected output for Happy Number",
        "explanation": "Explanation of how to solve Happy Number"
      }
    ],
    "pseudocode": "Algorithm for Happy Number:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Happy Number\ndef solve_202():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Happy Number",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 203,
    "title": "Remove Linked List Elements",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "63%",
    "fullDescription": "Problem 203: Remove Linked List Elements - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Remove Linked List Elements",
        "output": "Expected output for Remove Linked List Elements",
        "explanation": "Explanation of how to solve Remove Linked List Elements"
      }
    ],
    "pseudocode": "Algorithm for Remove Linked List Elements:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Remove Linked List Elements\ndef solve_203():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Remove Linked List Elements",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 204,
    "title": "Count Primes",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "64%",
    "fullDescription": "Problem 204: Count Primes - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Count Primes",
        "output": "Expected output for Count Primes",
        "explanation": "Explanation of how to solve Count Primes"
      }
    ],
    "pseudocode": "Algorithm for Count Primes:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Count Primes\ndef solve_204():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Count Primes",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 205,
    "title": "Isomorphic Strings",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "65%",
    "fullDescription": "Problem 205: Isomorphic Strings - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Isomorphic Strings",
        "output": "Expected output for Isomorphic Strings",
        "explanation": "Explanation of how to solve Isomorphic Strings"
      }
    ],
    "pseudocode": "Algorithm for Isomorphic Strings:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Isomorphic Strings\ndef solve_205():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Isomorphic Strings",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 206,
    "title": "Reverse Linked List",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "66%",
    "fullDescription": "Problem 206: Reverse Linked List - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Reverse Linked List",
        "output": "Expected output for Reverse Linked List",
        "explanation": "Explanation of how to solve Reverse Linked List"
      }
    ],
    "pseudocode": "Algorithm for Reverse Linked List:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Reverse Linked List\ndef solve_206():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Reverse Linked List",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 207,
    "title": "Course Schedule",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "67%",
    "fullDescription": "Problem 207: Course Schedule - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Course Schedule",
        "output": "Expected output for Course Schedule",
        "explanation": "Explanation of how to solve Course Schedule"
      }
    ],
    "pseudocode": "Algorithm for Course Schedule:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Course Schedule\ndef solve_207():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Course Schedule",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 208,
    "title": "Implement Trie (Prefix Tree)",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "68%",
    "fullDescription": "Problem 208: Implement Trie (Prefix Tree) - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Implement Trie (Prefix Tree)",
        "output": "Expected output for Implement Trie (Prefix Tree)",
        "explanation": "Explanation of how to solve Implement Trie (Prefix Tree)"
      }
    ],
    "pseudocode": "Algorithm for Implement Trie (Prefix Tree):\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Implement Trie (Prefix Tree)\ndef solve_208():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Implement Trie (Prefix Tree)",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 209,
    "title": "Minimum Size Subarray Sum",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "69%",
    "fullDescription": "Problem 209: Minimum Size Subarray Sum - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Minimum Size Subarray Sum",
        "output": "Expected output for Minimum Size Subarray Sum",
        "explanation": "Explanation of how to solve Minimum Size Subarray Sum"
      }
    ],
    "pseudocode": "Algorithm for Minimum Size Subarray Sum:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Minimum Size Subarray Sum\ndef solve_209():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Minimum Size Subarray Sum",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 210,
    "title": "Course Schedule II",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "40%",
    "fullDescription": "Problem 210: Course Schedule II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Course Schedule II",
        "output": "Expected output for Course Schedule II",
        "explanation": "Explanation of how to solve Course Schedule II"
      }
    ],
    "pseudocode": "Algorithm for Course Schedule II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Course Schedule II\ndef solve_210():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Course Schedule II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 211,
    "title": "Design Add and Search Words Data Structure",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "41%",
    "fullDescription": "Problem 211: Design Add and Search Words Data Structure - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Design Add and Search Words Data Structure",
        "output": "Expected output for Design Add and Search Words Data Structure",
        "explanation": "Explanation of how to solve Design Add and Search Words Data Structure"
      }
    ],
    "pseudocode": "Algorithm for Design Add and Search Words Data Structure:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Design Add and Search Words Data Structure\ndef solve_211():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Design Add and Search Words Data Structure",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 212,
    "title": "Word Search II",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "42%",
    "fullDescription": "Problem 212: Word Search II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Word Search II",
        "output": "Expected output for Word Search II",
        "explanation": "Explanation of how to solve Word Search II"
      }
    ],
    "pseudocode": "Algorithm for Word Search II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Word Search II\ndef solve_212():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Word Search II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 213,
    "title": "House Robber II",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "Dynamic Programming"
    ],
    "acceptance": "42.1%",
    "fullDescription": "House robber problem with circular arrangement using dynamic programming.",
    "testCases": [
      {
        "input": "nums = [2,3,2]",
        "output": "3",
        "explanation": "Rob house 2 for maximum 3."
      }
    ],
    "pseudocode": "Two DP runs\nExclude first or last house",
    "pythonCode": "Two DP approaches",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Two DP runs",
      "Exclude first/last",
      "Circular constraint"
    ]
  },
  {
    "id": 214,
    "title": "Shortest Palindrome",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "44%",
    "fullDescription": "Problem 214: Shortest Palindrome - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Shortest Palindrome",
        "output": "Expected output for Shortest Palindrome",
        "explanation": "Explanation of how to solve Shortest Palindrome"
      }
    ],
    "pseudocode": "Algorithm for Shortest Palindrome:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Shortest Palindrome\ndef solve_214():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Shortest Palindrome",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 215,
    "title": "Kth Largest Element in an Array",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "45%",
    "fullDescription": "Problem 215: Kth Largest Element in an Array - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Kth Largest Element in an Array",
        "output": "Expected output for Kth Largest Element in an Array",
        "explanation": "Explanation of how to solve Kth Largest Element in an Array"
      }
    ],
    "pseudocode": "Algorithm for Kth Largest Element in an Array:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Kth Largest Element in an Array\ndef solve_215():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Kth Largest Element in an Array",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 216,
    "title": "Combination Sum III",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "46%",
    "fullDescription": "Problem 216: Combination Sum III - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Combination Sum III",
        "output": "Expected output for Combination Sum III",
        "explanation": "Explanation of how to solve Combination Sum III"
      }
    ],
    "pseudocode": "Algorithm for Combination Sum III:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Combination Sum III\ndef solve_216():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Combination Sum III",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 217,
    "title": "Contains Duplicate",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "47%",
    "fullDescription": "Problem 217: Contains Duplicate - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Contains Duplicate",
        "output": "Expected output for Contains Duplicate",
        "explanation": "Explanation of how to solve Contains Duplicate"
      }
    ],
    "pseudocode": "Algorithm for Contains Duplicate:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Contains Duplicate\ndef solve_217():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Contains Duplicate",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 218,
    "title": "The Skyline Problem",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "48%",
    "fullDescription": "Problem 218: The Skyline Problem - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for The Skyline Problem",
        "output": "Expected output for The Skyline Problem",
        "explanation": "Explanation of how to solve The Skyline Problem"
      }
    ],
    "pseudocode": "Algorithm for The Skyline Problem:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for The Skyline Problem\ndef solve_218():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for The Skyline Problem",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 219,
    "title": "Contains Duplicate II",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "49%",
    "fullDescription": "Problem 219: Contains Duplicate II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Contains Duplicate II",
        "output": "Expected output for Contains Duplicate II",
        "explanation": "Explanation of how to solve Contains Duplicate II"
      }
    ],
    "pseudocode": "Algorithm for Contains Duplicate II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Contains Duplicate II\ndef solve_219():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Contains Duplicate II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 220,
    "title": "Contains Duplicate III",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "50%",
    "fullDescription": "Problem 220: Contains Duplicate III - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Contains Duplicate III",
        "output": "Expected output for Contains Duplicate III",
        "explanation": "Explanation of how to solve Contains Duplicate III"
      }
    ],
    "pseudocode": "Algorithm for Contains Duplicate III:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Contains Duplicate III\ndef solve_220():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Contains Duplicate III",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 221,
    "title": "Maximal Square",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "acceptance": "47.1%",
    "fullDescription": "Find largest square containing only 1's using dynamic programming.",
    "testCases": [
      {
        "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
        "output": "4",
        "explanation": "Largest square has area 4."
      }
    ],
    "pseudocode": "DP matrix for square size\nUpdate based on neighbors",
    "pythonCode": "DP matrix approach",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)",
    "keyInsights": [
      "DP matrix",
      "Square size",
      "Neighbor update"
    ]
  },
  {
    "id": 222,
    "title": "Count Complete Tree Nodes",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "52%",
    "fullDescription": "Problem 222: Count Complete Tree Nodes - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Count Complete Tree Nodes",
        "output": "Expected output for Count Complete Tree Nodes",
        "explanation": "Explanation of how to solve Count Complete Tree Nodes"
      }
    ],
    "pseudocode": "Algorithm for Count Complete Tree Nodes:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Count Complete Tree Nodes\ndef solve_222():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Count Complete Tree Nodes",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 223,
    "title": "Rectangle Area",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "53%",
    "fullDescription": "Problem 223: Rectangle Area - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Rectangle Area",
        "output": "Expected output for Rectangle Area",
        "explanation": "Explanation of how to solve Rectangle Area"
      }
    ],
    "pseudocode": "Algorithm for Rectangle Area:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Rectangle Area\ndef solve_223():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Rectangle Area",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 224,
    "title": "Basic Calculator",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "54%",
    "fullDescription": "Problem 224: Basic Calculator - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Basic Calculator",
        "output": "Expected output for Basic Calculator",
        "explanation": "Explanation of how to solve Basic Calculator"
      }
    ],
    "pseudocode": "Algorithm for Basic Calculator:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Basic Calculator\ndef solve_224():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Basic Calculator",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 225,
    "title": "Implement Stack using Queues",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "55%",
    "fullDescription": "Problem 225: Implement Stack using Queues - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Implement Stack using Queues",
        "output": "Expected output for Implement Stack using Queues",
        "explanation": "Explanation of how to solve Implement Stack using Queues"
      }
    ],
    "pseudocode": "Algorithm for Implement Stack using Queues:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Implement Stack using Queues\ndef solve_225():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Implement Stack using Queues",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 226,
    "title": "Invert Binary Tree",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "56%",
    "fullDescription": "Problem 226: Invert Binary Tree - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Invert Binary Tree",
        "output": "Expected output for Invert Binary Tree",
        "explanation": "Explanation of how to solve Invert Binary Tree"
      }
    ],
    "pseudocode": "Algorithm for Invert Binary Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Invert Binary Tree\ndef solve_226():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Invert Binary Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 227,
    "title": "Basic Calculator II",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "57%",
    "fullDescription": "Problem 227: Basic Calculator II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Basic Calculator II",
        "output": "Expected output for Basic Calculator II",
        "explanation": "Explanation of how to solve Basic Calculator II"
      }
    ],
    "pseudocode": "Algorithm for Basic Calculator II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Basic Calculator II\ndef solve_227():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Basic Calculator II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 228,
    "title": "Summary Ranges",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "58%",
    "fullDescription": "Problem 228: Summary Ranges - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Summary Ranges",
        "output": "Expected output for Summary Ranges",
        "explanation": "Explanation of how to solve Summary Ranges"
      }
    ],
    "pseudocode": "Algorithm for Summary Ranges:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Summary Ranges\ndef solve_228():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Summary Ranges",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 229,
    "title": "Majority Element II",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "59%",
    "fullDescription": "Problem 229: Majority Element II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Majority Element II",
        "output": "Expected output for Majority Element II",
        "explanation": "Explanation of how to solve Majority Element II"
      }
    ],
    "pseudocode": "Algorithm for Majority Element II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Majority Element II\ndef solve_229():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Majority Element II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 230,
    "title": "Kth Smallest Element in a BST",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "60%",
    "fullDescription": "Problem 230: Kth Smallest Element in a BST - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Kth Smallest Element in a BST",
        "output": "Expected output for Kth Smallest Element in a BST",
        "explanation": "Explanation of how to solve Kth Smallest Element in a BST"
      }
    ],
    "pseudocode": "Algorithm for Kth Smallest Element in a BST:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Kth Smallest Element in a BST\ndef solve_230():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Kth Smallest Element in a BST",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 231,
    "title": "Power of Two",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "61%",
    "fullDescription": "Problem 231: Power of Two - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Power of Two",
        "output": "Expected output for Power of Two",
        "explanation": "Explanation of how to solve Power of Two"
      }
    ],
    "pseudocode": "Algorithm for Power of Two:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Power of Two\ndef solve_231():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Power of Two",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 232,
    "title": "Implement Queue using Stacks",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "62%",
    "fullDescription": "Problem 232: Implement Queue using Stacks - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Implement Queue using Stacks",
        "output": "Expected output for Implement Queue using Stacks",
        "explanation": "Explanation of how to solve Implement Queue using Stacks"
      }
    ],
    "pseudocode": "Algorithm for Implement Queue using Stacks:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Implement Queue using Stacks\ndef solve_232():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Implement Queue using Stacks",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 233,
    "title": "Number of Digit One",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "63%",
    "fullDescription": "Problem 233: Number of Digit One - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Number of Digit One",
        "output": "Expected output for Number of Digit One",
        "explanation": "Explanation of how to solve Number of Digit One"
      }
    ],
    "pseudocode": "Algorithm for Number of Digit One:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Number of Digit One\ndef solve_233():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Number of Digit One",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 234,
    "title": "Palindrome Linked List",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "64%",
    "fullDescription": "Problem 234: Palindrome Linked List - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Palindrome Linked List",
        "output": "Expected output for Palindrome Linked List",
        "explanation": "Explanation of how to solve Palindrome Linked List"
      }
    ],
    "pseudocode": "Algorithm for Palindrome Linked List:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Palindrome Linked List\ndef solve_234():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Palindrome Linked List",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 235,
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "65%",
    "fullDescription": "Problem 235: Lowest Common Ancestor of a Binary Search Tree - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Lowest Common Ancestor of a Binary Search Tree",
        "output": "Expected output for Lowest Common Ancestor of a Binary Search Tree",
        "explanation": "Explanation of how to solve Lowest Common Ancestor of a Binary Search Tree"
      }
    ],
    "pseudocode": "Algorithm for Lowest Common Ancestor of a Binary Search Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Lowest Common Ancestor of a Binary Search Tree\ndef solve_235():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Lowest Common Ancestor of a Binary Search Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 236,
    "title": "Lowest Common Ancestor of a Binary Tree",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "66%",
    "fullDescription": "Problem 236: Lowest Common Ancestor of a Binary Tree - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Lowest Common Ancestor of a Binary Tree",
        "output": "Expected output for Lowest Common Ancestor of a Binary Tree",
        "explanation": "Explanation of how to solve Lowest Common Ancestor of a Binary Tree"
      }
    ],
    "pseudocode": "Algorithm for Lowest Common Ancestor of a Binary Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Lowest Common Ancestor of a Binary Tree\ndef solve_236():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Lowest Common Ancestor of a Binary Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 237,
    "title": "Delete Node in a Linked List",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "67%",
    "fullDescription": "Problem 237: Delete Node in a Linked List - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Delete Node in a Linked List",
        "output": "Expected output for Delete Node in a Linked List",
        "explanation": "Explanation of how to solve Delete Node in a Linked List"
      }
    ],
    "pseudocode": "Algorithm for Delete Node in a Linked List:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Delete Node in a Linked List\ndef solve_237():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Delete Node in a Linked List",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 238,
    "title": "Product of Array Except Self",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "68%",
    "fullDescription": "Problem 238: Product of Array Except Self - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Product of Array Except Self",
        "output": "Expected output for Product of Array Except Self",
        "explanation": "Explanation of how to solve Product of Array Except Self"
      }
    ],
    "pseudocode": "Algorithm for Product of Array Except Self:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Product of Array Except Self\ndef solve_238():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Product of Array Except Self",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 239,
    "title": "Sliding Window Maximum",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "69%",
    "fullDescription": "Problem 239: Sliding Window Maximum - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Sliding Window Maximum",
        "output": "Expected output for Sliding Window Maximum",
        "explanation": "Explanation of how to solve Sliding Window Maximum"
      }
    ],
    "pseudocode": "Algorithm for Sliding Window Maximum:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Sliding Window Maximum\ndef solve_239():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Sliding Window Maximum",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 240,
    "title": "Search a 2D Matrix II",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "40%",
    "fullDescription": "Problem 240: Search a 2D Matrix II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Search a 2D Matrix II",
        "output": "Expected output for Search a 2D Matrix II",
        "explanation": "Explanation of how to solve Search a 2D Matrix II"
      }
    ],
    "pseudocode": "Algorithm for Search a 2D Matrix II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Search a 2D Matrix II\ndef solve_240():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Search a 2D Matrix II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 241,
    "title": "Different Ways to Add Parentheses",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "41%",
    "fullDescription": "Problem 241: Different Ways to Add Parentheses - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Different Ways to Add Parentheses",
        "output": "Expected output for Different Ways to Add Parentheses",
        "explanation": "Explanation of how to solve Different Ways to Add Parentheses"
      }
    ],
    "pseudocode": "Algorithm for Different Ways to Add Parentheses:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Different Ways to Add Parentheses\ndef solve_241():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Different Ways to Add Parentheses",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 242,
    "title": "Valid Anagram",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "42%",
    "fullDescription": "Problem 242: Valid Anagram - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Valid Anagram",
        "output": "Expected output for Valid Anagram",
        "explanation": "Explanation of how to solve Valid Anagram"
      }
    ],
    "pseudocode": "Algorithm for Valid Anagram:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Valid Anagram\ndef solve_242():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Valid Anagram",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 243,
    "title": "Shortest Word Distance",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "43%",
    "fullDescription": "Problem 243: Shortest Word Distance - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Shortest Word Distance",
        "output": "Expected output for Shortest Word Distance",
        "explanation": "Explanation of how to solve Shortest Word Distance"
      }
    ],
    "pseudocode": "Algorithm for Shortest Word Distance:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Shortest Word Distance\ndef solve_243():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Shortest Word Distance",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 244,
    "title": "Shortest Word Distance II",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "44%",
    "fullDescription": "Problem 244: Shortest Word Distance II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Shortest Word Distance II",
        "output": "Expected output for Shortest Word Distance II",
        "explanation": "Explanation of how to solve Shortest Word Distance II"
      }
    ],
    "pseudocode": "Algorithm for Shortest Word Distance II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Shortest Word Distance II\ndef solve_244():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Shortest Word Distance II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 245,
    "title": "Shortest Word Distance III",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "45%",
    "fullDescription": "Problem 245: Shortest Word Distance III - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Shortest Word Distance III",
        "output": "Expected output for Shortest Word Distance III",
        "explanation": "Explanation of how to solve Shortest Word Distance III"
      }
    ],
    "pseudocode": "Algorithm for Shortest Word Distance III:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Shortest Word Distance III\ndef solve_245():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Shortest Word Distance III",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 246,
    "title": "Strobogrammatic Number",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "46%",
    "fullDescription": "Problem 246: Strobogrammatic Number - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Strobogrammatic Number",
        "output": "Expected output for Strobogrammatic Number",
        "explanation": "Explanation of how to solve Strobogrammatic Number"
      }
    ],
    "pseudocode": "Algorithm for Strobogrammatic Number:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Strobogrammatic Number\ndef solve_246():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Strobogrammatic Number",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 247,
    "title": "Strobogrammatic Number II",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "47%",
    "fullDescription": "Problem 247: Strobogrammatic Number II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Strobogrammatic Number II",
        "output": "Expected output for Strobogrammatic Number II",
        "explanation": "Explanation of how to solve Strobogrammatic Number II"
      }
    ],
    "pseudocode": "Algorithm for Strobogrammatic Number II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Strobogrammatic Number II\ndef solve_247():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Strobogrammatic Number II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 248,
    "title": "Strobogrammatic Number III",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "48%",
    "fullDescription": "Problem 248: Strobogrammatic Number III - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Strobogrammatic Number III",
        "output": "Expected output for Strobogrammatic Number III",
        "explanation": "Explanation of how to solve Strobogrammatic Number III"
      }
    ],
    "pseudocode": "Algorithm for Strobogrammatic Number III:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Strobogrammatic Number III\ndef solve_248():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Strobogrammatic Number III",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 249,
    "title": "Group Shifted Strings",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "49%",
    "fullDescription": "Problem 249: Group Shifted Strings - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Group Shifted Strings",
        "output": "Expected output for Group Shifted Strings",
        "explanation": "Explanation of how to solve Group Shifted Strings"
      }
    ],
    "pseudocode": "Algorithm for Group Shifted Strings:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Group Shifted Strings\ndef solve_249():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Group Shifted Strings",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 250,
    "title": "Count Univalue Subtrees",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "50%",
    "fullDescription": "Problem 250: Count Univalue Subtrees - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Count Univalue Subtrees",
        "output": "Expected output for Count Univalue Subtrees",
        "explanation": "Explanation of how to solve Count Univalue Subtrees"
      }
    ],
    "pseudocode": "Algorithm for Count Univalue Subtrees:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Count Univalue Subtrees\ndef solve_250():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Count Univalue Subtrees",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 251,
    "title": "Flatten 2D Vector",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "51%",
    "fullDescription": "Problem 251: Flatten 2D Vector - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Flatten 2D Vector",
        "output": "Expected output for Flatten 2D Vector",
        "explanation": "Explanation of how to solve Flatten 2D Vector"
      }
    ],
    "pseudocode": "Algorithm for Flatten 2D Vector:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Flatten 2D Vector\ndef solve_251():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Flatten 2D Vector",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 252,
    "title": "Meeting Rooms",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "52%",
    "fullDescription": "Problem 252: Meeting Rooms - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Meeting Rooms",
        "output": "Expected output for Meeting Rooms",
        "explanation": "Explanation of how to solve Meeting Rooms"
      }
    ],
    "pseudocode": "Algorithm for Meeting Rooms:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Meeting Rooms\ndef solve_252():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Meeting Rooms",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 253,
    "title": "Meeting Rooms II",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "53%",
    "fullDescription": "Problem 253: Meeting Rooms II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Meeting Rooms II",
        "output": "Expected output for Meeting Rooms II",
        "explanation": "Explanation of how to solve Meeting Rooms II"
      }
    ],
    "pseudocode": "Algorithm for Meeting Rooms II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Meeting Rooms II\ndef solve_253():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Meeting Rooms II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 254,
    "title": "Factor Combinations",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "54%",
    "fullDescription": "Problem 254: Factor Combinations - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Factor Combinations",
        "output": "Expected output for Factor Combinations",
        "explanation": "Explanation of how to solve Factor Combinations"
      }
    ],
    "pseudocode": "Algorithm for Factor Combinations:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Factor Combinations\ndef solve_254():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Factor Combinations",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 255,
    "title": "Verify Preorder Sequence in Binary Search Tree",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "55%",
    "fullDescription": "Problem 255: Verify Preorder Sequence in Binary Search Tree - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Verify Preorder Sequence in Binary Search Tree",
        "output": "Expected output for Verify Preorder Sequence in Binary Search Tree",
        "explanation": "Explanation of how to solve Verify Preorder Sequence in Binary Search Tree"
      }
    ],
    "pseudocode": "Algorithm for Verify Preorder Sequence in Binary Search Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Verify Preorder Sequence in Binary Search Tree\ndef solve_255():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Verify Preorder Sequence in Binary Search Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 256,
    "title": "Paint House",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "56%",
    "fullDescription": "Problem 256: Paint House - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Paint House",
        "output": "Expected output for Paint House",
        "explanation": "Explanation of how to solve Paint House"
      }
    ],
    "pseudocode": "Algorithm for Paint House:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Paint House\ndef solve_256():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Paint House",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 257,
    "title": "Binary Tree Paths",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "57%",
    "fullDescription": "Problem 257: Binary Tree Paths - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Binary Tree Paths",
        "output": "Expected output for Binary Tree Paths",
        "explanation": "Explanation of how to solve Binary Tree Paths"
      }
    ],
    "pseudocode": "Algorithm for Binary Tree Paths:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Binary Tree Paths\ndef solve_257():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Binary Tree Paths",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 258,
    "title": "Add Digits",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "58%",
    "fullDescription": "Problem 258: Add Digits - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Add Digits",
        "output": "Expected output for Add Digits",
        "explanation": "Explanation of how to solve Add Digits"
      }
    ],
    "pseudocode": "Algorithm for Add Digits:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Add Digits\ndef solve_258():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Add Digits",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 259,
    "title": "3Sum Smaller",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "59%",
    "fullDescription": "Problem 259: 3Sum Smaller - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for 3Sum Smaller",
        "output": "Expected output for 3Sum Smaller",
        "explanation": "Explanation of how to solve 3Sum Smaller"
      }
    ],
    "pseudocode": "Algorithm for 3Sum Smaller:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for 3Sum Smaller\ndef solve_259():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for 3Sum Smaller",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 260,
    "title": "Single Number III",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "60%",
    "fullDescription": "Problem 260: Single Number III - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Single Number III",
        "output": "Expected output for Single Number III",
        "explanation": "Explanation of how to solve Single Number III"
      }
    ],
    "pseudocode": "Algorithm for Single Number III:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Single Number III\ndef solve_260():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Single Number III",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 261,
    "title": "Graph Valid Tree",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "61%",
    "fullDescription": "Problem 261: Graph Valid Tree - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Graph Valid Tree",
        "output": "Expected output for Graph Valid Tree",
        "explanation": "Explanation of how to solve Graph Valid Tree"
      }
    ],
    "pseudocode": "Algorithm for Graph Valid Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Graph Valid Tree\ndef solve_261():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Graph Valid Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 262,
    "title": "Trips and Users",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "62%",
    "fullDescription": "Problem 262: Trips and Users - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Trips and Users",
        "output": "Expected output for Trips and Users",
        "explanation": "Explanation of how to solve Trips and Users"
      }
    ],
    "pseudocode": "Algorithm for Trips and Users:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Trips and Users\ndef solve_262():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Trips and Users",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 263,
    "title": "Ugly Number",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "63%",
    "fullDescription": "Problem 263: Ugly Number - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Ugly Number",
        "output": "Expected output for Ugly Number",
        "explanation": "Explanation of how to solve Ugly Number"
      }
    ],
    "pseudocode": "Algorithm for Ugly Number:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Ugly Number\ndef solve_263():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Ugly Number",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 264,
    "title": "Ugly Number II",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Math",
      "Dynamic Programming"
    ],
    "acceptance": "47.1%",
    "fullDescription": "Find nth ugly number using dynamic programming approach.",
    "testCases": [
      {
        "input": "n = 10",
        "output": "12",
        "explanation": "10th ugly number is 12."
      }
    ],
    "pseudocode": "Three pointers approach\nMultiply by 2, 3, 5",
    "pythonCode": "Three pointers DP",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "Three pointers",
      "Multiply factors",
      "DP approach"
    ]
  },
  {
    "id": 265,
    "title": "Paint House II",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "65%",
    "fullDescription": "Problem 265: Paint House II - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Paint House II",
        "output": "Expected output for Paint House II",
        "explanation": "Explanation of how to solve Paint House II"
      }
    ],
    "pseudocode": "Algorithm for Paint House II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Paint House II\ndef solve_265():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Paint House II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 266,
    "title": "Palindrome Permutation",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "66%",
    "fullDescription": "Problem 266: Palindrome Permutation - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Palindrome Permutation",
        "output": "Expected output for Palindrome Permutation",
        "explanation": "Explanation of how to solve Palindrome Permutation"
      }
    ],
    "pseudocode": "Algorithm for Palindrome Permutation:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Palindrome Permutation\ndef solve_266():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Palindrome Permutation",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 267,
    "title": "Palindrome Permutation II",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "67%",
    "fullDescription": "Problem 267: Palindrome Permutation II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Palindrome Permutation II",
        "output": "Expected output for Palindrome Permutation II",
        "explanation": "Explanation of how to solve Palindrome Permutation II"
      }
    ],
    "pseudocode": "Algorithm for Palindrome Permutation II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Palindrome Permutation II\ndef solve_267():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Palindrome Permutation II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 268,
    "title": "Missing Number",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "68%",
    "fullDescription": "Problem 268: Missing Number - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Missing Number",
        "output": "Expected output for Missing Number",
        "explanation": "Explanation of how to solve Missing Number"
      }
    ],
    "pseudocode": "Algorithm for Missing Number:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Missing Number\ndef solve_268():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Missing Number",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 269,
    "title": "Alien Dictionary",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "69%",
    "fullDescription": "Problem 269: Alien Dictionary - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Alien Dictionary",
        "output": "Expected output for Alien Dictionary",
        "explanation": "Explanation of how to solve Alien Dictionary"
      }
    ],
    "pseudocode": "Algorithm for Alien Dictionary:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Alien Dictionary\ndef solve_269():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Alien Dictionary",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 270,
    "title": "Closest Binary Search Tree Value",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "40%",
    "fullDescription": "Problem 270: Closest Binary Search Tree Value - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Closest Binary Search Tree Value",
        "output": "Expected output for Closest Binary Search Tree Value",
        "explanation": "Explanation of how to solve Closest Binary Search Tree Value"
      }
    ],
    "pseudocode": "Algorithm for Closest Binary Search Tree Value:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Closest Binary Search Tree Value\ndef solve_270():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Closest Binary Search Tree Value",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 271,
    "title": "Encode and Decode Strings",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "41%",
    "fullDescription": "Problem 271: Encode and Decode Strings - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Encode and Decode Strings",
        "output": "Expected output for Encode and Decode Strings",
        "explanation": "Explanation of how to solve Encode and Decode Strings"
      }
    ],
    "pseudocode": "Algorithm for Encode and Decode Strings:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Encode and Decode Strings\ndef solve_271():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Encode and Decode Strings",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 272,
    "title": "Closest Binary Search Tree Value II",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "42%",
    "fullDescription": "Problem 272: Closest Binary Search Tree Value II - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Closest Binary Search Tree Value II",
        "output": "Expected output for Closest Binary Search Tree Value II",
        "explanation": "Explanation of how to solve Closest Binary Search Tree Value II"
      }
    ],
    "pseudocode": "Algorithm for Closest Binary Search Tree Value II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Closest Binary Search Tree Value II\ndef solve_272():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Closest Binary Search Tree Value II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 273,
    "title": "Integer to English Words",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "43%",
    "fullDescription": "Problem 273: Integer to English Words - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Integer to English Words",
        "output": "Expected output for Integer to English Words",
        "explanation": "Explanation of how to solve Integer to English Words"
      }
    ],
    "pseudocode": "Algorithm for Integer to English Words:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Integer to English Words\ndef solve_273():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Integer to English Words",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 274,
    "title": "H-Index",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "44%",
    "fullDescription": "Problem 274: H-Index - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for H-Index",
        "output": "Expected output for H-Index",
        "explanation": "Explanation of how to solve H-Index"
      }
    ],
    "pseudocode": "Algorithm for H-Index:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for H-Index\ndef solve_274():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for H-Index",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 275,
    "title": "H-Index II",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "45%",
    "fullDescription": "Problem 275: H-Index II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for H-Index II",
        "output": "Expected output for H-Index II",
        "explanation": "Explanation of how to solve H-Index II"
      }
    ],
    "pseudocode": "Algorithm for H-Index II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for H-Index II\ndef solve_275():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for H-Index II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 276,
    "title": "Paint Fence",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "46%",
    "fullDescription": "Problem 276: Paint Fence - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Paint Fence",
        "output": "Expected output for Paint Fence",
        "explanation": "Explanation of how to solve Paint Fence"
      }
    ],
    "pseudocode": "Algorithm for Paint Fence:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Paint Fence\ndef solve_276():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Paint Fence",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 277,
    "title": "Find the Celebrity",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "47%",
    "fullDescription": "Problem 277: Find the Celebrity - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Find the Celebrity",
        "output": "Expected output for Find the Celebrity",
        "explanation": "Explanation of how to solve Find the Celebrity"
      }
    ],
    "pseudocode": "Algorithm for Find the Celebrity:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Find the Celebrity\ndef solve_277():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Find the Celebrity",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 278,
    "title": "First Bad Version",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "48%",
    "fullDescription": "Problem 278: First Bad Version - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for First Bad Version",
        "output": "Expected output for First Bad Version",
        "explanation": "Explanation of how to solve First Bad Version"
      }
    ],
    "pseudocode": "Algorithm for First Bad Version:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for First Bad Version\ndef solve_278():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for First Bad Version",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 279,
    "title": "Perfect Squares",
    "difficulty": "Medium",
    "tags": [
      "Math",
      "Dynamic Programming",
      "Breadth-First Search"
    ],
    "acceptance": "52.1%",
    "fullDescription": "Find minimum number of perfect squares that sum to n using dynamic programming.",
    "testCases": [
      {
        "input": "n = 12",
        "output": "3",
        "explanation": "12 = 4 + 4 + 4."
      }
    ],
    "pseudocode": "DP array for minimum squares\nCheck all perfect squares",
    "pythonCode": "DP approach",
    "timeComplexity": "O(n\u221an)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "DP array",
      "Perfect squares",
      "Minimum count"
    ]
  },
  {
    "id": 280,
    "title": "Wiggle Sort",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "50%",
    "fullDescription": "Problem 280: Wiggle Sort - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Wiggle Sort",
        "output": "Expected output for Wiggle Sort",
        "explanation": "Explanation of how to solve Wiggle Sort"
      }
    ],
    "pseudocode": "Algorithm for Wiggle Sort:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Wiggle Sort\ndef solve_280():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Wiggle Sort",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 281,
    "title": "Zigzag Iterator",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "51%",
    "fullDescription": "Problem 281: Zigzag Iterator - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Zigzag Iterator",
        "output": "Expected output for Zigzag Iterator",
        "explanation": "Explanation of how to solve Zigzag Iterator"
      }
    ],
    "pseudocode": "Algorithm for Zigzag Iterator:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Zigzag Iterator\ndef solve_281():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Zigzag Iterator",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 282,
    "title": "Expression Add Operators",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "52%",
    "fullDescription": "Problem 282: Expression Add Operators - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Expression Add Operators",
        "output": "Expected output for Expression Add Operators",
        "explanation": "Explanation of how to solve Expression Add Operators"
      }
    ],
    "pseudocode": "Algorithm for Expression Add Operators:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Expression Add Operators\ndef solve_282():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Expression Add Operators",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 283,
    "title": "Move Zeroes",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "53%",
    "fullDescription": "Problem 283: Move Zeroes - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Move Zeroes",
        "output": "Expected output for Move Zeroes",
        "explanation": "Explanation of how to solve Move Zeroes"
      }
    ],
    "pseudocode": "Algorithm for Move Zeroes:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Move Zeroes\ndef solve_283():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Move Zeroes",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 284,
    "title": "Peeking Iterator",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "54%",
    "fullDescription": "Problem 284: Peeking Iterator - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Peeking Iterator",
        "output": "Expected output for Peeking Iterator",
        "explanation": "Explanation of how to solve Peeking Iterator"
      }
    ],
    "pseudocode": "Algorithm for Peeking Iterator:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Peeking Iterator\ndef solve_284():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Peeking Iterator",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 285,
    "title": "Inorder Successor in BST",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "55%",
    "fullDescription": "Problem 285: Inorder Successor in BST - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Inorder Successor in BST",
        "output": "Expected output for Inorder Successor in BST",
        "explanation": "Explanation of how to solve Inorder Successor in BST"
      }
    ],
    "pseudocode": "Algorithm for Inorder Successor in BST:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Inorder Successor in BST\ndef solve_285():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Inorder Successor in BST",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 286,
    "title": "Walls and Gates",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "56%",
    "fullDescription": "Problem 286: Walls and Gates - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Walls and Gates",
        "output": "Expected output for Walls and Gates",
        "explanation": "Explanation of how to solve Walls and Gates"
      }
    ],
    "pseudocode": "Algorithm for Walls and Gates:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Walls and Gates\ndef solve_286():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Walls and Gates",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 287,
    "title": "Find the Duplicate Number",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "57%",
    "fullDescription": "Problem 287: Find the Duplicate Number - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Find the Duplicate Number",
        "output": "Expected output for Find the Duplicate Number",
        "explanation": "Explanation of how to solve Find the Duplicate Number"
      }
    ],
    "pseudocode": "Algorithm for Find the Duplicate Number:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Find the Duplicate Number\ndef solve_287():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Find the Duplicate Number",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 288,
    "title": "Unique Word Abbreviation",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "58%",
    "fullDescription": "Problem 288: Unique Word Abbreviation - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Unique Word Abbreviation",
        "output": "Expected output for Unique Word Abbreviation",
        "explanation": "Explanation of how to solve Unique Word Abbreviation"
      }
    ],
    "pseudocode": "Algorithm for Unique Word Abbreviation:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Unique Word Abbreviation\ndef solve_288():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Unique Word Abbreviation",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 289,
    "title": "Game of Life",
    "difficulty": "Easy",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "59%",
    "fullDescription": "Problem 289: Game of Life - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Game of Life",
        "output": "Expected output for Game of Life",
        "explanation": "Explanation of how to solve Game of Life"
      }
    ],
    "pseudocode": "Algorithm for Game of Life:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Game of Life\ndef solve_289():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Game of Life",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 290,
    "title": "Word Pattern",
    "difficulty": "Hard",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "60%",
    "fullDescription": "Problem 290: Word Pattern - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Word Pattern",
        "output": "Expected output for Word Pattern",
        "explanation": "Explanation of how to solve Word Pattern"
      }
    ],
    "pseudocode": "Algorithm for Word Pattern:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Word Pattern\ndef solve_290():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Word Pattern",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 291,
    "title": "Word Pattern II",
    "difficulty": "Medium",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "61%",
    "fullDescription": "Problem 291: Word Pattern II - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Word Pattern II",
        "output": "Expected output for Word Pattern II",
        "explanation": "Explanation of how to solve Word Pattern II"
      }
    ],
    "pseudocode": "Algorithm for Word Pattern II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Word Pattern II\ndef solve_291():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Word Pattern II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 292,
    "title": "Nim Game",
    "difficulty": "Easy",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "62%",
    "fullDescription": "Problem 292: Nim Game - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Nim Game",
        "output": "Expected output for Nim Game",
        "explanation": "Explanation of how to solve Nim Game"
      }
    ],
    "pseudocode": "Algorithm for Nim Game:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Nim Game\ndef solve_292():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Nim Game",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 293,
    "title": "Flip Game",
    "difficulty": "Hard",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "63%",
    "fullDescription": "Problem 293: Flip Game - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Flip Game",
        "output": "Expected output for Flip Game",
        "explanation": "Explanation of how to solve Flip Game"
      }
    ],
    "pseudocode": "Algorithm for Flip Game:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Flip Game\ndef solve_293():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Flip Game",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 294,
    "title": "Flip Game II",
    "difficulty": "Medium",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "64%",
    "fullDescription": "Problem 294: Flip Game II - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Flip Game II",
        "output": "Expected output for Flip Game II",
        "explanation": "Explanation of how to solve Flip Game II"
      }
    ],
    "pseudocode": "Algorithm for Flip Game II:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Flip Game II\ndef solve_294():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Flip Game II",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 295,
    "title": "Find Median from Data Stream",
    "difficulty": "Easy",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "65%",
    "fullDescription": "Problem 295: Find Median from Data Stream - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Find Median from Data Stream",
        "output": "Expected output for Find Median from Data Stream",
        "explanation": "Explanation of how to solve Find Median from Data Stream"
      }
    ],
    "pseudocode": "Algorithm for Find Median from Data Stream:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Find Median from Data Stream\ndef solve_295():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Find Median from Data Stream",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 296,
    "title": "Best Meeting Point",
    "difficulty": "Hard",
    "tags": [
      "Array",
      "String"
    ],
    "acceptance": "66%",
    "fullDescription": "Problem 296: Best Meeting Point - An array manipulation problem that tests your understanding of array operations, indexing, and algorithmic thinking.",
    "testCases": [
      {
        "input": "Example input for Best Meeting Point",
        "output": "Expected output for Best Meeting Point",
        "explanation": "Explanation of how to solve Best Meeting Point"
      }
    ],
    "pseudocode": "Algorithm for Best Meeting Point:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Best Meeting Point\ndef solve_296():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Best Meeting Point",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 297,
    "title": "Serialize and Deserialize Binary Tree",
    "difficulty": "Medium",
    "tags": [
      "Dynamic Programming"
    ],
    "acceptance": "67%",
    "fullDescription": "Problem 297: Serialize and Deserialize Binary Tree - A dynamic programming problem that challenges your ability to break down complex problems into overlapping subproblems.",
    "testCases": [
      {
        "input": "Example input for Serialize and Deserialize Binary Tree",
        "output": "Expected output for Serialize and Deserialize Binary Tree",
        "explanation": "Explanation of how to solve Serialize and Deserialize Binary Tree"
      }
    ],
    "pseudocode": "Algorithm for Serialize and Deserialize Binary Tree:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Serialize and Deserialize Binary Tree\ndef solve_297():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Serialize and Deserialize Binary Tree",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 298,
    "title": "Binary Tree Longest Consecutive Sequence",
    "difficulty": "Easy",
    "tags": [
      "Tree",
      "Graph"
    ],
    "acceptance": "68%",
    "fullDescription": "Problem 298: Binary Tree Longest Consecutive Sequence - A tree traversal problem that tests your understanding of binary trees, tree algorithms, and recursive thinking.",
    "testCases": [
      {
        "input": "Example input for Binary Tree Longest Consecutive Sequence",
        "output": "Expected output for Binary Tree Longest Consecutive Sequence",
        "explanation": "Explanation of how to solve Binary Tree Longest Consecutive Sequence"
      }
    ],
    "pseudocode": "Algorithm for Binary Tree Longest Consecutive Sequence:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Binary Tree Longest Consecutive Sequence\ndef solve_298():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Binary Tree Longest Consecutive Sequence",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 299,
    "title": "Bulls and Cows",
    "difficulty": "Hard",
    "tags": [
      "Hash Table",
      "Two Pointers"
    ],
    "acceptance": "69%",
    "fullDescription": "Problem 299: Bulls and Cows - A computational problem that tests your algorithmic thinking and problem-solving skills.",
    "testCases": [
      {
        "input": "Example input for Bulls and Cows",
        "output": "Expected output for Bulls and Cows",
        "explanation": "Explanation of how to solve Bulls and Cows"
      }
    ],
    "pseudocode": "Algorithm for Bulls and Cows:\n1. Understand the problem\n2. Design the algorithm\n3. Implement the solution",
    "pythonCode": "# Solution for Bulls and Cows\ndef solve_299():\n    # Implementation here\n    pass",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "keyInsights": [
      "Key insight 1: Understand the problem constraints for Bulls and Cows",
      "Key insight 2: Consider edge cases and boundary conditions",
      "Key insight 3: Optimize for time and space complexity"
    ]
  },
  {
    "id": 300,
    "title": "Longest Increasing Subsequence",
    "difficulty": "Medium",
    "tags": [
      "Array",
      "Binary Search",
      "Dynamic Programming"
    ],
    "acceptance": "52.1%",
    "fullDescription": "Find length of longest increasing subsequence using dynamic programming.",
    "testCases": [
      {
        "input": "nums = [10,9,2,5,3,7,101,18]",
        "output": "4",
        "explanation": "LIS is [2,5,7,101] with length 4."
      }
    ],
    "pseudocode": "DP array for LIS length\nBinary search optimization",
    "pythonCode": "DP with binary search",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "keyInsights": [
      "DP array",
      "Binary search",
      "LIS tracking"
    ]
  }
];

// Export for use in other files
if (typeof module !== 'undefined' && module.exports) {
    module.exports = topLeetCodeProblems;
}
